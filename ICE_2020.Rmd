---
title: "Índice de Calidad del Entorno"
author: "Diana Villasana Ocampo"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::bs4_book,
  set in the _output.yml file.
biblio-style: apalike
csl: chicago-fullnote-bibliography.csl
---
```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```

# Introducción {.unlisted .unnumbered}

**Promoción de la Urbanización Sostenible por ONU-Habitat**

La Organización de las Naciones Unidas, a través de ONU-Habitat, impulsa una urbanización sostenible como motor de desarrollo, paz y derechos humanos. La rápida urbanización ha incrementado los habitantes en barrios pobres, infraestructuras y servicios sobrecargados, empeorando la contaminación del aire y el crecimiento urbano descontrolado. Por ello, el Objetivo 11 de los Objetivos de Desarrollo Sostenible (ODS) es crucial: “lograr que las ciudades y los asentamientos humanos sean inclusivos, seguros, resilientes y sostenibles”.    

**Plan Nacional de Desarrollo 2019–2024**  

En México, el Plan Nacional de Desarrollo 2019–2024 promueve garantizar los derechos económicos, sociales, culturales y ambientales en poblaciones y territorios, alineado con los objetivos de desarrollo sostenible.    

**Índice de Calidad del Entorno (ICE) por CONAPO**    

La Secretaría General del Consejo Nacional de Población (CONAPO) presenta el Índice de Calidad del Entorno (ICE), un indicador compuesto que analiza las características de los asentamientos humanos, determinadas por las condiciones de marginación y la disponibilidad de servicios y equipamiento urbano. El ICE se desglosa en dos niveles geográficos: municipio y localidad, y se estructura en tres dimensiones:    

1. **Dimensión sociodemográfica**: Basada en indicadores socioeconómicos de los índices de marginación a nivel municipal y localidad (CONAPO, 2021a y 2021b).   
2. **Dimensión de equipamiento**: Analiza la disponibilidad de equipamiento y servicios públicos y privados, organizados en subsistemas según el Sistema Normativo de Equipamiento (SEDESOL, 2012). Los datos provienen de fuentes como el DENUE (INEGI, 2021), SIGED (SEP, 2021) y CLUES (DGIS, 2021).    

<a href="/images/Estructura/IE_Estructura.png" data-lightbox="image-1" data-title="metodologia">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Estructura/IE_Estructura.png"))
```
</a>

3. **Dimensión de accesibilidad y aislamiento geográfico**: Utiliza el tiempo de viaje a centros urbanos según el censo 2020, como parte del estudio de accesibilidad geoespacial (CONAPO/IMT/CentroGeo, 2022).   

## Estructura del índice de calidad del entorno {-}

```{r, echo = FALSE}
readRDS(file = paste0(here::here(), "/images/Estructura/Estructura_ICE.RDS"))
```

**Metodología del ICE.**

La construcción del ICE se realizó en cuatro etapas:   

1. **Generación y análisis de indicadores simples asociados a las dimensiones**.    
2. **Análisis de Componentes Principales (ACP)**: Reducción de variables a componentes que explican la mayor varianza de los datos originales, generando un sistema de ponderación.         
3. **Regresión de Componentes Principales (RCP)**: Método predictivo para estimar escenarios extremos y aplicar el método de distancias $DP_2$ para obtener el ICE.   
4. **Generación del ICE con el método $DP_2$**: Obtención de un índice sintético agregando la información de los indicadores.   


**Técnicas Multivariantes Complementarias**    

El uso de $ACP$ y $DP_{2}$ ha sido explorado en otras investigaciones. Pena (1977) argumenta que ambas técnicas son consistentes para comparar la posición relativa de las filas y obtener factores comunes de las columnas. Somarriba (2008) resalta que las agrupaciones en componentes no condicionan los resultados del indicador sintético, enfocándose en los indicadores relevantes. Investigaciones adicionales que han utilizado estas técnicas incluyen trabajos de Zarzosa y Somarriba.   

Este resumen proporciona una visión integral del Índice de Calidad del Entorno, destacando su relevancia en la evaluación de los asentamientos humanos y la importancia de la urbanización sostenible en el marco del desarrollo nacional y global.     

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                       eval = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(rprojroot::find_rstudio_root_file())
```  

```{r, echo=FALSE, results=FALSE}
#Font Stlye
require(showtext)
library(extrafont)
# activar showtext
windowsFonts()
#Century Gothic
```

```{r, echo = FALSE}
# Librerías que se usaron en el documento
require(corrplot)
require(doMC)
require(dplyr)
require(extrafont)
require(factoextra)
require(FactoMineR)
require(ggplot2)
require(ggthemes)
require(ggpubr)
require(hrbrthemes)
require(haven)
require(Hmisc)
require(kableExtra)
require(knitr)
require(openxlsx)
require(paletteer)
require(p2distance)
require(pls)
library(plotly)
require(readxl)
require(reshape2)
require(rrcov)
require(showtext)
require(stratification)
require(tibble)
require(tidyr)
require(unikn)
require(visNetwork)
set.seed(321)
```
```{r include=FALSE, eval=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'dp2distance', 'statification', 'corrplot'
), 'packages.bib')
```

**Estrcutura del documento**

- [Metodología](https://dvillasanao.github.io/ICE_2020/metodolog%C3%ADa.html)    
- [Fuentes de información](https://dvillasanao.github.io/ICE_2020/fuentes-de-informaci%C3%B3n.html)    
- [Índice de Calidad del Entorno (Nivel Municipal)](https://dvillasanao.github.io/ICE_2020/municipio-4.html)   
- [Índice de Calidad del Entorno (Nivel Localidad)](https://dvillasanao.github.io/ICE_2020/localidad-4.html)   
- [Índice de Calidad del Entorno (Nivel AGEB)](https://dvillasanao.github.io/ICE_2020/ageb-3.html)  
- [Resumen General](https://dvillasanao.github.io/ICE_2020/resumen-general.html)  

```{block2, type='rmdwarning'}
Este material no es introductorio al uso de R.
```

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Metodología {.unlisted .unnumbered}

<a href="images/Metodología ICE.png" data-lightbox="image-1" data-title="metodologia">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Estructura/Metodología ICE.png"))
```
</a>


## Primera etapa: construcción de indicadores {-} 

De acuerdo con los 13 subsistemas de equipamiento, se tomaron en consideración 71 variables que agruparon a los sectores propuesto en el Sistema Normativo de Equipamiento (SEDESOL, 2012). Dada las limitaciones en la disponibilidad de datos e información oficial disponible para la conformación de las variables, estas se construyeron como porcentaje de los equipamientos disponibles en las localidades respecto al total del municipio y sector correspondiente:   

$$w_{hjk} = \sum_{h=1}^{N_{h}} \sum_{j=1}^{n_{h}}\frac{S_{hjk}}{S_{hk}}; \text{donde k: 1,2,...,m} $$
donde: 

- $w_{hjk}$: Razón de la característica de interés en la $j-ésima$ localidad del $h-ésimo$ municipio,    
- $n_{h}$: Número de localidades en el $h-ésimo$ municipio,    
- $N_{h}$: Total de localidades en el $h-ésimo$ municipio,   
- $S_{hk}$: Total de la característica de interés del $h-ésimo$ municipio,   
- $S_{hk}$: Total de la característica de interés en la localidad $j-ésima$ del $h-ésimo$ municipio.   


## Segunda etapa: Análisis de Componentes Principales (PCA) {-}   

El Análisis de Componentes Principales (PCA, por sus siglas en inglés) es un método estadístico utilizado para reducir la complejidad de un conjunto de datos. El objetivo es transformar las variables originales en un conjunto más pequeño y manejable de nuevas variables llamadas "componentes principales".   

Este método se basa en el cálculo de una matriz de covarianzas o correlaciones entre las variables originales, y en la posterior obtención de los vectores y valores propios de esta matriz. Los vectores propios representan las direcciones en las que los datos tienen la mayor variabilidad, y los valores propios indican la cantidad de variabilidad explicada por cada componente principal. Los valores propios se ordenan de mayor a menor, de manera que el primer componente principal explica la mayor parte de la variabilidad en los datos, y cada componente subsiguiente explica una proporción menor. Los componentes principales se utilizan para describir los datos y construir modelos estadísticos más sencillos.  

En resumen, el PCA es un método estadístico que reduce la complejidad de un conjunto de datos al transformar las variables originales en un conjunto más pequeño de nuevas variables que explican la mayor parte de la variabilidad de los datos.   

### Ventajas y Desventajas del PCA {-}  

**Ventajas:**  

- **Reducción de la dimensionalidad**: PCA permite reducir el número de variables utilizadas para describir un conjunto de datos, facilitando su visualización y análisis.   
- **Identificación de patrones**: Al identificar los componentes principales, el PCA puede ayudar a encontrar patrones o relaciones entre las variables que no eran evidentes en los datos originales.   
- **Eliminación de variables redundantes**: PCA puede eliminar variables altamente correlacionadas, mejorando la eficiencia computacional y la interpretación de los resultados.   
- **Normalización de los datos**: PCA normaliza los datos, eliminando problemas de escala o unidades diferentes entre las variables originales.   

**Desventajas:**    

- **Interpretación**: La interpretación de los componentes principales puede ser difícil, especialmente si no se tiene un conocimiento profundo del conjunto de datos.    
- **Pérdida de información**: PCA puede eliminar información útil si se descartan componentes con baja variabilidad que podrían ser importantes para la descripción de los datos.   
- **Sensibilidad a los datos atípicos**: PCA puede verse afectado por datos atípicos, resultando en componentes que no reflejan adecuadamente la variabilidad en los datos.    
- **Requisitos computacionales**: PCA puede requerir muchos recursos computacionales, especialmente para conjuntos de datos grandes.  

### Aplicación del PCA {-}  

El PCA es una técnica estadística no supervisada que permite reducir la complejidad de múltiples dimensiones, conservando la información en unas pocas componentes. Dada una matriz de datos con $p \times p$ variables y $n \times n$ observaciones, donde los datos están centrados y escalados con su desviación estándar, se asegura que la nube de datos esté centrada en el origen de las componentes principales, sin verse afectada por las relaciones espaciales entre las variables. 

El PCA busca transformar el espacio vectorial generado por un vector $\mathrm{X=}\left(\mathrm{\ }X_{n1},\ {\ X}_{n2},\ ...\ ,\ X_{np}\right)$ en un nuevo conjunto $\mathrm{Z\ =\ }\left(\mathrm{\ }Z_1,\ {\ Z}_2,\ ...\ ,\ Z_k\right),\ \ k\le p$, que sean combinaciones lineales de los indicadores y que expliquen la mayor parte de la variabilidad. Esto se expresa como:  

$$Z\ =\ XA$$
donde:  
$A\ =\ \left(a_{n1},\ a_{n2},\ ...,\ a_{np}\right)$ representa las posiciones de cada observación en este nuevo sistema de coordenadas de componentes principales, denominadas *loadings*, y se calculan como combinaciones lineales de las variables originales y los pesos $a_{np}$.    

El PCA también permite conocer la proporción de la varianza explicada por cada componente principal, además de la varianza total presente en un conjunto de datos:   

$$\sum_{j=1}^{p}{Var\left(X_j\right)\ =}\ \sum_{j=1}^{p}\frac{1}{n}\sum_{i=1}^{n}x_{ij}^2$$
La varianza explicada por el $k-ésima$ componente principal se define como:  

$$\frac{1}{n}\sum_{1=1}^{n}z_{ik}^2=\frac{1}{n}\sum_{1=1}^{n}\left(\sum_{j=1}^{p}{a_{nj}x_{ij}}\right)^2\ $$ 

Por lo tanto, la proporción de la varianza explicada del $k-ésimo$ componente principal está dada por:    

$$\frac{\sum_{i=1}^{n}\left(\sum_{j=1}^{p}{a_{nj}x_{ij}}\right)^2}{\sum_{j=1}^{p}\frac{1}{n}\sum_{i=1}^{n}x_{ij}^2}$$

En total, hay $min(n\ -\ 1,\ \ p))$ componentes principales, y la suma de la proporción de la varianza explicada es uno.  

### Validación del PCA {-}  

Para validar el PCA, se considera la calidad de la representación de las variables en la construcción del modelo, lo que permite evaluar la estabilidad de las variables en los componentes. También se identifican los valores atípicos y se determina en qué medida influyen en la construcción de los indicadores.   


### Descomposición de componentes principales {-}  

En el análisis de componentes principales, se puede descomponer la matriz de varianzas y covarianzas de dos maneras diferentes:

Descomposición en valores propios (eigendecomposition): Esta descomposición se utiliza cuando la matriz de varianzas y covarianzas es simétrica y definida positiva. En este caso, la matriz se descompone en una matriz de autovectores y una matriz diagonal de valores propios. Los autovectores forman una base ortogonal que describe las direcciones principales de la varianza en los datos, mientras que los valores propios indican la importancia relativa de cada dirección.

Descomposición en valores singulares (singular value decomposition, SVD): Esta descomposición se utiliza cuando la matriz de varianzas y covarianzas no es simétrica o no es definida positiva. En este caso, la matriz se descompone en tres matrices: una matriz de autovectores izquierdos, una matriz de autovectores derechos y una matriz diagonal de valores singulares. Los autovectores izquierdos y derechos forman una base ortogonal que describe las direcciones principales de la varianza en los datos, mientras que los valores singulares indican la importancia relativa de cada dirección.

En ambas descomposiciones, se pueden seleccionar las componentes principales más importantes para reducir la dimensionalidad de los datos y simplificar su análisis.   

<a href="images/SVD.png" data-lightbox="image-1" data-title="SVD">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Estructura/SVD.png"))
```
</a>

<a href="images/SVD_Page_2.png" data-lightbox="image-1" data-title="SVD_2">
```{r, echo = FALSE, fig.width=8, fig.height=8, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/images/Estructura/SVD_Page_2.png"))
```
</a>



### Identificación de datos atípicos {-}   

Los datos atípicos (también conocidos como *valores extremos* o *outliers*) pueden tener un impacto significativo en los resultados del método de componentes principales (`PCA`). Si los datos atípicos no se manejan adecuadamente, pueden llevar a resultados sesgados o incorrectos. Por lo tanto, es importante identificarlos y considerar cuidadosamente cómo manejarlos antes de realizar el análisis de PCA.        

Existen algunas estrategias para manejar los datos atípicos dentro del análisis de  PCA:

- **Identificación de los datos atípicos**: Es importante identificar los datos atípicos antes de realizar el análisis de PCA. Esto se puede hacer mediante la visualización de los datos o mediante pruebas estadísticas.      

- **Exclusión de los datos atípicos**: Una estrategia común para manejar los datos atípicos es excluirlos del análisis. Sin embargo, esto debe hacerse con cuidado, ya que la exclusión de los datos atípicos puede resultar en una pérdida de información importante.    

- **Transformación de los datos**: Otra estrategia es transformar los datos antes de realizar el análisis de PCA. Las transformaciones comunes incluyen la transformación logarítmica o la normalización de los datos. Estas transformaciones pueden reducir la influencia de los datos atípicos y mejorar los resultados de PCA.     

- **Uso de métodos robustos**: Existen métodos robustos que pueden manejar los datos atípicos de manera efectiva en PCA, como el método de componentes principales robustos (`RPCA`, por sus siglas en inglés). Estos métodos son menos sensibles a los datos atípicos y pueden proporcionar resultados más precisos.        


### Método de Componentes Principales Robustos `RPCA`  {-}

El método de componentes principales robustos (`RPCA`, por sus siglas en inglés) se utiliza cuando se sospecha que los datos contienen valores atípicos o errores que pueden afectar los resultados del análisis de componentes principales (PCA).    

El RPCA es una versión modificada del método de componentes principales tradicional que es menos sensible a los valores atípicos y a los errores en los datos. En lugar de minimizar la varianza total de los datos como en PCA, RPCA minimiza la varianza total de los datos después de excluir los valores atípicos o errores. Ete tipo de análisis puede ser útil en una variedad de situaciones, como en el análisis de datos biomédicos, análisis financiero, análisis de datos climáticos, entre otros.     
 
En general, se recomienda utilizar RPCA cuando:

- Los datos pueden contener valores atípicos o errores.   

- Los datos tienen una distribución no normal.    

- Las variables tienen diferentes escalas.    

- El tamaño de la muestra es pequeño en comparación con la dimensión de los datos.    

- Se necesita una mayor precisión en los resultados del análisis.    

**Observaciones del método RPCA**

Es importante tener en cuenta que RPCA no siempre es necesario y puede ser computacionalmente más costoso que el método de componentes principales tradicional. Por lo tanto, es importante evaluar cuidadosamente si RPCA es apropiado para los datos que se estan tratando y los objetivos de análisis antes de utilizarlo.      

Aunque el método de componentes principales robustos (RPCA), es útil para manejar valores atípicos y errores en los datos, también presenta algunas desventajas que deben tenerse en cuenta:    

- **Mayor complejidad computacional**: El método RPCA puede ser más costoso computacionalmente que el método de componentes principales tradicional debido a la necesidad de excluir los valores atípicos o errores en los datos.    

- **Pérdida de información**: Al excluir los valores atípicos o errores en los datos, puede perderse información importante, lo que puede afectar la precisión de los resultados del análisis.   

- **Dependencia del modelo**: El método RPCA se basa en un modelo específico de distribución de datos, por lo que si los datos no se ajustan a este modelo, los resultados pueden ser incorrectos o inexactos.    

- **Selección de parámetros**: El método RPCA requiere la selección de parámetros para determinar qué valores se consideran atípicos o errores, lo que puede ser subjetivo y afectar los resultados del análisis.     


## Tercera etapa: Regresión de Componentes Principales (`PCR`) {-}

El modelo de PCR es un método utilizado para reducir la dimensionalidad de los datos y evitar problemas de multicolinealidad en un modelo de regresión lineal múltiple. Este modelo se basa en la descomposición en valores singulares (SVD) de la matriz de datos originales, lo que permite identificar las componentes principales que explican la mayor parte de la varianza en los datos.

A partir de las componentes principales seleccionadas, se construye un modelo de regresión lineal múltiple utilizando estas componentes como variables predictoras. El número de componentes principales seleccionadas se determina de acuerdo con un criterio predefinido, como la cantidad de varianza explicada o un límite para el número de componentes.

El modelo de PCR puede ser una alternativa útil a la selección tradicional de variables predictoras en un modelo de regresión lineal, ya que permite reducir la dimensionalidad de los datos y evitar problemas de multicolinealidad. Sin embargo, es importante tener en cuenta que el modelo de PCR también tiene algunas limitaciones, como la interpretación de los coeficientes de regresión y la posible pérdida de información importante en los datos. Por lo tanto, se recomienda utilizar el modelo de PCR en combinación con otras técnicas de análisis de datos para obtener una comprensión completa del problema.


**Singular value descomposición**  

En el modelo de Regresión de Componentes Principales (PCR, por sus siglas en inglés), se utiliza la descomposición en valores singulares (SVD) para encontrar las componentes principales de los datos y reducir su dimensionalidad.

La idea detrás del PCR es utilizar las componentes principales de los datos (obtenidas a través de la SVD) como variables predictoras en un modelo de regresión lineal múltiple. De esta manera, se puede reducir el número de variables predictoras y evitar problemas de multicolinealidad, lo que puede mejorar la precisión del modelo y hacerlo más interpretable.

En resumen, para implementar el modelo de PCR se utilizan los resultados de la descomposición en valores singulares (SVD) para seleccionar las componentes principales de los datos y construir un modelo de regresión lineal múltiple. Por lo tanto, no se utiliza la descomposición en eigenvectores y eigenvalores.  


## Método de distancias ponderadas al cuadrado $DP_2$ {-}

El método de distancias ponderadas al cuadrado ($DP_2$) de José Bernardo Peña Trapero es una técnica estadística utilizada para medir la similitud entre diferentes objetos o casos. Este método se basa en una medida de distancia que se calcula sumando las diferencias al cuadrado ponderadas entre las características de dos objetos y tomando la raíz cuadrada del resultado. La ponderación de las características permite que las más importantes tengan un mayor impacto en el resultado final mientras que las menos importantes tienen un menor impacto.

El método DP2 de Peña Trapero se utiliza en una variedad de aplicaciones, como la clasificación de imágenes y la evaluación de la similitud entre diferentes textos. Una de las ventajas del método $DP_2$ es que puede manejar datos de diferentes tipos y escalas, lo que lo hace útil en situaciones donde los datos son heterogéneos.

Sin embargo, también hay algunas desventajas en el uso del método DP2, como la selección subjetiva de la función de ponderación de características y el costo computacional en grandes conjuntos de datos. Por lo tanto, se deben evaluar cuidadosamente los datos y los objetivos de análisis antes de aplicar este método.

En resumen, el método DP2 de Peña Trapero es una técnica útil para medir la similitud entre diferentes objetos o casos, pero se debe aplicar con cuidado y evaluar cuidadosamente en función de los datos y objetivos de análisis.


<!--chapter:end:01_Modelo.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Fuentes de información {.unnumbered}

Primeramente, las fuentes de información que se utilizaron para la realización del índice de calidad del entorno se enumeran a continuación:  



## Indicadores sociodemográficos {-}


El Censo de Población y Vivienda 2020 (CPV2020) del INEGI (Instituto Nacional de Estadística y Geografía) el objetivo fue recopilar información detallada y actualizada sobre la población y las viviendas de México para ser utilizada en la toma de decisiones y la planificación de políticas públicas y privadas en el país. Esto incluye datos sobre la cantidad y características de las personas que viven en el país, como su edad, sexo, educación, ocupación, entre otros aspectos, así como información sobre la estructura y características de las viviendas en las que habitan. El cúal este tpo de informción es importante para la planificación y la toma de decisiones en áreas como la política pública, la inversión en infraestructura, la distribución de recursos y servicios, la investigación demográfica y social, y muchas otras. Además, también es utilizado por empresas y organizaciones para el análisis de mercado y la toma de decisiones estratégicas.  


## Equipamiento {-}

<a href="/images/Estructura/IE_Subsectores.png" data-lightbox="image-1" data-title="Subsectores">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Estructura/IE_Subsectores.png"))
```
</a>


### DENUE {-}

[El Directorio Estadístico Nacional de Unidades Económicas (DENUE)](https://www.inegi.org.mx/rnm/index.php/catalog/668) es la infraestructura mínima del Subsistema Nacional de Información Económica (SNIE), cuyo propósito es proveer a los usuarios tanto especializados como no especializados de los datos de identificación, ubicación y contacto de las unidades económicas activas en el territorio nacional para el desarrollo y evaluación, tanto de políticas públicas como de programas de fomento económico en los tres niveles de gobierno; así como apoyo en el proceso de toma de decisiones para direccionar la inversión y optimizar recursos tanto en el ámbito público como en el privado.

[El Directorio Estadístico Nacional de Unidades Económicas (DENUE)](https://www.inegi.org.mx/rnm/index.php/catalog/668) del INEGI cuyo objetivo es proporcionar una base de datos actualizada y completa de las unidades económicas en México. Esto incluye empresas, establecimientos, instituciones gubernamentales, organizaciones sin fines de lucro, entre otras entidades que realizan actividades económicas en el país. Este tipo de insumo sirve como base para la planificación económica, la investigación y la toma de decisiones en áreas como la inversión, el análisis de mercado, el diseño de políticas públicas, la identificación de oportunidades comerciales, entre otras. Además, también es utilizado por el sector empresarial para el análisis de la competencia, la segmentación de mercado, la identificación de clientes potenciales, entre otros fines.


**[Sistema de Clasificación Industrial de América del Norte, 2018 (SCIAN)]** 

El objetivo del SCIAN México es proporcionar un marco único, consistente y actualizado para la recopilación, análisis y presentación de estadísticas de tipo económico, que refleje la estructura de la economía mexicana. El SCIAN México es la base para la generación, presentación y difusión de todas las estadísticas económicas del INEGI. Su adopción por parte de las Unidades del Estado, permitirá homologar la información económica que se produce en el país, y con ello contribuir a la de la región de América del Norte.   

**UNIDAD DE ANÁLISIS**

Las unidades económicas a las que está referida la información del DENUE son dos: El establecimiento y la empresa.

- **El establecimiento:** unidad económica que, en una sola ubicación física, asentada en un lugar de manera permanente y delimitada por construcciones e instalaciones fijas, combina acciones y recursos bajo el control de una sola entidad propietaria o controladora para realizar alguna actividad económica sea con fines de lucro o no.
    
    Incluye a las viviendas en las que se realizan actividades económicas y excluye a las viviendas en las que se llevan a cabo actividades económicas con fines de autoconsumo, así como los servicios que se realizan en otros sitios.
    
- **La empresa:** organización, propiedad de una sola entidad jurídica, que realiza una o más actividades económicas, con autonomía en la toma de decisiones de mercadeo, financiamiento e inversión, al contar con la autoridad y responsabilidad de distribuir recursos de acuerdo con un plan o estrategia de producción de bienes y servicios, pudiendo estar ubicada u operar en varios domicilios.
- **Se excluye** a las unidades económicas que llevan a cabo actividades de manera ambulante o aquellas en las que los locales en los que se efectúa la actividad económica son desmontables y se remueven diariamente.

Se consideran 13 subsistemas económicos de los cuales se clasificaron 52 elementos económicos que pertenecen a los subistemas. 

```{r, eval = FALSE, comment="R/01_SCIAN2018.R"}
load(paste0(here::here(), "/Bases/Claves_subsistema_SCIAN2018.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(paste0(here::here(), "/Bases/Claves_subsistema_SCIAN2018.RData"))
head(SCIAN, 10) %>% 
 gt() %>%
  tab_header(title = "Sistema de Clasificación Industrial de América del Norte, 2018 (SCIAN)",
             subtitle = "Estrucutura") %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = "Century Gothic",
                table.font.size = 10,
                table.align = 'center',
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left", 
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
      tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%
       tab_style(style = "vertical-align:middle; font-weight: bold",
                  locations = cells_column_labels()) %>% 
        cols_width(starts_with("ELEMENTO") ~ px(200),
                   starts_with("ESTRUCTURA_SCIAN2018") ~ px(800),
                   everything() ~ px(100)) %>%
          as_raw_html() 
```
</div>

Se cargan todas las bases del DENUE 2021 que se van a usar, el cúal después se van a seleccionar los subramos económicos. 


Descarga masiva
En esta sección podrás descargar los archivos del DENUE, el Banco de Indicadores, el Inventario Nacional de Viviendas, Microdatos y la Sala de prensa por área geográfica, proyectos, años de la información, temas y formatos para poder utilizar la información en forma local en tu equipo.
Title: Directorio Estadístico Nacional de Unidades Económicas (DENUE) 05_2021

Se muestra el algoritmo para integrar el DENUE 

```{r, eval = FALSE, class.source = 'fold-hide', comment="02_DENUE_Integrado.Rmd"}
tablas <- c("43", "46111", "46112-46311","46321-46531", "46591-46911", "48-49", "51", "52", "56", "61", "62", "71",  "72_1", "72_2", "81_1", "81_2")

# Enlaces de las bases de datos (Descargas masivas | INEGI | DENUE)
#https://www.inegi.org.mx/app/descarga/default.html
url <- read.table(file = "Bases/DENUE/Enlaces_DENUE_0521.txt", sep = ",")

for(i in 1:16){
  if(!file.exists(paste0(here::here(), "/Bases/DENUE/denue_00_", tablas[i], "_0521_csv.zip"))){
  download.file(url[i,], paste0(here::here(), "/Bases/DENUE/denue_00_", tablas[i], "_0521_csv.zip"), mode = "wb")
  }
}

# Se agrupan 16 bases de datos en formato CVS en un solo data.frame 
for(i in tablas){
  assign(paste0("df_",i), read.csv(paste0(here::here(), "/DENUE/CSV/CSV/conjunto_de_datos/denue_inegi_",i,"_.csv"), fileEncoding = "latin1"))
}

# Se agrupan todas las tablas en una sola
lista <- ls(pattern =  "df_")
denue_2021 <- do.call(rbind.data.frame, mget(lista))

denue_2021 <- denue_2021 %>%
               select(codigo_act, nombre_act, cve_ent, entidad, cve_mun, municipio, cve_loc, localidad, ageb, manzana) %>% 
                 mutate(cve_ent = stringr::str_pad(.$cve_ent, 2, "left", pad = "0"), 
                        cve_mun = stringr::str_pad(.$cve_mun, 3, "left", pad = "0"),
                        cve_loc = stringr::str_pad(.$cve_loc, 4, "left", pad = "0"),
                        ageb = stringr::str_pad(.$ageb, 4, "left", pad = "0"),
                        manzana = stringr::str_pad(.$manzana, 3, "left", pad = "0")) %>%
                   mutate(CVE_MUN = paste0(.$cve_ent, .$cve_mun),
                          CVE_LOC = paste0(.$cve_ent, .$cve_mun, .$cve_loc),
                          CVE_AGEB = paste0(.$cve_ent, .$cve_mun, .$cve_loc, .$ageb), 
                          CVE_MZA =  paste0(.$cve_ent, .$cve_mun, .$cve_loc, .$ageb, .$manzana)) %>%
# Se anexa la base de Claves
                    left_join(., SCIAN, 
                               by = c("codigo_act" = "CODIGO")) %>%
                      mutate(CVE_ELE = as.character(.$CVE_ELE))

# Se guarda la base de datos donde se integran 16 bases de datos
save(denue2021, file = paste0(here::here(), "/Bases/DENUE/denue2021.RData"))
```

Se integran las claves geoestadísticas para la elaboración de los indicadores simples

```{r, eval = FALSE}
# Estructura integrada del DENUE
load(paste0(here::here(), "/Bases/denue_integrado.RData"))
codigo <- unique(SCIAN$CODIGO)
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE, cache.lazy=TRUE}
require(gt)
load(file = paste0(here::here(), "/Bases/denue_integrado_20obs.RData"))
head(denue_2021, 10) %>% 
 gt() %>%
  tab_header(title = "Directorio Estadístico Nacional de Unidades Económicas (DENUE)",
             subtitle = "DENUE (2021)") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>% 
        cols_width(starts_with("localidad") ~ px(270),
                   starts_with("nombre_act") ~ px(320),
                   starts_with("ESTRUCTURA_SCIAN2018") ~ px(320),
                   everything() ~ px(120)) %>%
          as_raw_html() 
```
</div>

#### Municipio {-}

```{r, eval = FALSE}
denue_mun <- denue_2021 %>%
              filter(.$codigo_act %in% codigo) %>%
               select(ELEMENTO, CVE_MUN) %>%
                melt(., id = c("CVE_MUN"))  %>%
                 mutate(value = as.character(.$value)) %>%
                  acast(., CVE_MUN ~ value, drop = FALSE) %>% 
                   as.data.frame() %>% 
                    tibble::rownames_to_column(., "CVE_MUN") %>%
                     mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%
                      relocate(CVE_ENT, .before = "CVE_MUN") %>%
                       group_by(CVE_ENT) %>%
                        mutate_at(vars(c(-CVE_ENT, -CVE_MUN)), funs(./sum(.)*100))%>%
                         replace(., is.na(.), 0)

save(denue_mun, file = paste0(here::here(), "/Bases/Municipio/Indicadores_DENUE.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
load(file = paste0(here::here(), "/Bases/Municipio/Indicadores_DENUE.RData"))
require(gt)
head(denue_mun, 10) %>% 
 gt() %>%
  tab_header(title = "Directorio Estadístico Nacional de Unidades Económicas (DENUE)",
             subtitle = "Nivel municipal (2021)") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(2:ncol(denue_mun)), 
                  decimals = 2) %>%
          as_raw_html() 
```
</div>

#### Localidad {-}

```{r, eval = FALSE}
denue_loc <- denue_2021 %>%
              filter(.$codigo_act %in% codigo) %>%
               select(ELEMENTO, CVE_LOC) %>%
                melt(., id = c("CVE_LOC"))  %>%
                 mutate(value = as.character(.$value)) %>%
                  acast(., CVE_LOC ~ value, drop = FALSE) %>% 
                   as.data.frame() %>% 
                    tibble::rownames_to_column(., "CVE_LOC") %>%
                     mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%
                      relocate(CVE_MUN, .before = "CVE_LOC") %>%
                       group_by(CVE_MUN) %>%
                        mutate_at(vars(c(-CVE_MUN, -CVE_LOC)), funs(./sum(.)*100))%>%
                         replace(., is.na(.), 0)

save(denue_loc, file = paste0(here::here(), "/Bases/Localidad/Indicadores_DENUE.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
load(file = paste0(here::here(), "/Bases/Localidad/Indicadores_DENUE.RData"))
require(gt)
head(denue_loc, 10) %>% 
 gt() %>%
  tab_header(title = "Directorio Estadístico Nacional de Unidades Económicas (DENUE)",
             subtitle = "Nivel localidad (2021)") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(2:ncol(denue_mun)), 
                  decimals = 2) %>%
          as_raw_html() 
```
</div>


#### AGEB {-}

```{r, eval = FALSE}
denue_ageb <- denue_2021 %>%
               filter(.$codigo_act %in% codigo) %>%
                select(ELEMENTO, CVE_AGEB) %>%
                 melt(., id = c("CVE_AGEB"))  %>%
                  mutate(value = as.character(.$value)) %>%
                   acast(., CVE_AGEB ~ value, drop = FALSE) %>% 
                    as.data.frame() %>% 
                     tibble::rownames_to_column(., "CVE_AGEB")  %>%
                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%
                       relocate(CVE_LOC, .before = "CVE_AGEB") %>%
                        group_by(CVE_LOC) %>%
                         mutate_at(vars(c(-CVE_LOC, -CVE_AGEB)), funs(./sum(.)*100))%>%
                          replace(., is.na(.), 0)

save(denue_ageb, file = paste0(here::here(), "/Bases/AGEB/Indicadores_DENUE.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
load(file = paste0(here::here(), "/Bases/AGEB/Indicadores_DENUE.RData"))
require(gt)
head(denue_ageb, 10) %>% 
 gt() %>%
  tab_header(title = "Directorio Estadístico Nacional de Unidades Económicas (DENUE)",
             subtitle = "Nivel AGEB (2021)") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(2:ncol(denue_mun)), 
                  decimals = 2) %>%
          as_raw_html() 
```
</div>

### SEP {-}


```{r, eval = FALSE, comment="03_SEP_Estructura.Rmd"}
load(paste0(here::here(), "/Bases/SEP_Estructura.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(paste0(here::here(), "/Bases/SEP_Estructura.RData"))
head(SEP, 10) %>% 
 gt() %>%
  tab_header(title = "SIGED (Sistema de Información y Gestión Educativa)",
             subtitle = "Secretaría de Educación Pública (SEP)") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>%
       cols_width(starts_with("NOM_CT") ~ px(470),
                  starts_with("SERV_EDUC") ~ px(280),
                  everything() ~ px(120)) %>%
        as_raw_html() 
```
</div>

#### Municipio {-}

**Se utiliza la base de datos a nivel municipio, ya que esta presenta todo el universo de escuelas en el país.**  

```{r, eval = FALSE}
sep_mun <- SEP %>%
            select(CVE_MUN, `Nivel educativo`) %>%
             reshape2::melt(., id = c("CVE_MUN")) %>%
              acast(., CVE_MUN ~ value, drop = FALSE) %>%
               as.data.frame() %>% 
                tibble::rownames_to_column(., "CVE_MUN") %>%
                 mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%
                  relocate(CVE_ENT, .before = "CVE_MUN") %>%
                   group_by(CVE_ENT) %>%
                    mutate_at(vars(c(-CVE_MUN, -CVE_ENT)), funs(./sum(.)*100))%>%
                     replace(., is.na(.), 0)
save(sep_mun, file = paste0(here::here(), "/Bases/Municipio/Indicadores_Escuelas_SEP.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
load(paste0(here::here(), "/Bases/Municipio/Indicadores_Escuelas_SEP.RData"))
require(gt)
head(sep_mun, 10) %>% 
 gt() %>%
  tab_header(title = "SIGED (Sistema de Información y Gestión Educativa)",
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())%>%
       fmt_number(columns = c(2:ncol(sep_mun)), 
                  decimals = 2) %>%
          as_raw_html() 
```
</div>


#### Localidad {-}

```{r, eval = FALSE}
sep_loc <- SEP %>%
                select(CVE_LOC, `Nivel educativo`) %>%
                 reshape2::melt(., id = c("CVE_LOC")) %>%
                   acast(., CVE_LOC ~ value, drop = FALSE) %>%
                    as.data.frame() %>% 
                     tibble::rownames_to_column(., "CVE_LOC") %>%
                      mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%
                        relocate(CVE_MUN, .before = "CVE_LOC") %>%
                         group_by(CVE_MUN) %>%
                          mutate_at(vars(c(-CVE_LOC, -CVE_MUN)), funs(./sum(.)*100))%>%
                           replace(., is.na(.), 0)

save(sep_loc, file = paste0(here::here(), "/Bases/Localidad/Indicadores_Escuelas_SEP.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
load(file = paste0(here::here(), "/Bases/Localidad/Indicadores_Escuelas_SEP.RData"))
require(gt)
head(sep_loc, 10) %>% 
 gt() %>%
  tab_header(title = "SIGED (Sistema de Información y Gestión Educativa)",
             subtitle = "Nivel localidad") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())%>%
       fmt_number(columns = c(2:ncol(sep_mun)), 
                  decimals = 2) %>%
          as_raw_html() 
```
</div>

#### AGEB {-}

```{r, eval = FALSE, comment="03_SEP_Estructura.Rmd"}
load("Bases/SEP_Estructura_AGEB.RData")
```

```{r, eval = FALSE}
sep_ageb <- sep_ageb %>%
                select(CVE_AGEB, `Nivel educativo`) %>%
                 reshape2::melt(., id = c("CVE_AGEB")) %>%
                   acast(., CVE_AGEB ~ value, drop = TRUE) %>% # drop = FALSE
                    as.data.frame() %>% 
                     tibble::rownames_to_column(., "CVE_AGEB") %>%
                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%
                        relocate(CVE_LOC, .before = "CVE_AGEB") %>%
                         group_by(CVE_LOC) %>%
                          mutate_at(vars(c(-CVE_AGEB, -CVE_LOC)), funs(./sum(.)*100))%>%
                           replace(., is.na(.), 0)

save(sep_ageb, file = paste0(here::here(), "/Bases/AGEB/Indicadores_Escuelas_SEP.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
load(file = paste0(here::here(), "/Bases/AGEB/Indicadores_Escuelas_SEP.RData"))
require(gt)
head(sep_ageb, 10) %>% 
 gt() %>%
  tab_header(title = "SIGED (Sistema de Información y Gestión Educativa)",
             subtitle = "Nivel AGEB") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(2:ncol(sep_mun)), 
                  decimals = 2) %>%
          as_raw_html() 
```
</div>

### CLUES {-}

```{r, eval = FALSE, comment="04_CLUES_Estructura.Rmd"}
load("Bases/CLUES_Estructura.RData")
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/CLUES_Estructura.RData"))
head(CLUES, 10) %>% 
 gt() %>%
  tab_header(title = "Clave Única de Establecimientos de Salud (CLUES)",
             subtitle = "Dirección General de Información en Salud (DGIS).") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels()) %>%
       cols_width(starts_with("Nombre del municipio") ~ px(200),
                  starts_with("Nombre de la loalidad") ~ px(250),
                  starts_with("NOMBRE.DE.LA.INSTITUCION") ~ px(400),
                  starts_with("Nivel de atención") ~ px(200),
                  everything() ~ px(100)) %>%
        as_raw_html() 
```
</div>

#### Municipio {-}

```{r, eval = FALSE}
clues_mun <- CLUES %>%
                select(`Nivel de atención`, CVE_MUN) %>%
                 melt(., id = c("CVE_MUN"))  %>%
                  mutate(value = as.character(.$value)) %>%
                   acast(., CVE_MUN ~ value, drop = FALSE) %>% 
                    as.data.frame() %>% 
                     tibble::rownames_to_column(., "CVE_MUN") %>%
                      mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%
                       relocate(CVE_ENT, .before = "CVE_MUN") %>%
                        group_by(CVE_ENT) %>%
                         mutate_at(vars(c(-CVE_ENT, -CVE_MUN)),funs(./sum(.)*100))%>%
                          replace(., is.na(.), 0)

save(clues_mun, file = paste0(here::here(), "/Bases/Municipio/Indicadores_CLUES.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/Municipio/Indicadores_CLUES.RData"))
head(clues_mun, 10) %>% 
 gt() %>%
  tab_header(title = "Clave Única de Establecimientos de Salud (CLUES)",
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c(2:ncol(clues_mun)), 
                  decimals = 2) %>%
        as_raw_html() 
```
</div>


#### Localidad {-}

```{r, eval = FALSE}
clues_loc <- CLUES %>%
                select(`Nivel de atención`, CVE_LOC) %>%
                 melt(., id = c("CVE_LOC"))  %>%
                  mutate(value = as.character(.$value)) %>%
                   acast(., CVE_LOC ~ value, drop = FALSE) %>% 
                    as.data.frame() %>% 
                     tibble::rownames_to_column(., "CVE_LOC") %>%
                      mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%
                       relocate(CVE_MUN, .before = "CVE_LOC") %>%
                        group_by(CVE_MUN) %>%
                         mutate_at(vars(c(-CVE_MUN, -CVE_LOC)),funs(./sum(.)*100))%>%
                          replace(., is.na(.), 0)

save(clues_loc, file = paste0(here::here(), "/Bases/Localidad/Indicadores_CLUES.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(paste0(here::here(), "/Bases/Localidad/Indicadores_CLUES.RData"))
head(clues_loc, 10) %>% 
 gt() %>%
  tab_header(title = "Clave Única de Establecimientos de Salud (CLUES)",
             subtitle = "Nivel localidad") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c(2:ncol(clues_mun)), 
                  decimals = 2) %>%
        as_raw_html() 
```
</div>

#### AGEB {-}

```{r, eval = FALSE, comment="04_CLUES_Estructura.Rmd"}
load(paste0(here::here(), "/Bases/CLUES_Estructura_AGEB.RData"))
```

```{r, eval = FALSE}
clues_ageb <- CLUES_AGEB %>%
                select(`Nivel de atención`, CVE_AGEB) %>%
                 melt(., id = c("CVE_AGEB"))  %>%
                  mutate(value = as.character(.$value)) %>%
                   acast(., CVE_AGEB ~ value, drop = FALSE) %>% 
                    as.data.frame() %>% 
                     tibble::rownames_to_column(., "CVE_AGEB") %>%
                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%
                       relocate(CVE_LOC, .before = "CVE_AGEB") %>%
                        group_by(CVE_LOC) %>%
                         mutate_at(vars(c(-CVE_LOC, -CVE_AGEB)),funs(./sum(.)*100))%>%
                          replace(., is.na(.), 0)

save(clues_ageb, file = paste0(here::here(), "/Bases/AGEB/Indicadores_CLUES.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/AGEB/Indicadores_CLUES.RData"))
head(clues_ageb, 10) %>% 
 gt() %>%
  tab_header(title = "Clave Única de Establecimientos de Salud (CLUES)",
             subtitle = "Nivel AGEB") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c(2:ncol(clues_mun)), 
                  decimals = 2) %>%
        as_raw_html() 
```
</div>

## Índice de accesibilidad (IA) {-}

#### Municipio {-}

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/Municipio/IA_municipio.Rdata"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/Municipio/IA_municipio.Rdata"))
head(accesibilidad_mun, 10) %>% 
 gt() %>%
  tab_header(title = "Índice de accesibilidad",
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c("IAL"), 
                  decimals = 2) %>%
        fmt_integer(columns = c("POBTOT"),
                    sep_mark = " ") %>%
         as_raw_html() 
```
</div>

<a href="/images/Municipio/IAL_Mun_Mapa.png" data-lightbox="image-1" data-title="IAL_Mun_Mapa">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Municipio/IAL_Mun_Mapa.png"))
```
</a>

#### Localidad {-}

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/Localidad/IA_localidad.Rdata"))
```


<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/Localidad/IA_localidad.Rdata"))
head(accesibilidad_loc, 10) %>% 
 gt() %>%
  tab_header(title = "Índice de accesibilidad",
             subtitle = "Nivel localidad") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c("IAL"), 
                  decimals = 2) %>%
        cols_width(starts_with("NOM_LOC") ~ px(200),
                   starts_with("GACC") ~ px(180),
                   starts_with("TAMLOC") ~ px(150),
                   everything() ~ px(100)) %>%
         as_raw_html() 
```
</div>

<a href="/images/Localidad/IAL_Loc_Mapa.png" data-lightbox="image-1" data-title="IAL_Loc_Mapa">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Localidad/IAL_Loc_Mapa.png"))
```
</a>

## Entorno Urbano {-}

Dada la importancia de los proyectos sobre el entorno urbano, destacada por informes como el que presentó ONU-Hábitat sobre el Estado de las ciudades en América Latina y el Caribe 2012 o el de CEPAL-CELADE en el cual se afirma que debe adoptarse como acuerdo de trabajo que los temas de entorno, equipamiento y medio ambiente se incorporen a los censos para definir la calidad y adecuación de la vivienda, en particular la urbana.


Algortinmo de integración del Entorno Urbano

```{r, eval = FALSE}
tablas <- c(paste0("0", seq(1, 9, 1)), seq(10, 32, 1))

for(i in tablas){
 assign(paste0("TI_", i), read_sav(paste0(here::here(), "/TI_MANZANA/TI_MANZANA_EU_",i,".SAV")))
}

# Se agrupan todas las tablas en una sola
lista <- ls(pattern = "TI_")
MANZANA_EU_2020 <- do.call(rbind.data.frame, mget(lista))

MANZANA_EU_2020 <- MANZANA_EU_2020 %>% 
                    select("ENT", "CVE_MUN","CVE_LOC","CVE_AGEB","PERSONAS", "VIVPARHAB", "TOTLADO", "TOTVIAL", "TOTRASGO", contains("_N")) %>%
                     mutate(PAVIM_ADOQ_N = .$PAVIM_N + .$ADOQ_N) %>%
                      select("ENT", "CVE_MUN","CVE_LOC","CVE_AGEB","PERSONAS", "VIVPARHAB", "TOTLADO", "TOTVIAL", "TOTRASGO", PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N,
                             C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N,
                             C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)

# Se guarda la base de datos donde se integran 16 bases de datos
save(MANZANA_EU_2020, file = paste0(here::here(), "/Bases/MANZANA_EU_2020.RData"))
```

No enfocamos en los indicadores númericos. 

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/MANZANA_EU_2020.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(paste0(here::here(), "/Bases/MANZANA_EU_2020.RData"))
head(MANZANA_EU_2020, 10) %>% 
 gt() %>%
  tab_header(title = "Características del Entorno Urbano",
             subtitle = "INEGI") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       cols_width(everything() ~ px(100)) %>%
        as_raw_html() 
```
</div>

###  `Caso particular` {-}

**Caso particular**
**Municpio de Ocampo / Localidad Melchor Ocampo**  
Debido a la falta de información de este municipio, se toma como referencia a los municipios vecinos. 

- `08009` Bocoyna  
- `08031` Guerrero  
- `08041` Maguarichi  
- `08047` Boris  
- `08063` Temósachic
- `08066` Uruachi

<center>
![](images/Estructura/Ocampo_Mun.png){#id .class width=450 height=300px}
</center>

Fuente: [Espacio y datos de México (INEGI)](https://www.inegi.org.mx/app/mapa/espacioydatos/default.aspx)

```{r, eval = FALSE}
EU_mun <- MANZANA_EU_2020 %>%
           select("ENT", "CVE_MUN", "PERSONAS", "VIVPARHAB", "TOTLADO", "TOTVIAL", "TOTRASGO", contains("_N")) %>%
             filter(CVE_MUN %in% c("08009", "08031", "08041", "08047", "08063", "08066")) %>%
              select(-CVE_MUN) %>%
                group_by(ENT) %>% 
                  summarise(across(where(is.numeric), sum)) %>%
                   ungroup() %>%
                    mutate_at(vars(c(-ENT, -PERSONAS,-VIVPARHAB,-TOTLADO)),funs((./TOTLADO)*100))

save(EU_mun, file = paste0(here::here(), "/Bases/Municipio/EU_mun.RData"))
```

<div style="height:150px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/Municipio/EU_mun.RData"))
head(EU_mun, 10) %>% 
 gt() %>%
  tab_header(title = "Características del Entorno Urbano",
             subtitle = "Caso particular") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(5:25), 
                    decimals = 2) %>%
        fmt_integer(columns = c(2:4),
                    sep_mark = " ") %>%
         cols_width(everything() ~ px(100)) %>%
          as_raw_html() 
```
</div>

#### Nivel Localidad {-}

```{r, eval = FALSE}
EU_loc <- MANZANA_EU_2020 %>%
             select("CVE_LOC", "PERSONAS", "VIVPARHAB", "TOTLADO", "TOTVIAL", "TOTRASGO", contains("_N")) %>%
              group_by(CVE_LOC) %>% 
               summarise(across(where(is.numeric), sum)) %>%
                ungroup() %>%
                 mutate_at(vars(c(-CVE_LOC, -PERSONAS,-VIVPARHAB,-TOTLADO)), funs((./TOTLADO)*100))

save(EU_loc, file = paste0(here::here(), "/Bases/Localidad/EU_loc.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/Localidad/EU_loc.RData"))
head(EU_loc, 10) %>% 
 gt() %>%
  tab_header(title = "Características del Entorno Urbano",
             subtitle = "Nivel localidad") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(5:25), 
                    decimals = 2) %>%
        fmt_integer(columns = c(2:4),
                    sep_mark = " ") %>%
         cols_width(everything() ~ px(100)) %>%
          as_raw_html() 
```
</div>


#### Nivel AGEB {-}

```{r, eval = FALSE}
EU_ageb <- MANZANA_EU_2020 %>%
            select("CVE_AGEB", "PERSONAS", "VIVPARHAB", "TOTLADO", "TOTVIAL", "TOTRASGO", contains("_N")) %>%
              group_by(CVE_AGEB) %>% 
               summarise(across(where(is.numeric), sum)) %>%
                ungroup() %>%
                 mutate_at(vars(c(-CVE_AGEB, -PERSONAS,-VIVPARHAB,-TOTLADO)), funs((./TOTLADO)*100))

save(EU_ageb, file = paste0(here::here(), "/Bases/AGEB/EU_ageb.RData"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/AGEB/EU_ageb.RData"))
head(EU_ageb, 10) %>% 
 gt() %>%
  tab_header(title = "Características del Entorno Urbano",
             subtitle = "Nivel AGEB") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       fmt_number(columns = c(5:25), 
                    decimals = 2) %>%
        fmt_integer(columns = c(2:4),
                    sep_mark = " ") %>%
         cols_width(everything() ~ px(100)) %>%
          as_raw_html() 
```
</div>

```{r,echo = FALSE}
rm(list = ls())
```

<!--chapter:end:02_Bases.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Municipio {.unlisted .unnumbered}


```{r, echo = FALSE, out.width = '100%', fig.asp = 1, fig.align='center'}
#options(device="RStudioGD")
readRDS(file = paste0(here::here(), "/Output/Municipio/Network_Mun.rds"))
```

Se toma como referencia el marco geoestadístico nacional 2020 a Nivel Municipal.

```{r, codefolding_show = "hide" }
load(paste0(here::here(), "/Bases/Municipio/MGN.Rdata"))
```

<div style="height:320px;overflow:auto;">
```{r, echo = FALSE}
require(gt)
head(MGN_mun, 10) %>% 
 gt() %>%
  tab_header(title = "Marco Geoestadístico Nacional (MGN)",
             subtitle = "Nivel municipal") %>%
   fmt_number(columns = c("IM_2020", "IMN_2020"), 
                decimals = 2) %>%
    fmt_integer(columns = c("POBTOT", "OVPH", "VIVTOT", "P_AFRO", "P_IND", "P_DISC"),
                sep_mark = " ") %>%
      tab_options(heading.title.font.size = 14, 
                  heading.subtitle.font.size = 12,
                  table.font.names = "Century Gothic",
                  table.font.size = 10,
                  table.align = 'center',
                  data_row.padding = px(1)) %>%
       tab_style(style = list(cell_text(align = "left",
                                         weight = 'bold')),
                  locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                   locations = list(cells_title(groups = c("subtitle")))) %>%
         cols_label(CVE_MUN = md("**Clave del municipio**"),
                    ENT = md("**Clave de la entidad**"),
                    NOM_ENT = md("**Entidad**"), 
                    MUN = md("**Clave del municipio**"),
                    NOM_MUN = md("**Municipio**"), 
                    POBTOT = md("**Población Total**"), 
                    OVPH = md("**Ocupantes en viviendas particulares habitadas**"), 
                    VIVTOT = md("**Viviendas totales**"), 
                    P_AFRO = md("**Población afrodescendiente o afromexicana**"),
                    G_AFRO = md("**Grado de población afrodescendiente o afromexicana**"),
                    P_IND = md("**Población indígena**"),
                    G_IND = md("**Grado de población indígena**"),
                    P_DISC = md("**Población con algún grado de discapacidad**"),
                    IM_2020 = md("**Índice de marginación a nivel municipal**"),
                    GM_2020 = md("**Grado de marginación a nivel municipal**"),
                    IMN_2020 = md("**Índice de marginación a nivel municipal normalizado**")) %>%
         cols_width(starts_with("POB") ~ px(100),
                    starts_with("NOM") ~ px(120),
                    starts_with("Grado") ~ px(180),
                    starts_with("G_AFRO") ~ px(220),
                    starts_with("G_IND") ~ px(200),
                    everything() ~ px(100)) %>%
          as_raw_html() 
```
</div>


## Marginación {.unnumbered}

Se carga la nueva base del índice de marginación 2020.   

```{r}
load(paste0(here::here(), "/Bases/Municipio/IMM.Rdata"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
head(IMM, 10) %>% 
 gt() %>%
  tab_header(title = "Indicadores sociodemigráficos",
             subtitle = "Nivel municipal") %>%
   fmt_number(columns = c(2:10), 
                decimals = 2) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = "Century Gothic",
                table.font.size = 10,
                table.align = 'center',
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left", 
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
      tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%
       cols_label(CVE_MUN = md("**Clave del municipio**"),
                  ANALF = md("**Porcentaje de población de 15 años o más analfabeta**"),
                  SBASC = md("**Porcentaje de población de 15 años o más sin educación básica**"),
                  OVSDE = md("**Porcentaje de ocupantes en viviendas sin drenaje ni excusado**"),
                  OVSEE = md("**Porcentaje de ocupantes en viviendas sin energía eléctrica**"),
                  OVSAE = md("**Porcentaje de ocupantes en viviendas sin agua entubada**"),
                  VHAC = md("**Porcentaje de viviendas con algún nivel de hacinamiento**"),
                  OVPT= md("**Porcentaje de ocupantes en viviendas con piso de tierra**"),
                  PL.5000 = md("**Porcentaje de población en localidades menores a 5 000 habitantes**"),
                  PO2SM = md("**Porcentaje de población ocupada con ingresos de hasta 2 salarios mínimos**")) %>% 
        cols_width(starts_with("CVE_MUN") ~ px(80),
                   everything() ~ px(150)) %>%
          as_raw_html() 
```
</div>


Para el cálculo de los componentes principales depende de las unidades de medida empleadas en las variables. Por lo que es importante, antes de aplicar `PCA`, estandarizar los indicadores simples para que tenganmedia **0** y desviación estándar **1**, ya que, de lo contrario, las variables con mayor varianza dominarían al resto, aunque en el caso en que las variables estén medidas en las mismas unidades, podemos optar por no estandarizarlas. La estandarización se lleva a cabo restando a cada observación la media y dividiendo entre la desviación estándar de la variable a la que pertenece:    

$$Z_{i}=\frac{x_{i}-\bar{x}}{\sigma_{i}}$$

Se utiliza la función $PCA$ del parquete **FactoMiner**, donde se especifica que se estandaricen las vairables con el parámetro *scale.unit=TRUE*

**Análisis de componentes principales**

Se utilizan todas las variables

```{r}
PCA_IMM <- PCA(IMM[, c(2:ncol(IMM))],
                scale.unit = TRUE, 
                 ncp = ncol(IMM[, c(2:ncol(IMM))]),
                  graph = FALSE) 
```

```{r, echo = FALSE, eval=FALSE}
saveRDS(PCA_IMM,file = paste0(here::here(), "/Output/Municipio/PCA_IMM.RDS")) 
```


**Es importante seleccionar que gráficos se pueden incluir en el análisis**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada

Por otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos a través de descomposición de valores singulares (`SVD`) de la matriz de datos.

$$\mathbf X = \mathbf U \mathbf S \mathbf V^\top$$ - Segundo, desde el punto de vista `PCA` que requiere el cálculo de los valores propios y los vectores propios, haciendo la descomposición propia de $\mathbf X \mathbf X^{T}$.

$$\mathbf X \mathbf V = \mathbf U \mathbf S \mathbf V^\top \mathbf V = \mathbf U \mathbf S$$

Donde - $\mathbf V$ son los eigenvectors - $\mathbf U$ es la matriz unitaria - $\mathbf S$ es la traza de los eigenvalues

Las columnas de $\mathbf {US}$ son los pesos de las componentes principales

**Se generan los índices de cada uno de los subsistemas** **Se utilizan a los componentes principales que expliquen el máximo de la información**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.


```{r}
# Componentes seleccionadas
ncp <- 3

# Índices de las componentes principales seleccionados
PC_IMM <-  IMM %>%
            select(CVE_MUN) %>%
             mutate(PC = as.numeric(scale(as.matrix(IMM[, c(2:10)])) %*% 
                                     as.matrix(PCA_IMM[["var"]][["coord"]][, 1:ncp]) %*% 
                                      as.matrix(PCA_IMM[["eig"]][,2][1:ncp]/100))) %>%
              as.data.frame()

save(PC_IMM, file = paste0(here::here(), "/Output/Municipio/PC_IMM.Rdata"))
```


**Resumen**

```{r, echo = FALSE}
PCA_IMM <- readRDS(file = paste0(here::here(), "/Output/Municipio/PCA_IMM.RDS")) 
tabla <- facto_summarize(PCA_IMM, "var", axes = 1:3) %>%
          select(-name) %>%
           as.data.frame() %>%
            mutate(Indicadores = c('Porcentaje de población de 15 años o más analfabeta', 
                                   'Porcentaje de población de 15 años o más sin educación básica',
                                   'Porcentaje de ocupantes en viviendas sin drenaje ni excusado',
                                   'Porcentaje de ocupantes en viviendas sin energía eléctrica', 
                                   'Porcentaje de ocupantes en viviendas sin agua entubada', 
                                   'Porcentaje de ocupantes en viviendas con piso de tierra',
                                   'Porcentaje de población en localidades con menos de 5 000 habitantes',
                                   'Porcentaje de viviendas con algún nivel de hacinamiento',
                                   'Porcentaje de población ocupada con ingresos de hasta 2 salarios mínimos')) %>%
             relocate(Indicadores, .before = "Dim.1") 
```

```{r, echo = FALSE}
tabla %>% 
 gt() %>%
  tab_header(title = "Tabla: Resumen de los indicadores de marginación utilizando PCA", 
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       tab_footnote(footnote = "Fuente: Elaboración propia", 
                    placement = "left") %>%
        fmt_number(columns = c(2:7), 
                    decimals = 3)  %>%
         as_raw_html() 
```

## Equipamiento {.unnumbered}

**Claves económicas**

### DENUE {.unnumbered}

Se anexan los indicadores simples, de acuerdo a la clasificación económica del DENUE (**01**)

```{r, eval = TRUE}
load(paste0(here::here(), "/Bases/Municipio/Indicadores_DENUE.RData"))
```

Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUE

```{r}
load(paste0(here::here(), "/Bases/Claves_subsistema_SCIAN2018.RData"))
```

**Subramos**

Se toman como referencia 13 subsitemas económicos y 64 elementos económicos que lo integran

```{r, collapse=TRUE}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
tablas <- names(Subsitemas)
tablas
```

```{r, eval = FALSE}
for(i in 1:11){
assign(paste0("tabla_", tablas[i]), denue_mun %>%
                                     ungroup() %>%
                                      select(CVE_MUN, Subsitemas[[paste(tablas[i])]]) %>%
                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%
                                        mutate(suma = as.numeric(.$suma)) %>%
                                          filter(.$suma != 0) %>%
                                           select(-suma))
}
```

**Dimensiones de cálculo**

```{r, echo = FALSE}
#tabla <- matrix(data = NA, nrow = 11, ncol = 3)
#for(i in 1:11){
 # tabla[i, 1] <- paste(tablas[i])
 #  tabla[i, 2] <- nrow(get(paste0("tabla_", tablas[i])))
 #  tabla[i, 3] <- length(Subsitemas[[paste(tablas[i])]])
#}
#colnames(tabla) <- c("Indicadores", "Observaciones", "Dimensiones")

load(paste0(here::here(), "/Output/Municipio/tabla_observaciones_DENUE.RData"))
tabla %>% 
  as.data.frame() %>%
   mutate(Observaciones = as.numeric(.$Observaciones)) %>%
    gt() %>%
     tab_header(title = "Tabla: Dimensiones de cálculo", 
                subtitle = "Nivel municipal") %>%
      tab_options(heading.title.font.size = 14, 
                  heading.subtitle.font.size = 12,
                  table.font.names = "Century Gothic",
                  table.font.size = 10,
                  table.align = 'center',
                  data_row.padding = px(1)) %>%
       tab_style(style = list(cell_text(align = "left", 
                                        weight = 'bold')),
                 locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                  locations = list(cells_title(groups = c("subtitle")))) %>%
         tab_style(style = "vertical-align:center; font-weight: bold",
                   locations = cells_column_labels()) %>%
          tab_footnote(footnote = "Fuente: Elaboración propia", 
                       placement = "left") %>%
           fmt_integer(columns = c("Observaciones"),
                       sep_mark = " ") %>%
            as_raw_html()
```

**Análisis de componentes principales**

```{r, eval = FALSE}
ncp <- c(1, 1, 1, 1, 3, 1 ,1, 1, 1, 1, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))

PCA_Subsistemas <- NULL
for(i in 1:11){
  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0("tabla_", tablas[i]))[, c(2:ncol(get(paste0("tabla_", tablas[i]))))], 
                                              scale.unit = TRUE, 
                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),
                                                graph = FALSE) 
}
```

```{r, echo = FALSE, eval = FALSE}
saveRDS(PCA_Subsistemas, file = paste0(here::here(), "/Output/Municipio/PC_DENUE.RDS"))
```


```{r, eval = FALSE}
# Índices de las componentes principales seleccionados
PC_DENUE <- NULL
for(i in 1:11){
  PC_DENUE[[i]] <- get(paste0("tabla_", tablas[i]))[1] %>%
                    select(CVE_MUN) %>%
                     mutate(PC = scale(as.matrix(get(paste0("tabla_", tablas[i]))[,-1])) %*% 
                      as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["var"]][["coord"]][,1:ncp[i]]) %*% 
                       as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["eig"]][,2][1:ncp[i]]/100)) %>% 
                        as.data.frame()
}
save(PC_DENUE, file = paste0(here::here(), "/Output/Municipio/PC_DENUE.Rdata"))
```

```{r, echo = FALSE}
PCA_Subsistemas <- readRDS(file = paste0(here::here(), "/Output/Municipio/PC_DENUE.RDS"))

ncp <- c(1, 1, 1, 1, 3, 1 ,1, 1, 1, 1, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))

tabla <- NULL 
for(i in 1:11){
 tabla[[paste0(tablas[i])]] <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i])
}
# Asistencia Social 
i <- 2
tabla <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i]) %>%
          rename("Indicadores" = "name") %>%
           as.data.frame() 

tabla %>% 
 gt() %>%
  tab_header(title = "Tabla: Resumen de los indicadores de asistencia social",  
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       tab_footnote(footnote = "Fuente: Elaboración propia", 
                    placement = "left") %>%
        fmt_number(columns = c(2:4), 
                   decimals = 3)  %>%
         as_raw_html() 
```

#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- NULL
for(i in 1:11){
pcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0("tabla_", tablas[i]))[-1], ncomp = ncp[i], scale = TRUE, center = TRUE, validation = "LOO")
}

## Se guardan los resultados 
saveRDS(pcr_model, paste0(here::here(), "/Output/Municipio/pcr_model_denue.rds"))

## Caso máximo
pcr_pred_max <- NULL
for(i in 1:11){
  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)
  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), ".comp"))
}

## Caso mínimos 
pcr_pred_min <- NULL
for(i in 1:11){
  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)
}

pcr_extremos <- matrix(NA, nrow = 11, ncol = 3)
for(i in 1:11){
  pcr_extremos[i, 1] <- paste(tablas[i])
  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]
  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]
}
colnames(pcr_extremos) <- c("Indicadores", "Máximo", "Mínimo")

save(pcr_extremos, file = paste0(here::here(), "/Output/Municipio/PCR_DENUE.RData"))
write.table(pcr_extremos, file = paste0(here::here(), "/Output/Municipio/PCR_DENUE.txt", sep = ","))
```


```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/Municipio/PCR_DENUE.RData"))

pcr_extremos %>% 
 as.data.frame() %>%
  mutate_at(vars(2:3), as.numeric) %>%
   gt() %>%
    tab_header(title = "Tabla: Valores extremos utilizando Principal Component Regression (PCR)",  
               subtitle = "Indicadores del DENUE a nivel municipal") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 table.align = 'center',
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left", 
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        tab_style(style = "vertical-align:center; font-weight: bold",
                  locations = cells_column_labels()) %>%
         tab_footnote(footnote = "Fuente: Elaboración propia", 
                      placement = "left") %>%
          fmt_number(columns = c("Máximo", "Mínimo"), 
                     decimals = 3)  %>%
           as_raw_html() 
```


### Educación {.unnumbered}

```{r, eval = FALSE}
load("Bases/Municipio/Indicadores_Escuelas_SEP.RData")

sep_mun <- sep_mun %>%
             mutate(suma = rowSums(.[3:11])) %>%
               mutate(suma = as.numeric(.$suma)) %>%
                filter(.$suma != 0) %>%
                  select(-suma)
```

**Análisis de componentes principales**

```{r, eval = FALSE}
PCA_SEP <- PCA(sep_mun[, c(3:11)],
                scale.unit = TRUE, 
                 ncp = ncol(sep_mun[, c(3:11)]),
                  graph = FALSE)
```

```{r, echo = FALSE, eval = FALSE}
saveRDS(PCA_SEP, file = paste0(here::here(), "/Output/Municipio/PCA_SEP.RDS"))
```


```{r, eval = FALSE}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 2
# Índices de las componentes principales seleccionados
PC_SEP <-  sep_mun %>%
            select(CVE_MUN) %>%
             mutate(PC = as.numeric(scale(as.matrix(sep_mun[, c(3:11)])) %*% 
              as.matrix(PCA_SEP[["var"]][["coord"]][,1:ncp]) %*% 
               as.matrix(PCA_SEP[["eig"]][,2][1:ncp]/100))) %>%
                as.data.frame()
save(PC_SEP,  file = paste0(here::here(), "/Output/Municipio/PC_SEP.Rdata"))
```

```{r, echo = FALSE}
PCA_SEP <- readRDS(file = paste0(here::here(), "/Output/Municipio/PCA_SEP.RDS"))

tabla <- facto_summarize(PCA_SEP, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 

# Educación 
tabla <- facto_summarize(PCA_SEP, "var", axes = 1:2) %>%
          rename("Indicadores" = "name") %>%
           as.data.frame() 

tabla %>% 
 gt() %>%
  tab_header(title = "Tabla: Resumen de los indicadores de educación utilizando PCA", 
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       tab_footnote(footnote = "Fuente: Elaboración propia", 
                    placement = "left") %>%
        fmt_number(columns = c(2:6), 
                   decimals = 3)  %>%
         as_raw_html() 
```

#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_SEP$PC~., data = sep_mun[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")
#saveRDS(pcr_model, paste0(here::here(), "/Output/Municipio/pcr_model_sep.rds"))

## Caso máximo
test <- t(rep(100, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_mun[,c(3:11)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_mun[,c(3:11)])
pcr_pred_min <- predict(pcr_model, test)


pcr_extremos <- data.frame("Indicadores" = c("Educación"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp])

save(pcr_extremos, file = paste0(here::here(), "/Output/Municipio/PCR_SEP.RData"))
write.table(pcr_extremos, file = paste0(here::here(), "/Output/Municipio/PCR_SEP.txt", sep = ","))
```


```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/Municipio/PCR_SEP.RData"))

pcr_extremos %>% 
 as.data.frame() %>%
  mutate_at(vars(2:3), as.numeric) %>%
   gt() %>%
    tab_header(title = "Tabla: Valores extremos utilizando Principal Component Regression (PCR)",  
               subtitle = "Indicadores de la SEP a nivel municipal") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 table.align = 'center',
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left", 
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        tab_style(style = "vertical-align:center; font-weight: bold",
                  locations = cells_column_labels()) %>%
         tab_footnote(footnote = "Fuente: Elaboración propia", 
                      placement = "left") %>%
          fmt_number(columns = c("Máximo", "Mínimo"), 
                     decimals = 3)  %>%
           as_raw_html() 
```

#### Validación Cruzada {.unnumbered}

- Mean Squared Error (MSE) 
 
$$MSE = \frac{1}{n}\sum_{i = 1}^{n}\left(Y_{i}- \hat{Y}_{i}\right)^{2}$$
- Root Mean Squared Prediction Error `RMSE`

$$RMSE = \sqrt{\frac{1}{n}\sum_{i = 1}^{n}\left(Y_{i}- \hat{Y}_{i}\right)^{2}}$$
```{r, eval = FALSE}
ncomp <- 9
# Validación Cruzada 
pcr_model <- pcr(PC_SEP$PC~., data = sep_mun[, c(3:11)], 
                 ncomp = ncomp,  
                 scale = TRUE, 
                 center = TRUE, 
                 validation = "LOO")
saveRDS(pcr_model, paste0(here::here(), "/Output/Municipio/pcr_model_sep_cv.rds"))

summary(pcr_model)

#calculate MSE
mean((pcr_model[["residuals"]])^2)
```

```{r, echo = FALSE}
pcr_model <- readRDS(paste0(here::here(), "/Output/Municipio/pcr_model_sep_cv.rds"))

# Extraer los datos de validación
validation_data <- MSEP(pcr_model)$val[,,]

# Se convierten los datos a un data frame para ggplot2
validation_df <- validation_data %>%
                  t() %>%
                   as.data.frame() %>%
                    tibble::rownames_to_column(var = "rowid") %>%
                     mutate(ncomp = seq(0, nrow(.) - 1))

# Crear el gráfico con ggplot2
validation_df %>% 
 filter(ncomp %nin% 0) %>% 
  ggplot(aes(x = ncomp)) +
   geom_line(aes(y = CV, color = "line1")) + 
    geom_line(aes(y = adjCV, color = "line2"), linetype = "dashed") + 
     geom_point(aes(y = CV, color = "line1")) + 
      geom_point(aes(y = adjCV, color = "line2")) + 
       theme_minimal() +
        scale_color_manual(labels = c("CV", "CVAdj"), 
                            values = c("line1" = "#18b581", "line2" = "#e01280")) +
         scale_x_continuous(breaks = seq(0, 10, by = 1)) +
          labs(title = "Validation Plot", 
               x = "Number of Components", 
               y = "Mean Squared Error of Prediction (MSEP)",
               color = "CrossValidation") 
```

La función `postResample` puede utilizarse para estimar el error cuadrático medio (`RMSE`), el `R2` simple y el error absoluto medio (`MAE`) para resultados numéricos.     

- Mean Absolute Error (MSE) 
 
$$MSE = \frac{1}{n}\sum_{i = 1}^{n}\left|Y_{i}- \hat{Y}_{i}\right|^{2}$$

```{r, eval = FALSE}
set.seed(123)
require(caret)
require(pls)
#require(pca)
trControl <- trainControl(method = "cv", number = 10, selectionFunction = "oneSE")

# Base de datos original con los la variable respuesta 
df <- data.frame(PC = PC_SEP$PC) %>% 
       cbind(., sep_mun %>%
                 select(3:ncol(sep_mun)))

# Split the data into training and test set
inTraining <- createDataPartition(df$PC, p = .75, list = FALSE)
training <- df[ inTraining,]
testing  <- df[-inTraining,]

# Build the model on training set
caret.pcr <- train(PC~., 
                   data = training,
                   method = "pcr",
                   preProcess = c("center", "scale"),
                   trControl = trControl, 
                   tuneGrid = data.frame(ncomp = 1:ncomp))

saveRDS(caret.pcr, paste0(here::here(), "/Output/Municipio/caret_pcr_sep_cv.rds"))
```

```{r, eval = FALSE}
pcr_pred <- predict(caret.pcr, testing)
# Calculate MSE 
mean((pcr_pred - testing$PC)^2)
# Calculate RMSE 
#sqrt(mean((pcr_pred - testing$PC)^2))
RMSE = caret::RMSE(pcr_pred, testing$PC)
# Summary of accurracy 
postResample(pred = pcr_pred, obs = testing$PC)
```

```{r, echo = FALSE}
caret.pcr<- readRDS(paste0(here::here(), "/Output/Municipio/caret_pcr_sep_cv.rds"))
# Extraer los datos de validación
validation_data <- caret.pcr[["results"]]

tabla <- validation_data %>% 
          reshape2::melt(id.vars = "ncomp") %>% 
           as.data.frame()

p <- tabla %>%
      ggplot(aes(x = ncomp)) +
       geom_line(aes(y = value, color = variable), linetype = "dashed") + 
        geom_point(aes(y = value, color = variable)) +
         theme_minimal() +
          scale_color_viridis_d(option = "A", begin = 0, end = 0.8) +
           scale_y_continuous(labels = scales::unit_format(scale = 1e-1, unit = NULL)) + 
           scale_x_continuous(breaks = seq(0, 10, by = 1)) + 
            facet_wrap(. ~ variable, scales = "free") + 
             labs(title = "Validation Plot", 
                  x = "Number of Components", 
                  y = "",
                  color = "CrossValidation") 
p
```


### Salud {.unnumbered}

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/Municipio/Indicadores_CLUES.RData"))

clues_mun <- clues_mun %>%
              mutate(suma = rowSums(.[3:6])) %>%
               mutate(suma = as.numeric(.$suma)) %>%
                filter(.$suma != 0) %>%
                  select(-suma)
```

```{r, eval = FALSE}
PCA_CLUES <- PCA(clues_mun[, c(3:6)],
                  scale.unit = TRUE, 
                   ncp = ncol(clues_mun[, c(3:6)]),
                    graph = FALSE) 
```

```{r, echo = FALSE, eval = FALSE}
saveRDS(PCA_CLUES, file = paste0(here::here(), "/Output/Municipio/PCA_CLUES.RDS"))
```

```{r, eval = FALSE}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 1

# Índices de las componentes principales seleccionados
PC_CLUES <-  clues_mun %>%
              select(CVE_MUN) %>%
               mutate(PC = as.numeric(scale(as.matrix(clues_mun[, c(3:6)])) %*% 
                                       as.matrix(PCA_CLUES[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_CLUES[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_CLUES,  file = paste0(here::here(), "/Output/Municipio/PC_CLUES.Rdata"))
```


```{r, echo = FALSE}
PCA_CLUES <- readRDS(file = paste0(here::here(), "/Output/Municipio/PCA_CLUES.RDS"))

tabla <- facto_summarize(PCA_CLUES, "var", axes = 1) %>%
          rename("Indicadores" = "name") %>%
           as.data.frame()

tabla %>% 
 gt() %>%
  tab_header(title = "Tabla: Resumen de los indicadores de salud utilizando PCA", 
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:center; font-weight: bold",
                locations = cells_column_labels()) %>%
       tab_footnote(footnote = "Fuente: Elaboración propia", 
                    placement = "left") %>%
        fmt_number(columns = c(2:5), 
                   decimals = 3)  %>%
         as_raw_html() 
```


#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_CLUES$PC~., data = clues_mun[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/Municipio/pcr_model_clues.rds"))

## Caso máximo
test <- t(rep(100, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_mun[,c(3:6)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_mun[,c(3:6)])
pcr_pred_min <- predict(pcr_model, test)

pcr_extremos <- data.frame("Indicadores" = c("Educación"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

save(pcr_extremos, file = paste0(here::here(), "/Output/Municipio/PCR_CLUES.RData"))
write.table(pcr_extremos, file = paste0(here::here(), "/Output/Municipio/PCR_CLUES.txt"), sep = ",")
```

```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/Municipio/PCR_CLUES.RData"))

pcr_extremos %>% 
 as.data.frame() %>%
  mutate_at(vars(2:3), as.numeric) %>%
   gt() %>%
    tab_header(title = "Tabla: Valores extremos utilizando Principal Component Regression (PCR)",  
               subtitle = "Indicadores del CLUES a nivel municipal") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 table.align = 'center',
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left", 
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        tab_style(style = "vertical-align:center; font-weight: bold",
                  locations = cells_column_labels()) %>%
         tab_footnote(footnote = "Fuente: Elaboración propia", 
                      placement = "left") %>%
          fmt_number(columns = c("Máximo", "Mínimo"), 
                     decimals = 3)  %>%
           as_raw_html() 
```

## Accesibilidad {.unnumbered}

**Índice de accesibilidad**

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/Municipio/IA_municipio.Rdata"))
```

```{r, echo = FALSE}
require(gt)
load(file = paste0(here::here(), "/Bases/Municipio/IA_municipio.Rdata"))
head(accesibilidad_mun, 10) %>% 
 gt() %>%
  tab_header(title = "Índice de accesibilidad",
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c("IAL"), 
                  decimals = 2) %>%
        fmt_integer(columns = c("POBTOT"),
                    sep_mark = " ") %>%
         as_raw_html() 
```

```{r, echo = FALSE}
require(psych)
tabla <- describe(accesibilidad_mun$IAL) %>%
          tibble::rownames_to_column()
tabla %>% 
 gt() %>%
  tab_header(title = "Análisis descriptivo de la variables de accesibilidad",
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c(4:14), 
                  decimals = 1) %>%
        fmt_integer(columns = c("n"),
                    sep_mark = " ") %>%
         as_raw_html() 
```

Distribución del índice de accesibilidad a nivel municipal    

<a href="/images/Municipio/IAL a nivel municipal_ggridges.png" data-lightbox="image-1" data-title="IAL_municipio">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Municipio/IAL a nivel municipal_ggridges.png"))
```
</a>

```{r,echo = FALSE}
rm(list = ls())
```

## Calidad del entorno {.unnumbered}

**MGN**

```{r}
load(paste0(here::here(), "/Bases/Municipio/MGN.RData"))
```

```{r}
load(paste0(here::here(), "/Output/Municipio/PC_IMM.Rdata"))

IMM <- PC_IMM %>%
        rename("IMM" = "PC")
```

**DENUE**

Se excluyen los subsistemas de `Educación` y `Salud`.

```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
Indicadores <- names(Subsitemas)

load(paste0(here::here(), "/Output/Municipio/PC_DENUE.Rdata"))

tabla <- NULL
for(i in 1:11){
  if(i %in% 1){
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_mun %>% select(CVE_MUN), tabla_DENUE, by = c("CVE_MUN"))
  } else {
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_mun %>% select(CVE_MUN), tabla_DENUE, by = c("CVE_MUN")) %>%
                 select(.,2)
  }
}

DENUE <- do.call(cbind.data.frame, tabla)
colnames(DENUE) <- c("CVE_MUN", Indicadores)
rm(tabla_DENUE)
```

**SEP**

```{r}
load(paste0(here::here(), "/Output/Municipio/PC_SEP.RData"))
SEP <- PC_SEP %>%
         rename("Educacion" = "PC")
```

**CLUES**

```{r}
load(paste0(here::here(), "/Output/Municipio/PC_CLUES.RData"))
CLUES <- PC_CLUES %>%
          rename("Salud" = "PC")
```

\*\* Índice de accesibilidad a nivel municipio\*\*

```{r}
load(paste0(here::here(), "/Bases/Municipio/IA_municipio.Rdata"))
IAL <- accesibilidad_mun %>%
         select(CVE_MUN, IAL) 
```

**Integración del ICE**

**Imputación de valores faltantes**

A los valores faltantes de equipamiento se les imputa el valor mínimos que puede obtener cada subsistema, calculados por el método de componentes principales. Siendo estos los valores extremos (falta de equipamiento), este valor se formuló utilizando Principal Component Regresion (PCR) y de esta manera poder obtener el valor predictivo del valor mínimo.

```{r}
PCR_pred <- read.table(paste0(here::here(), "/Output/Municipio/PCR_SEP.txt"), header = TRUE, sep = ",") %>% 
             rbind(.,read.table(paste0(here::here(), "/Output/Municipio/PCR_CLUES.txt"), header = TRUE, sep = ",")) %>%
              rbind(., read.table(paste0(here::here(), "/Output/Municipio/PCR_DENUE.txt"), header = TRUE, sep = ","))
```

```{r}
ICE_2020 <- MGN_mun %>%
             select(CVE_MUN) %>%
              left_join(., IMM, by = c("CVE_MUN")) %>%
               left_join(., SEP, by = c("CVE_MUN")) %>%
                left_join(., CLUES, by = c("CVE_MUN")) %>%
                 left_join(., DENUE, by = c("CVE_MUN")) %>% 
                  left_join(., IAL, by = c("CVE_MUN")) %>% 
                   mutate_at(vars(2:16), as.numeric) 

ICE_2020 <- ICE_2020 %>%
                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),
                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),
                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),
                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),
                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),
                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),
                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),
                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),
                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),
                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),
                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),
                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),
                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)
                       )
```

### Método de Distancias $DP_2$ {.unnumbered}

José Bernardo Pena Trapero: `Problemas de la medición del bienestar y conceptos afines (1977)`

Primeramente se define como es la entrada de los indicadores simples.\ Este tipo de método - Índice de marginación (Negativo) (Marginación baja (-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento + CLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de accesibilidad (Negativo) (Accesibilidad alta (cercanos a cero) / Accesibilidad baja (Alejados del cero))

```{r}
require(p2distance)
ICE_2020_data <- ICE_2020 %>%
                   mutate(IMM = -1*.$IMM,
                          IAL = -1*.$IAL)
```

**Base de referencia**

**Nota.-** Se toma como base de referencia el valor del mínimo de cada
indicador simple.

```{r}
require(p2distance)
minRV <- p2distance::makeReferenceVector(X = ICE_2020_data[-1], 
                                          reference_vector_function = 'min')
```

```{r, echo = FALSE}
tabla <- t(minRV) %>%
           as.data.frame() %>%
            tibble::rownames_to_column(var = "Indicadores")
colnames(tabla) <- c("Indicadores", "Base de referencia")


tabla %>% 
 gt() %>%
  tab_header(title = "Tabla: Base de referencia a nivel municipal",
             subtitle = "Nivel municipal") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = "Century Gothic",
               table.font.size = 10,
               table.align = 'center',
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left", 
                                     weight = 'bold')),
              locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
      tab_style(style = "vertical-align:middle; font-weight: bold",
                locations = cells_column_labels())  %>%
       fmt_number(columns = c("Base de referencia"), 
                  decimals = 3) %>%
         as_raw_html() 
```

**Método de Distancia** $DP_{2}$

```{r}
##Calculo del Método de Distancias DP2
ind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), 
                       reference_vector = minRV, 
                        iterations = 50)
```

El modelo converge a la cuarta iteración

```{r}
ind_ice$iteration
```

```{r}
ICE_2020 <- cbind(ICE_2020, ind_ice[["p2distance"]])

# Se cambian los nombres de las columnas 
names(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "ICE")
```

```{r, echo = FALSE, fig.height=3, fig.width=7}
p <- ICE_2020 %>%
      ggplot() + 
       geom_boxplot(aes(x = ICE, y = "", color = ICE), fill = "transparent", size = 0.7) + 
        geom_jitter(aes(x = ICE, y = "", color = ICE, fill = ICE), size = 2, alpha = 0.3) + 
         theme_ipsum_rc(grid = "X") +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"),
                                 legend.key.size = unit(0.5, 'cm'),
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
              scale_color_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                scale_fill_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                 scale_y_discrete(expand = c(0.5,0)) +
                 labs(title = paste("Boxplot del índice de calidad del entorno"),
                       subtitle = "Nivel municipal", 
                       color = "",  
                        fill = "", 
                         x = "", 
                          y = "") 
p
```

```{r}
# Se identifican los outliers en el índice de calidad del entorno
#boxplot.stats(DP2_2010$IM_2010)$out
outliers <- boxplot.stats(ICE_2020$ICE)

## Se crea un índice ficticio quitando los outliers   
ICE_2020 <- ICE_2020 %>%
              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],
                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],
                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) 
```

### Método de estratificación {.unnumbered}

`strata.cumrootf`: cumulative root frequency method by Dalenius and
Hodges (1959)\

**Nclass óptimo del método de Dalenius & Hodge**

`alloc` lista que especifica el esquema de asignación. La lista debe
contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de
asignación general (ver paquete de `stratification`). El valor
predeterminado es la asignación de **Neyman** (q1 = q3 = 0.5 y q2 = 0)

```{r, eval = FALSE, cache = TRUE, cache.lazy = TRUE, collapse=TRUE}
start.time <- Sys.time()
# Se define el coeficiente de variación a usar
coef.var <- 0.05

DH_Municipio <- list()
i <- 1
  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)
  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)
  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)
 for (n in seq(5, 1000, 1)){
   DH_Municipio[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
   cum <- DH_Municipio[[n]]
   sd[i,] <-  c(n, cum$stderr, cum$CV)
   meanh[i,] <- c(n, cum$meanh)
   varh[i,] <-  c(n, cum$varh)
   i <- i + 1
}

colnames(sd) <- c("n", "sderr", "CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
colnames(varh) <- c("nclass", paste0(rep("Strata", 5), 1:5))

end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken

#Se guardan los resultados de las iteraciones
save(sd, file = paste0(here::here(), "/Output/Municipio/sd.Rdata"))
```

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/Municipio/sd.Rdata"))
```

```{r, collapse=TRUE}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV))
```

<div class = "row">
<div class = "col-md-3">
```{r, echo = FALSE}
min.strata %>%
    kable(col.names = c("n", "Error \n estándar", "CV"),
                   digits = 4, 
                    align = 'c',
                    format.args = list(font_size = '9px', family = "Century Gothic"),
                     format = "html", 
                      booktabs = FALSE) %>% 
            kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
             kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 9) %>%
              column_spec(1, bold = T, border_right = T) %>%
               row_spec(0, bold = T) %>%
                  row_spec(1, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
              footnote(., general = "Elaboración propia", 
                        general_title = "Fuente:", 
                         footnote_as_chunk = T) 
```
</div>

<div class = "col-md-8">
```{r, echo = FALSE, out.width = "80%", out.height= "80%"}
rows <- c(nrow(sd))

p <- sd %>%
      as.data.frame() %>%
       arrange(desc(.$CV)) %>%
        mutate(count = seq(1,nrow(sd))) %>%
         ggplot() + 
          geom_point(aes(x = count, y = CV)) + 
           geom_line(aes(x = count, y = CV)) +
            geom_text(data = min.strata, aes(label = paste("CV = ", round(CV, 4) ," | nclass  =", n), x = rows -300, y = CV),  
                       vjust = -1,
                         size = 3,
                          color = "red",
                           family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
                labs(title = "Método de Dalenius & Hodges óptimo",
                      subtitle = paste("Índice de calidad del entorno | Método iterativo | CV Óptimo"),
                       y = "CV", 
                        x = "iteraciones") 
p
```
</div>
</div>

```{r}
strata.ice <- strata.cumrootf(ICE_2020$ICE_out,
                               CV = 0.05,  ## Revisar que tenga el mismo CV
                                Ls = 5,
                                 alloc = c(0.5,0,0.5), 
                                  nclass = min.strata$n)

## Se agrega a la base de datos
ICE_2020 <- ICE_2020 %>%
              select(-ICE_out) %>%   # Se quita el índice ficticio
                mutate(G.ICE = strata.ice[["stratumID"]])


# Se cambian los nombres de las columnas 
colnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "G.ICE")

# Se cambian los levels de D&H
levels(ICE_2020$G.ICE) = c("Completa", "Grave", "Moderada", "Ligera", "No hay")
```

### Índice normalizado {.unnumbered}

**Indice normalizado**

**Escenarios del mínimo y máximo valor en el índice DP2**

**Se guarda la bases de Datos del ICE por municipio**

```{r}
# Desviación estandar de los indicadores
desvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%
                       as.data.frame() %>%
                        rename("desvest" ="V1") %>%
                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%
                            mutate(desvest.inversa = 1/(.$sd_muestral))

# Escenario mínimo
vector_minimo <- as.matrix(minRV)

tabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])]
minimo <- data.frame(Escenario = "Mínimo", tabla, DP2 = sum(tabla))

# Escenario mínimo  
vector_maximo <- p2distance::makeReferenceVector(ICE_2020_data[-1], reference_vector_function = 'max')

tabla <- abs(vector_maximo - minRV)* desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])] 

maximo <- data.frame(Escenario = "Máximo", tabla, DP2 = sum(tabla))

# Indice normalizado
min_DP2 <- minimo$DP2[1]
max_DP2 <- maximo$DP2[1]

ICE_2020 <- ICE_2020 %>%
              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2))

# Se guarda el índice de calidad del entorno normalizado
save(ICE_2020, file = paste0(here::here(), "/Bases/Municipio/ICE_2020.RData"))
```


<a href="/images/Municipio/ICE_Mun_Mapa.png" data-lightbox="image-1" data-title="ICE_Mun_Mapa">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%', fig.cap="Elaboración propia"}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Municipio/ICE_Mun_Mapa.png"))
```
</a>



<!--chapter:end:03_Municipio.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Localidad {.unlisted .unnumbered}


```{r, echo = FALSE, out.width = '100%', fig.asp = 1, fig.align='center'}
readRDS(file = paste0(here::here(), "/Output/Localidad/Network_Loc.rds"))
```

Se toma como referencia el marco geoestadístico nacional 2020 a nivel localidad. El cúal cuenta con 189 432 localidades para el año 2020. 

```{r, echo=TRUE}
load(paste0(here::here(), "/Bases/Localidad/MGN.Rdata"))
```



<div style="height:320px;overflow:auto;">
```{r, echo = FALSE}
require(gt)
head(MGN_loc, 10) %>% 
dplyr::relocate(Tamaño.de.localidad, .before = "TAMLOC") %>%
 gt() %>%
  tab_header(title = "Marco Geoestadístico Nacional (MGN)",
             subtitle = "Nivel localidad") %>%
   fmt_integer(columns = c("Pob.Total", "Viviendas.Totales"),
               sep_mark = " ") %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = "Century Gothic",
                table.font.size = 10,
                table.align = 'center',
                data_row.padding = px(1)) %>%
       tab_style(style = list(cell_text(align = "left",
                                         weight = 'bold')),
                  locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                   locations = list(cells_title(groups = c("subtitle")))) %>%
         cols_label(CVE_LOC = md("**Clave de la localidad**"),
                    ENTIDAD = md("**Clave de la entidad**"),
                    NOM_ENT = md("**Entidad**"), 
                    MUN = md("**Clave del municipio**"),
                    NOM_MUN = md("**Municipio**"), 
                    LOC = md("**Clave de localidad**"),
                    NOM_LOC = md("**Localidad**"), 
                    LONGITUD = md("**Longuitud**"),
                    LATITUD = md("**Latitud**"),
                    ALTITUD = md("**Altitud**"), 
                    Pob.Total = md("**Población Total**"), 
                    Viviendas.Totales = md("**Viviendas totales**"), 
                    TAMLOC = md("**Tamaño de la localidad**"),
                    AMBITO = md("**Ámbito**"),
                    Tamaño.de.localidad = md("**Tamaño de la localidad**"),
                    Indicadora = md("**Indicadora**")) %>%
         cols_width(starts_with("CVE_LOC") ~ px(100),
                    starts_with("ENTIDAD") ~ px(80),
                    starts_with("MUN") ~ px(80),
                    starts_with("NOM_LOC") ~ px(280),
                    starts_with("LONGITUD") ~ px(100),
                    starts_with("LATITUD") ~ px(100),
                    starts_with("ALTITUD") ~ px(100),
                    starts_with("Tamaño.de.localidad") ~ px(150),
                    starts_with("Indicadora") ~ px(150),
                    everything() ~ px(80)) %>%
          as_raw_html() 
```
</div>


## Marginación {.unnumbered}

Se vuelve a reestructurar la base de datos a nivel localidad 2020, donde los principales cambios que se hacen: 
-	Se agregan esas localidades con el margen de error mayores al 90%.
-	En la base publicada del índice de marginación a nivel localidad. Se excluyeron a aquellas localidades que no presentaban a algún cálculo en uno de los indicadores. Pero en este caso se incluyen todas las localidades, para que puedan coincidir con los datos oficiales del INEGI para el Censo de Población y Vivienda 2020. 

Al final del cálculo se van a desplegar las localidades menores a 2 viviendas particulares, en las cuales están agrupadas a nivel municipal. Finalmente puedan ser usadas en el  ICE.  

**Bases de datos**

Se carga la nueva base del índice de marginación 2020.   

```{r}
load(paste0(here::here(), "/Bases/Localidad/IML.Rdata"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
head(IML, 10) %>% 
 gt() %>%
  tab_header(title = "Indicadores sociodemigráficos",
             subtitle = "Nivel localidad") %>%
   fmt_number(columns = c(2:9), 
                decimals = 2) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = "Century Gothic",
                table.font.size = 10,
                table.align = 'center',
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left", 
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
      tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%
       cols_label(CVE_LOC = md("**Clave de la localidad**"),
                  ANALF = md("**Porcentaje de población de 15 años o más analfabeta**"),
                  SBASC = md("**Porcentaje de población de 15 años o más sin educación básica**"),
                  OVSDE = md("**Porcentaje de ocupantes en viviendas sin drenaje ni excusado**"),
                  OVSEE = md("**Porcentaje de ocupantes en viviendas sin energía eléctrica**"),
                  OVSAE = md("**Porcentaje de ocupantes en viviendas sin energía eléctrica**"),
                  OVHAC = md("**Porcentaje de ocupantes en viviendas con algún nivel de hacinamiento**"),
                  OVPT= md("**Porcentaje de ocupantes en viviendas con piso de tierra**")) %>% 
        cols_width(starts_with("CVE_LOC") ~ px(80),
                   everything() ~ px(150)) %>%
          as_raw_html() 
```
</div>



Para el cálculo de los componentes principales depende de las unidades de medida empleadas en las variables. Por lo que es importante, antes de aplicar `PCA`, estandarizar los indicadores simples para que tengan media **0** y desviación estándar **1**, ya que, de lo contrario, las variables con mayor varianza dominarían al resto, aunque en el caso en que las variables estén medidas en las mismas unidades, podemos optar por no estandarizarlas. La estandarización se lleva a cabo restando a cada observación la media y dividiendo entre la desviación estándar de la variable a la que pertenece:

$$Z_{i}=\frac{x_{i}-\bar{x}}{\sigma_{i}}$$

Se utiliza la función $PCA$ del parquete **FactoMiner**, donde se
especifica que se estandaricen las vairables con el parámetro
*scale.unit=TRUE*

**Análisis de componentes principales**

**Se utilizan todas las variables** 

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/Localidad/IML.Rdata"))

PCA_IML <- PCA(IML[, c(2:ncol(IML))],
                 scale.unit = TRUE, 
                  ncp = ncol(IML[, c(2:ncol(IML))]),
                   graph = FALSE) 
```

**Es importante seleccionar que gráficos se pueden incluir en el análisis**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada

Por otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos a través de descomposición de valores singulares (`SVD`) de la matriz de datos.

$$\mathbf X = \mathbf U \mathbf S \mathbf V^\top$$ - Segundo, desde el punto de vista `PCA` que requiere el cálculo de los valores propios y
los vectores propios, haciendo la descomposición propia de $\mathbf X \mathbf X^{T}$.

$$\mathbf X \mathbf V = \mathbf U \mathbf S \mathbf V^\top \mathbf V = \mathbf U \mathbf S$$

Donde - $\mathbf V$ son los eigenvectors - $\mathbf U$ es la matriz unitaria - $\mathbf S$ es la traza de los eigenvalues

Las columnas de $\mathbf {US}$ son los pesos de las componentes principales

**Se generan los índices de cada uno de los subsistemas** **Se utilizan
a los componentes principales que expliquen el máximo de la información**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.


```{r, eval = FALSE}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 4

# Índices de las componentes principales seleccionados
PC_IML <-  IML %>%
             select(CVE_LOC) %>%
               mutate(PC = as.numeric(scale(as.matrix(IML[,c(2:ncol(IML))])) %*% 
                                       as.matrix(PCA_IML[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_IML[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()
save(PC_IML, file = paste0(here::here(), "/Output/Localidad/PC_IML.Rdata"))
```


**Resumen**

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/Localidad/facto_summarize_IML.Rdata"))
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de marginación utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:8, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```



## Equipamiento {.unnumbered}

**Claves económicas**

### DENUE {.unnumbered}

Se anexan los indicadores simples, de acuerdo a la clasificación económica del DENUE (**01**)

```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/Localidad/Indicadores_DENUE.RData"))
```


Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUE

```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/Claves_subsistema_SCIAN2018.RData"))
```

**Subramos**

Se toman como referencia 13 subsitemas económicos y 64 elementos
económicos que lo integran

Integrarlo en una base de datos para no saturar la página web


```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
tablas <- names(Subsitemas)

for(i in 1:11){
assign(paste0("tabla_",tablas[i]), denue_loc %>%
                                     ungroup() %>%
                                      select(CVE_LOC, Subsitemas[[paste(tablas[i])]]) %>%
                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%
                                        mutate(suma = as.numeric(.$suma)) %>%
                                          filter(.$suma != 0) %>%
                                           select(-suma))
}
```


**Dimensiones de cálculo**

```{r, echo = FALSE}
tabla <- matrix(data = NA, nrow = 11, ncol = 3)
for(i in 1:11){
  tabla[i, 1] <- paste(tablas[i])
  tabla[i, 2] <- nrow(get(paste0("tabla_", tablas[i])))
  tabla[i, 3] <- length(Subsitemas[[paste(tablas[i])]])
}
colnames(tabla) <- c("Indicadores", "Observaciones", "Dimensiones")

tabla %>% 
  as.data.frame() %>%
    mutate(Observaciones = as.numeric(.$Observaciones)) %>%
  kable(caption = "Tabla: Dimensiones de cálculo", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic", big.mark = " "),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:11, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T)
```


**Análisis de componentes principales**

```{r, class.source = "fold-show"}
ncp <- c(2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))

PCA_Subsistemas <- NULL
for(i in 1:11){
  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0("tabla_", tablas[i]))[, c(2:ncol(get(paste0("tabla_", tablas[i]))))], 
                                              scale.unit = TRUE, 
                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),
                                                graph = FALSE) 
}
```

```{r}
# Índices de las componentes principales seleccionados
PC_DENUE <- NULL
for(i in 1:11){
  PC_DENUE[[i]] <- get(paste0("tabla_", tablas[i]))[1] %>%
                     select(CVE_LOC) %>%
                       mutate(PC = scale(as.matrix(get(paste0("tabla_", tablas[i]))[,-1])) %*% 
                                    as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["var"]][["coord"]][,1:ncp[i]]) %*% 
                                      as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["eig"]][,2][1:ncp[i]]/100)) %>% 
                         as.data.frame()
}
save(PC_DENUE, file = paste0(here::here(), "/Output/Localidad/PC_DENUE.Rdata"))
```

```{r, echo = FALSE}
tabla <- NULL 
for(i in 1:11){
 tabla[[paste0(tablas[i])]] <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i])
}

# Asistencia Social 
i <- 2
tabla <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i]) %>%
          select(-name) %>%
           as.data.frame() 

tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de asistencia social", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:5, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T)
```

#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- NULL
for(i in 1:11){
pcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0("tabla_",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = "LOO")
}

## Se guardan los resultados 
saveRDS(pcr_model, paste0(here::here(), "/Output/Localidad/pcr_model_denue.rds"))

## Caso máximo
pcr_pred_max <- NULL
for(i in 1:11){
  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)
  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), ".comp"))
}

## Caso mínimos 
pcr_pred_min <- NULL
for(i in 1:11){
  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)
}


pcr_extremos <- matrix(NA, nrow = 11, ncol = 3)
for(i in 1:11){
  pcr_extremos[i, 1] <- paste(tablas[i])
  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]
  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]
}
colnames(pcr_extremos) <- c("Indicadores", "Máximo", "Mínimo")
write.table(pcr_extremos, file = paste0(here::here(), "/Output/Localidad/PCR_DENUE.txt"), sep = ",")
```



### Educación {.unnumbered}

```{r}
load(paste0(here::here(), "/Bases/Localidad/Indicadores_Escuelas_SEP.RData"))

sep_loc <- sep_loc %>%
             mutate(suma = rowSums(.[3:11])) %>%
               mutate(suma = as.numeric(.$suma)) %>%
                filter(.$suma != 0) %>%
                  select(-suma)
```

**Análisis de componentes principales**

```{r, class.source = "fold-show"}
PCA_SEP <- PCA(sep_loc[, c(3:11)],
                scale.unit = TRUE, 
                 ncp = ncol(sep_loc[, c(3:11)]),
                  graph = FALSE)
```


```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 4

# Índices de las componentes principales seleccionados
PC_SEP <-  sep_loc %>%
              select(CVE_LOC) %>%
               mutate(PC = as.numeric(scale(as.matrix(sep_loc[, c(3:11)])) %*% 
                              as.matrix(PCA_SEP[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_SEP[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_SEP,  file = paste0(here::here(), "/Output/Localidad/PC_SEP.Rdata"))
```

\renewcommand{\arraystretch}{2}
```{r, echo = FALSE}
tabla <- facto_summarize(PCA_SEP, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de educación utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:9, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T)
```


#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_SEP$PC~., data = sep_loc[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/Localidad/pcr_model_sep.rds"))

## Caso máximo
test <- t(rep(100, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_loc[,c(3:11)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_loc[,c(3:11)])
pcr_pred_min <- predict(pcr_model, test)


pcr_extremos <- data.frame("Indicadores" = c("Educación"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/Localidad/PCR_SEP.txt"), sep = ",")
```



### Salud {.unnumbered}


```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/Localidad/Indicadores_CLUES.RData"))

clues_loc <- clues_loc %>%
               mutate(suma = rowSums(.[3:6])) %>%
                 mutate(suma = as.numeric(.$suma)) %>%
                  filter(.$suma != 0) %>%
                    select(-suma)
```

```{r, class.source = "fold-show"}
PCA_CLUES <- PCA(clues_loc[, c(3:6)],
                  scale.unit = TRUE, 
                   ncp = ncol(clues_loc[, c(3:6)]),
                    graph = FALSE) 
```



```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 2

# Índices de las componentes principales seleccionados
PC_CLUES <-  clues_loc %>%
              select(CVE_LOC) %>%
               mutate(PC = as.numeric(scale(as.matrix(clues_loc[, c(3:6)])) %*% 
                                       as.matrix(PCA_CLUES[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_CLUES[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_CLUES,  file = paste0(here::here(), "/Output/Localidad/PC_CLUES.Rdata"))
```

```{r, echo = FALSE}
tabla <- facto_summarize(PCA_CLUES, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de salud utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:4, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


#### Caso extremos {-}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_CLUES$PC~., data = clues_loc[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/Localidad/pcr_model_clues.rds"))

## Caso máximo
test <- t(rep(100, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_loc[, c(3:6)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_loc[, c(3:6)])
pcr_pred_min <- predict(pcr_model, test)

pcr_extremos <- data.frame("Indicadores" = c("Salud"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/Localidad/PCR_CLUES.txt"), sep = ",")
```



**Índice de accesibilidad**

```{r}
load(paste0(here::here(), "/Bases/Localidad/IA_localidad.Rdata"))
```



```{r,echo = FALSE}
rm(list = ls())
```

## Calidad del entorno {-}

**MGN**

```{r}
load(paste0(here::here(), "/Bases/Localidad/MGN.RData")) 
```


**Marginación**

```{r}
load(paste0(here::here(), "/Output/Localidad/PC_IML.Rdata"))
```

**Localidades confidenciales**

Para la obtención de las localidades confidenciales se requirio agruparlas a nivel municipal, lo que permitio poder contemplar el 100 por ciento de las localidades reconocidas en el marco geoestadístico. 

Se analizan 81 105 localidades confidenciales

```{r}
load(file = paste0(here::here(), "/Bases/Localidad/Loc_Confidenciales_Claves.Rdata"))

IML <- PC_IML %>%
           filter(substr(.$CVE_LOC,6,9) != '9999') %>%
            rbind(., Loc_Confidenciales %>% select(CVE_LOC, PC)) 

IML <- IML %>%
           rename("IML" = "PC")
```


**DENUE**

Se excluyen los subsistemas de `Educación` y `Salud`. 

```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
Indicadores <- names(Subsitemas)

load(paste0(here::here(), "/Output/Localidad/PC_DENUE.Rdata"))

tabla <- NULL
for(i in 1:11){
  if(i %in% 1){
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_loc %>% select(CVE_LOC), tabla_DENUE, by = c("CVE_LOC"))
  } else {
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_loc %>% select(CVE_LOC), tabla_DENUE, by = c("CVE_LOC")) %>%
                 select(.,2)
  }
}

DENUE <- do.call(cbind.data.frame, tabla)
colnames(DENUE) <- c("CVE_LOC", Indicadores)
rm(tabla_DENUE)
```


***SEP** 

```{r}
load(paste0(here::here(), "/Output/Localidad/PC_SEP.RData"))

SEP <- PC_SEP %>%
         rename("Educacion" = "PC")
```


**CLUES**

```{r}
load(paste0(here::here(), "/Output/Localidad/PC_CLUES.RData"))

CLUES <- PC_CLUES %>%
          rename("Salud" = "PC")
```


**Accesibilidad**

```{r}
load(paste0(here::here(), "/Bases/Localidad/IA_localidad.Rdata")) 

IAL <- accesibilidad_loc %>%
         select(CVE_LOC, IAL) 
```


**Integración del ICE**

**Imputación de valores faltantes**

A los valores faltantes de equipamiento se les imputa el valor mínimos
que puede obtener cada subsistema, calculados por el método de
componentes principales. Siendo estos los valores extremos (falta de
equipamiento), este valor se formuló utilizando Principal Component
Regresion (PCR) y de esta manera poder obtener el valor predictivo del
valor mínimo.

```{r}
PCR_pred <- read.table(paste0(here::here(), "/Output/Localidad/PCR_SEP.txt"), header = TRUE, sep = ",") %>% 
             rbind(.,read.table(paste0(here::here(), "/Output/Localidad/PCR_CLUES.txt"), header = TRUE, sep = ",")) %>%
              rbind(., read.table(paste0(here::here(), "/Output/Localidad/PCR_DENUE.txt"), header = TRUE, sep = ","))

```

```{r}
ICE_2020 <- MGN_loc %>%
             select(CVE_LOC, Indicadora) %>%
              left_join(., IML, by = c("CVE_LOC")) %>%
               left_join(., SEP, by = c("CVE_LOC")) %>%
                left_join(., CLUES, by = c("CVE_LOC")) %>%
                 left_join(., DENUE, by = c("CVE_LOC")) %>% 
                  left_join(., IAL, by = c("CVE_LOC")) %>% 
                   mutate_at(vars(3:17), as.numeric)

ICE_2020 <- ICE_2020 %>%
                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),
                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),
                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),
                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),
                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),
                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),
                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),
                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),
                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),
                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),
                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),
                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),
                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,
                  mutate(IAL = ifelse(is.na(.$IAL) == TRUE, 810, .$IAL)) %>%
                   mutate(Indicadora = case_when(nchar(.$Indicadora)>0 ~ .$Indicadora,
                                                 is.na(.$IAL) ~ "Sin localización en la red",
                                                 is.na(.$IML) ~ "Sin cálculo de marginación"))
table(ICE_2020$Indicadora)
```


Es importante determinar que sucede con las localidades que no tienen cálculo

```{r}
ICE_2020 <- ICE_2020 %>%
             filter(nchar(.$IML)> 0) %>%
              select(., c(1, 3:17)) 
```

José Bernardo Pena Trapero: `Problemas de la medición del bienestar y conceptos afines (1977)` 

Primeramente se define como es la entrada de los indicadores simples. Este tipo de método 
- Índice de marginación (Negativo) (Marginación baja (-Negativa) / Marginación alta (Positiva))
- Índice de equipamiento 
    + CLUES (Postivo)
    + SEP (Postivo)
    + DENUE (Positivo)
- Indice de accesibilidad (Negativo)



```{r}
ICE_2020_data <- ICE_2020 %>%
                   mutate(IML = -1*.$IML,
                          IAL = -1*.$IAL)
```


**Base de referencia**

**Nota.-** Se toma como base de referencia el valor del mínimo de cada
indicador simple.


```{r}
minRV <- makeReferenceVector(X = ICE_2020_data[-1], 
                             reference_vector_function = 'min')
```

```{r, echo = FALSE}
tabla <- t(minRV) %>%
           as.data.frame() %>%
            tibble::rownames_to_column(var = "Indicadores")
tabla %>%              
  kable(caption = "Tabla: Base de referencia a nivel localidad", 
         col.names = c("Indicadores", "Base de referencia"),
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:15, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

**Método de Distancia** $DP_{2}$

```{r}
#require(p2distance)
##Calculo del Método de Distancias DP2
ind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), 
                       reference_vector = minRV, 
                        iterations = 50)
```

El modelo converge a la cuarta iteración

```{r}
ind_ice$iteration
```

```{r}
ICE_2020 <- cbind(ICE_2020, ind_ice[["p2distance"]])

# Se cambian los nombres de las columnas 
names(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "ICE")
```

```{r, echo = FALSE, fig.height=3, fig.width=7}
p <- ICE_2020 %>%
      ggplot() + 
       geom_boxplot(aes(x = ICE, y = "", color = ICE), fill = "transparent", size = 0.7) + 
        geom_jitter(aes(x = ICE, y = "", color = ICE, fill = ICE), size = 0.3, alpha = 0.01) + 
         theme_ipsum_rc(grid = "X") +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                            legend.key.size = unit(0.5, 'cm'),
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
              scale_color_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                scale_fill_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                 scale_y_discrete(expand = c(0.5,0)) +
                 labs(title = paste("Boxplot del índice de calidad del entorno"),
                       subtitle = "Nivel localidad", 
                       color = "",  
                        fill = "", 
                         x = "", 
                          y = "") 
p
```


```{r}
# Se identifican los outliers en el índice de calidad del entorno
#boxplot.stats(DP2_2010$IM_2010)$out
outliers <- boxplot.stats(ICE_2020$ICE)

## Se crea un índice ficticio quitando los outliers   
ICE_2020 <- ICE_2020 %>%
              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],
                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],
                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) 
```


### Método de estratificación {.unnumbered}

`strata.cumrootf`: cumulative root frequency method by Dalenius and
Hodges (1959)\

**Nclass óptimo del método de Dalenius & Hodge**

`alloc` lista que especifica el esquema de asignación. La lista debe
contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de
asignación general (ver paquete de `stratification`). El valor
predeterminado es la asignación de **Neyman** (q1 = q3 = 0.5 y q2 = 0)

```{r,eval = FALSE, cache=TRUE,cache.lazy=TRUE}
start.time <- Sys.time()
# Se define el coeficiente de variación a usar
coef.var <- 0.05

DH_Localidad <- list()
i <- 1
  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)
  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)
  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)
 for (n in seq(5, 1000, 1)){
   DH_Localidad[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)
   cum <- DH_Localidad[[n]]
   sd[i,] <-  c(n, cum$stderr, cum$CV)
   meanh[i,] <- c(n, cum$meanh)
   varh[i,] <-  c(n, cum$varh)
   i <- i + 1
}

colnames(sd) <- c("n","sderr","CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata",5),1:5))
colnames(varh) <- c("nclass",paste0(rep("Strata",5),1:5))

end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken

#Se guardan los resultados de las iteraciones
save(sd, file = paste0(here::here(), "/Output/Localidad/sd.Rdata"))
```

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/Localidad/sd.Rdata"))
```

```{r, collapse=TRUE}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV))
```

<div class = "row">
<div class = "col-md-3">
```{r, echo = FALSE}
min.strata %>%
    kable(col.names = c("n", "Error \n estándar", "CV"),
                   digits = 4, 
                    align = 'c',
                    format.args = list(font_size = '9px', family = "Century Gothic"),
                     format = "html", 
                      booktabs = FALSE) %>% 
            kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
             kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 9) %>%
              column_spec(1, bold = T, border_right = T) %>%
               row_spec(0, bold = T) %>%
                  row_spec(1, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
              footnote(., general = "Elaboración propia", 
                        general_title = "Fuente:", 
                         footnote_as_chunk = T) 
```
</div>

<div class = "col-md-8">
```{r, echo = FALSE, out.width = "80%", out.height= "80%"}
rows <- c(nrow(sd))

p <- sd %>%
      as.data.frame() %>%
       arrange(desc(.$CV)) %>%
        mutate(count = seq(1,nrow(sd))) %>%
         ggplot() + 
          geom_point(aes(x = count, y = CV)) + 
           geom_line(aes(x = count, y = CV)) +
            geom_text(data = min.strata, aes(label = paste("CV = ", round(CV, 4) ," | nclass  =", n), x = rows -300, y = CV),  
                       vjust = -1,
                         size = 3,
                          color = "red",
                           family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
                labs(title = "Método de Dalenius & Hodges óptimo",
                      subtitle = paste("Índice de calidad del entorno | Método iterativo | CV Óptimo"),
                       y = "CV", 
                        x = "iteraciones") 
p
```
</div>
</div>


```{r}
strata.ice <- strata.cumrootf(ICE_2020$ICE_out,
                               CV = 0.05, 
                                Ls = 5,
                                 alloc = c(0.5,0,0.5), 
                                  nclass = min.strata$n)

## Se agrega a la base de datos
ICE_2020 <- ICE_2020 %>%
              select(-ICE_out) %>%   # Se quita el índice ficticio
                mutate(G.ICE = strata.ice[["stratumID"]])


# Se cambian los nombres de las columnas 
colnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "G.ICE")

# Se cambian los levels de D&H
levels(ICE_2020$G.ICE) = c("Completa", "Grave", "Moderada", "Ligera", "No hay")
```


### Índice normalizado {.unnumbered}

**Indice normalizado**

**Escenarios del mínimo y máximo valor en el índice DP2**

**Se guarda la bases de Datos del ICE por municipio**


```{r}
# Desviación estandar de los indicadores
desvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%
                       as.data.frame() %>%
                        rename("desvest" ="V1") %>%
                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%
                            mutate(desvest.inversa = 1/(.$sd_muestral))

# Escenario mínimo
vector_minimo <- as.matrix(minRV)

tabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])]
minimo <- data.frame(Escenario = "Mínimo", tabla, DP2 = sum(tabla))

# Escenario mínimo  
vector_maximo <- p2distance::makeReferenceVector(ICE_2020_data[-1], reference_vector_function = 'max')

tabla <- abs(vector_maximo - minRV)* desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])] 

maximo <- data.frame(Escenario = "Máximo", tabla, DP2 = sum(tabla))

# Indice normalizado
min_DP2 <- minimo$DP2[1]
max_DP2 <- maximo$DP2[1]

ICE_2020 <- ICE_2020 %>%
              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%
               arrange(ICE_Norm)

# Se guarda el índice de calidad del entorno normalizado
save(ICE_2020, file = paste0(here::here(), "/Bases/Localidad/ICE_2020.RData"))
```


<a href="/images/Localidad/ICE_Loc_Mapa.png" data-lightbox="image-1" data-title="ICE_Loc_Mapa">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%', fig.cap="Elaboración propia"}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Localidad/ICE_Loc_Mapa.png"))
```
</a>

<!--chapter:end:04_Localidad.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# AGEB {.unlisted .unnumbered}


```{r, echo = FALSE, out.width = '100%', fig.asp = 1, fig.align='center'}
readRDS(file = paste0(here::here(), "/Output/AGEB/Network_AGEB.rds"))
```



Se toma como referencia el marco geoestadístico nacional 2020 a nivel localidad. El cúal cuenta con 61 439 AGEB's para el año 2020.   

```{r}
load(paste0(here::here(), "/Bases/AGEB/MGN_ageb.Rdata"))
```

<div style="height:320px;overflow:auto;">
```{r, echo = FALSE}
require(gt)
head(MGN_ageb, 10) %>% 
 gt() %>%
  tab_header(title = "Marco Geoestadístico Nacional (MGN)",
             subtitle = "Nivel AGEB Urbana") %>%
   fmt_integer(columns = c("Pob.Total", "Viviendas.Totales"),
               sep_mark = " ") %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = "Century Gothic",
                table.font.size = 10,
                table.align = 'center',
                data_row.padding = px(1)) %>%
       tab_style(style = list(cell_text(align = "left",
                                         weight = 'bold')),
                  locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                   locations = list(cells_title(groups = c("subtitle")))) %>%
         cols_label(CVE_AGEB = md("**Clave de la AGEB**"),
                    ENT = md("**Clave de la entidad**"),
                    NOM_ENT = md("**Entidad**"), 
                    MUN = md("**Clave del municipio**"),
                    NOM_MUN = md("**Municipio**"), 
                    LOC = md("**Clave de localidad**"),
                    NOM_LOC = md("**Localidad**"), 
                    AGEB = md("**AGEB**"), 
                    AMBITO = md("**Ámbito**"),
                    Tamaño.de.localidad = md("**Tamaño de la localidad**"),
                    Pob.Total = md("**Población Total**"), 
                    Viviendas.Totales = md("**Viviendas totales**"), 
                    Indicadora = md("**Indicadora**")) %>%
         cols_width(starts_with("POB") ~ px(100),
                    starts_with("NOM") ~ px(120),
                    starts_with("Tamaño") ~ px(150),
                    everything() ~ px(100)) %>%
          as_raw_html() 
```
</div>

## Marginación {.unnumbered}

Se vuelve a reestructurar la base de datos a nivel AGEB 2020, donde los principales cambios que se hacen: 
-	Se agregan esas AGEB con el margen de error mayores al 90%.
-	En la base publicada del índice de marginación a nivel AGEB, Se excluyeron a aquellas AGEB que no presentaban a algún cálculo en uno de los indicadores. 
- También se quita el filtro de 20 viviendas totales y se contempla a el total de viviendas. 

**Bases de datos**

Se carga la nueva base del índice de marginación 2020.   

```{r}
load(paste0(here::here(), "/Bases/AGEB/IMU.Rdata"))
```

<div style="height:320px; overflow:auto;">
```{r, echo = FALSE}
require(gt)
names(IMU)
head(IMU, 10) %>% 
 gt() %>%
  tab_header(title = "Indicadores sociodemigráficos",
             subtitle = "Nivel AGEB") %>%
   fmt_number(columns = c(2:9), 
                decimals = 2) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = "Century Gothic",
                table.font.size = 10,
                table.align = 'center',
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left", 
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
      tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%
       cols_label(CVE_AGEB = md("**Clave de la AGEB**"),
                  P6A14NAE = md("**Porcentaje de población de 15 años o más analfabeta**"),
                  PSDSS = md("**Porcentaje de población sin derechohabiencia a los servicios de salud**"),
                  PSBASC = md("**Porcentaje de población de 15 años o más sin educación básica**"),
                  OVSDE = md("**Porcentaje de ocupantes en viviendas sin drenaje ni excusado**"),
                  OVSEE = md("**Porcentaje de ocupantes en viviendas sin energía eléctrica**"),
                  OVSAE = md("**Porcentaje de ocupantes en viviendas sin energía eléctrica**"),
                  OVHAC = md("**Porcentaje de ocupantes en viviendas con algún nivel de hacinamiento**"),
                  OVPT = md("**Porcentaje de ocupantes en viviendas con piso de tierra**"),
                  OVSREF = md("**Porcentaje de ocupantes en viviendas particulares habitadas sin refrigerador**"),
                  OVSINT = md("**Porcentaje de ocupantes en viviendas particulares habitadas sin internet**"),
                  OVSCEL = md("**Porcentaje de ocupantes en viviendas particulares habitadas sin celular**")) %>% 
        cols_width(starts_with("CVE_AGEB") ~ px(80),
                   everything() ~ px(150)) %>%
          as_raw_html() 
```
</div>


Para el cálculo de los componentes principales depende de las unidades de medida empleadas en las variables. Por lo que es importante, antes de aplicar `PCA`, estandarizar los indicadores simples para que tengan media **0** y desviación estándar **1**, ya que, de lo contrario, las variables con mayor varianza dominarían al resto, aunque en el caso en que las variables estén medidas en las mismas unidades, podemos optar por no estandarizarlas. La estandarización se lleva a cabo restando a cada observación la media y dividiendo entre la desviación estándar de la variable a la que pertenece:

$$Z_{i}=\frac{x_{i}-\bar{x}}{\sigma_{i}}$$

Se utiliza la función $PCA$ del parquete **FactoMiner**, donde se especifica que se estandaricen las vairables con el parámetro *scale.unit=TRUE*

**Análisis de componentes principales**



**Se utilizan todas las variables** 

```{r, eval = FALSE}
PCA_IMU <- PCA(IMU[, c(2:ncol(IMU))],
               scale.unit = TRUE, 
                ncp = ncol(IMU[, c(2:ncol(IMU))]),
                 graph = FALSE) 
```


**Es importante seleccionar que gráficos se pueden incluir en el análisis**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada

Por otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos a través de descomposición de valores singulares (`SVD`) de la matriz de datos.

$$\mathbf X = \mathbf U \mathbf S \mathbf V^\top$$ - Segundo, desde el punto de vista `PCA` que requiere el cálculo de los valores propios y
los vectores propios, haciendo la descomposición propia de $\mathbf X \mathbf X^{T}$.

$$\mathbf X \mathbf V = \mathbf U \mathbf S \mathbf V^\top \mathbf V = \mathbf U \mathbf S$$

Donde - $\mathbf V$ son los eigenvectors - $\mathbf U$ es la matriz unitaria - $\mathbf S$ es la traza de los eigenvalues

Las columnas de $\mathbf {US}$ son los pesos de las componentes principales

**Se generan los índices de cada uno de los subsistemas** **Se utilizan a los componentes principales que expliquen el máximo de la información**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.


```{r, eval = FALSE}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 6

# Índices de las componentes principales seleccionados
PC_IMU <-  IMU %>%
              select(CVE_AGEB) %>%
               mutate(PC = as.numeric(scale(as.matrix(IMU[,c(2:ncol(IMU))])) %*% 
                                       as.matrix(PCA_IMU[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_IMU[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()
save(PC_IMU, file = paste0(here::here(), "/Output/AGEB/PC_IMU.Rdata"))
```

**Resumen**

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/AGEB/facto_summarize_IMU.Rdata"))
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de marginación utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:11, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


## Equipamiento {.unnumbered}

**Claves económicas**

### DENUE {.unnumbered}

Se anexan los indicadores simples, de acuerdo a la clasificación económica del DENUE (**01**)

```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/AGEB/Indicadores_DENUE.RData"))
```

Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUE

```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/Claves_subsistema_SCIAN2018.RData"))
```



**Subramos**

Se dividen los indicadores simples de acuerdo a los 13 subsitemas económicos

```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
tablas <- names(Subsitemas)

for(i in 1:11){
assign(paste0("tabla_",tablas[i]), denue_ageb %>%
                                     ungroup() %>%
                                      select(CVE_AGEB, Subsitemas[[paste(tablas[i])]]) %>%
                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%
                                        mutate(suma = as.numeric(.$suma)) %>%
                                          filter(.$suma != 0) %>%
                                           select(-suma))
}
```

**Dimensiones de cálculo**

```{r, echo = FALSE}
tabla <- matrix(data = NA, nrow = 11, ncol = 3)
for(i in 1:11){
  tabla[i, 1] <- paste(tablas[i])
  tabla[i, 2] <- nrow(get(paste0("tabla_", tablas[i])))
  tabla[i, 3] <- length(Subsitemas[[paste(tablas[i])]])
}
colnames(tabla) <- c("Indicadores", "Observaciones", "Dimensiones")

tabla %>% 
  as.data.frame() %>%
    mutate(Observaciones = as.numeric(.$Observaciones)) %>%
  kable(caption = "Tabla: Dimensiones de cálculo", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic", big.mark = " "),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:11, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

**Análisis de componentes principales**

```{r, class.source = "fold-show"}
ncp <- c(2, 4, 2, 4, 4, 5, 2, 3, 5, 4, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))

PCA_Subsistemas <- NULL
for(i in 1:11){
  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0("tabla_", tablas[i]))[, c(2:ncol(get(paste0("tabla_", tablas[i]))))], 
                                              scale.unit = TRUE, 
                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),
                                                graph = FALSE) 
}
```

```{r}
# Índices de las componentes principales seleccionados
PC_DENUE <- NULL
for(i in 1:11){
  PC_DENUE[[i]] <- get(paste0("tabla_", tablas[i]))[1] %>%
                     select(CVE_AGEB) %>%
                       mutate(PC = as.numeric(scale(as.matrix(get(paste0("tabla_", tablas[i]))[,-1])) %*% 
                                               as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["var"]][["coord"]][,1:ncp[i]]) %*% 
                                                as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["eig"]][,2][1:ncp[i]]/100))) %>%
                        as.data.frame()
}   

save(PC_DENUE, file = paste0(here::here(), "/Output/AGEB/PC_DENUE.Rdata"))
```


```{r, echo = FALSE}
tabla <- NULL 
for(i in 1:11){
 tabla[[paste0(tablas[i])]] <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i])
}

# Asistencia Social 
i <- 2
tabla <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i]) %>%
          select(-name) %>%
           as.data.frame() 

tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de asistencia social", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:5, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
require(pls)
## Principal Components Regression (PCR)
pcr_model <- NULL
for(i in 1:11){
pcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0("tabla_",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = "LOO")
}

saveRDS(pcr_model, paste0(here::here(), "/Output/AGEB/pcr_model_denue.rds"))
## Caso máximo
pcr_pred_max <- NULL
for(i in 1:11){
  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)
  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), ".comp"))
}

## Caso mínimos 
pcr_pred_min <- NULL
for(i in 1:11){
  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)
}


pcr_extremos <- matrix(NA, nrow = 11, ncol = 3)
for(i in 1:11){
  pcr_extremos[i, 1] <- paste(tablas[i])
  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]
  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]
}
colnames(pcr_extremos) <- c("Indicadores", "Máximo", "Mínimo")
write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_DENUE.txt"), sep = ",")
```


### Educación {.unnumbered}

```{r}
load(paste0(here::here(), "/Bases/AGEB/Indicadores_Escuelas_SEP.RData"))

sep_ageb <- sep_ageb %>%
             mutate(suma = rowSums(.[3:11])) %>%
               mutate(suma = as.numeric(.$suma)) %>%
                filter(.$suma != 0) %>%
                  select(-suma)
```

**Análisis de componentes principales**

```{r}
PCA_SEP <- PCA(sep_ageb[, c(3:11)],
                scale.unit = TRUE, 
                 ncp = ncol(sep_ageb[, c(3:11)]),
                  graph = FALSE)
```


```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 5

# Índices de las componentes principales seleccionados
PC_SEP <-  sep_ageb %>%
              select(CVE_AGEB)  %>%
               mutate(PC = as.numeric(scale(as.matrix(sep_ageb[, c(3:11)])) %*% 
                              as.matrix(PCA_SEP[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_SEP[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_SEP,  file = paste0(here::here(), "/Output/AGEB/PC_SEP.Rdata"))
```

```{r, echo = FALSE}
tabla <- facto_summarize(PCA_SEP, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de educación utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:9, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_SEP$PC~., data = sep_ageb[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/AGEB/pcr_model_sep.rds"))
## Caso máximo
test <- t(rep(100, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_ageb[,c(3:11)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_ageb[,c(3:11)])
pcr_pred_min <- predict(pcr_model, test)


pcr_extremos <- data.frame("Indicadores" = c("Educación"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_SEP.txt"), sep = ",")
```


### Salud {.unnumbered}

```{r}
load(paste0(here::here(), "/Bases/AGEB/Indicadores_CLUES.RData"))

clues_ageb <- clues_ageb %>%
               mutate(suma = rowSums(.[3:6])) %>%
                 mutate(suma = as.numeric(.$suma)) %>%
                  filter(.$suma != 0) %>%
                    select(-suma)
```

```{r}
PCA_CLUES <- PCA(clues_ageb[, c(3:6)],
                  scale.unit = TRUE, 
                   ncp = ncol(clues_ageb[, c(3:6)]),
                    graph = FALSE) 
```

```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 3

# Índices de las componentes principales seleccionados
PC_CLUES <-  clues_ageb %>%
              select(CVE_AGEB) %>%
               mutate(PC = as.numeric(scale(as.matrix(clues_ageb[, c(3:6)])) %*% 
                                       as.matrix(PCA_CLUES[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_CLUES[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_CLUES,  file = paste0(here::here(), "/Output/AGEB/PC_CLUES.Rdata"))
```


```{r, echo = FALSE}
tabla <- facto_summarize(PCA_CLUES, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de salud utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:4, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


#### Caso extremos {-}


```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_CLUES$PC~., data = clues_ageb[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/AGEB/pcr_model_clues.rds"))
## Caso máximo
test <- t(rep(100, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_ageb[, c(3:6)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_ageb[, c(3:6)])
pcr_pred_min <- predict(pcr_model, test)

pcr_extremos <- data.frame("Indicadores" = c("Salud"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_CLUES.txt"), sep = ",")
```


## Entorno urbano {.unnumbered}


- Son 2852 casos que no cuentan con alguna viviendas particulares habitadas 
- Son 2760 casos que no cuentan con población. 


```{r}
load(paste0(here::here(), "/Bases/AGEB/EU_ageb.RData"))

EU_ageb <- EU_ageb %>%
            select(CVE_AGEB, PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N, C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N, C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)
```


- Son 2852 casos que no cuentan con alguna viviendas particulares habitadas 
- Son 2760 casos que no cuentan con población. 

**Análisis de componentes principales**

```{r}
PCA_EU <- PCA(EU_ageb[, c(2:ncol(EU_ageb))],
               scale.unit = TRUE, 
                  ncp = ncol(EU_ageb[,c(2:ncol(EU_ageb))]),
                   graph = FALSE) 
```



```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 7

# Índices de las componentes principales seleccionados
PC_EU <-  EU_ageb %>%
              select(CVE_AGEB) %>%
               mutate(PC = as.numeric(scale(as.matrix(EU_ageb[, c(2:ncol(EU_ageb))])) %*% 
                                       as.matrix(PCA_EU[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_EU[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()
save(PC_EU,  file = paste0(here::here(), "/Output/AGEB/PC_EU.Rdata"))
```

```{r, echo = FALSE}
tabla <- facto_summarize(PCA_EU, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de salud utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:19, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

#### Caso extremos {-}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_EU$PC~., data = EU_ageb[, c(2:ncol(EU_ageb))], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "CV", segments = 1000)

saveRDS(pcr_model, file = paste0(here::here(), "/Output/AGEB/pcr_model_eu.rds"))

## Caso máximo
test <- t(rep(100,19)) %>% as.data.frame() 
colnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])

pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0,19)) %>% as.data.frame() 
colnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])

pcr_pred_min <- predict(pcr_model, test)

pcr_extremos <- data.frame("Indicadores" = c("Entorno Urbano"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_EU.txt"), sep = ",")
```


Son 387 AGEB Urbanas que no contienen cálculo de entorono urbano. 
Se anexan los indicadores sin cálculo de entorno urbano, el cual se les imputaron los valores a nivel localidad y a tres de ellos a nivel municipal. 

```{r, echo = FALSE}
pcr_model <- readRDS(paste0(here::here(), "/Output/AGEB/pcr_model_eu.rds"))
```


```{r}
load(paste0(here::here(), "/Output/AGEB/EU_imputacion.Rdata"))
```

**Modelo predictivo**
**Se une los datos imputados y los datos de entorno urbano por AGEB Urbana**

```{r}
# Modelo predictivo de los datos imputados
pcr_pred <- predict(pcr_model, EU_imputacion[-1]) 
pcr_pred <- data.frame(CVE_AGEB = EU_imputacion$CVE_AGEB, PC = pcr_pred) %>%
              select(., c(1, ncp + 1)) %>% 
               mutate(Indicadora = "Datos imputados_Entorno Urbano")
colnames(pcr_pred) <- c("CVE_AGEB", "PC", "Indicadora")

PC_EU <- PC_EU %>%
          mutate(Indicadora = "") %>%
           rbind(pcr_pred)

save(PC_EU, file = paste0(here::here(), "/Output/AGEB/PC_EU.Rdata"))           
```



```{r, echo = FALSE, out.width = "60%"}
tabla <- PC_EU %>%
          arrange(PC) %>%
            mutate(n = seq_len(nrow(PC_EU)))

p <-  tabla %>%
       ggplot() +
  #      annotation_custom(mont, -Inf, Inf, -Inf, Inf) +
        geom_line(data = tabla %>% filter(Indicadora == ""), aes(x = n, y = PC, color = "LINE1"), size = 2, alpha = 0.5) + 
         geom_point(data = tabla %>% filter(Indicadora == "Datos imputados_Entorno Urbano"), aes(x = n, y = PC, color = "LINE2"), size = 2, alpha = 1) + 
         theme_ipsum_es(grid="X") +
           theme(title = element_text(size = 15, family = "Century Gothic"),
                  plot.title = element_text(size = 12,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 10, hjust = 0.5, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.line.x = element_line(color="black", size = 0.6),
                             axis.line.y = element_line(color="black", size = 0.6),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
            scale_color_manual(labels = c("Entorno Urbano", "Datos imputados"), values = c("#337EFF", "#828282")) + 
            scale_fill_manual(labels = c("Entorno Urbano", "Datos imputados"), values = c("#337EFF", "#101395")) + 
              labs(title = "Principal Components Regression (PCR)",
                   x = paste(ncp, "Componentes"),
                   y = "fitted.values", 
                   color = "", 
                    fill = "")
p
```


```{r, echo=FALSE}
rm(list = ls())
```

## Calidad del entorno {-}

**Marco Geoestadístico Nacional**

```{r}
load(paste0(here::here(), "/Bases/AGEB/MGN_ageb.Rdata"))
```

**Marginación**

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_IMU.Rdata"))

IMU <- PC_IMU %>%
         rename("IMU" = "PC")
```


**DENUE**

Se excluyen los subsistemas de `Educación` y `Salud`. 

```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
Indicadores <- names(Subsitemas)

load(paste0(here::here(), "/Output/AGEB/PC_DENUE.Rdata"))

tabla <- NULL
for(i in 1:11){
  if(i %in% 1){
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c("CVE_AGEB"))
  } else {
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c("CVE_AGEB")) %>%
                 select(.,2)
  }
}

DENUE <- do.call(cbind.data.frame, tabla)
colnames(DENUE) <- c("CVE_AGEB", Indicadores)
rm(tabla_DENUE)
```



**SEP** 

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_SEP.Rdata"))
SEP <- PC_SEP %>%
         rename("Educacion" = "PC")
```

**CLUES**

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_CLUES.Rdata"))

CLUES <- PC_CLUES %>%
          rename("Salud" = "PC")
```


**Entorno Urbano** 

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_EU.Rdata"))

EU <- PC_EU %>%
       rename("EU" = "PC")
```


**Integración del ICE**

**Imputación de valores faltantes**

A los valores faltantes de equipamiento se les imputa el valor mínimos
que puede obtener cada subsistema, calculados por el método de
componentes principales. Siendo estos los valores extremos (falta de
equipamiento), este valor se formuló utilizando Principal Component
Regresion (PCR) y de esta manera poder obtener el valor predictivo del
valor mínimo.

**Integración del ICE **

**Imputación de valores faltantes**

A los valores faltantes de equipamiento se les imputa el valor mínimos que puede obtener cada subsistema, calculados por el método de componentes principales. Siendo estos los valores extremos (falta de equipamiento), este valor se formuló utilizando Principal Component Regresion (PCR) y de esta manera poder obtener el valor predictivo del valor mínimo.  

```{r}
PCR_pred <- read.table(paste0(here::here(), "/Output/AGEB/PCR_SEP.txt"), header = TRUE, sep = ",") %>% 
             rbind(.,read.table(paste0(here::here(), "/Output/AGEB/PCR_CLUES.txt"), header = TRUE, sep = ",")) %>%
              rbind(., read.table(paste0(here::here(), "/Output/AGEB/PCR_DENUE.txt"), header = TRUE, sep = ","))
```

```{r}
ICE_2020 <- MGN_ageb %>%
             select(CVE_AGEB) %>%
              left_join(., IMU, by = c("CVE_AGEB")) %>%
               left_join(., SEP, by = c("CVE_AGEB")) %>%
                left_join(., CLUES, by = c("CVE_AGEB")) %>%
                 left_join(., DENUE, by = c("CVE_AGEB")) %>% 
                  left_join(., EU, by = c("CVE_AGEB")) %>% 
                   mutate_at(vars(2:16), as.numeric)

ICE_2020 <- ICE_2020 %>%
                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),
                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),
                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),
                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),
                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),
                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),
                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),
                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),
                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),
                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),
                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),
                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),
                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,
                   mutate(Indicadora = case_when(is.na(.$IMU) ~ "Sin cálculo de marginación",
                                                 is.na(.$EU) ~ "Sin cálculo de entorno urbano", 
                                                 .$Indicadora == "Datos imputados_Entorno Urbano" ~ "Datos imputados_Entorno Urbano"))
table(ICE_2020$Indicadora)
```

**Se anexan los datos a la base `MGN`**

**Son 387 observaciones que no tiene cálculo del entorno urbano**

Es importante determinar que sucede con las AGEB que no tienen cálculo

```{r}
ICE_2020 <- ICE_2020 %>%
             filter(is.na(.$Indicadora)  | .$Indicadora == "Datos imputados_Entorno Urbano") %>%
              select(-Indicadora) 
```


### Método de Distancias $DP_2$ {.unnumbered}

José Bernardo Pena Trapero:
`Problemas de la medición del bienestar y conceptos afines (1977)`

Primeramente se define como es la entrada de los indicadores simples.\
Este tipo de método - Índice de marginación (Negativo) (Marginación baja
(-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento +
CLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de
accesibilidad (Negativo) (Accesibilidad alta (cercanos a cero) /
Accesibilidad baja (Alejados del cero))


```{r}
ICE_2020_data <- ICE_2020 %>%
                   mutate(IMU = -1*.$IMU)
```


**Base de referencia**

**Nota.-** Se toma como base de referencia el valor del mínimo de cada
indicador simple.

```{r}
minRV <- makeReferenceVector(X = ICE_2020_data[2:16], 
                             reference_vector_function = 'min')
minRV
```

```{r, echo = FALSE}
tabla <- t(minRV) %>%
           as.data.frame() %>%
            tibble::rownames_to_column(var = "Indicadores")
tabla %>%              
  kable(caption = "Tabla: Base de referencia a nivel AGEB", 
         col.names = c("Indicadores", "Base de referencia"),
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:15, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

**Método de Distancia** $DP_{2}$

```{r}
##Calculo del Método de Distancias DP2
ind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), 
                       reference_vector = minRV, 
                        iterations = 50)
```

El modelo converge a la cuarta iteración

```{r}
ind_ice$iteration
```


```{r}
ICE_2020 <- cbind(ICE_2020, ind_ice[["p2distance"]])

# Se cambian los nombres de las columnas 
names(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "ICE")
```


```{r, echo = FALSE, fig.height=3, fig.width=7}
p <- ICE_2020 %>%
      ggplot() + 
       geom_boxplot(aes(x = ICE, y = "", color = ICE), fill = "transparent", size = 0.5) + 
        geom_jitter(aes(x = ICE, y = "", color = ICE, fill = ICE), size = 0.1, alpha = 0.1) + 
         theme_ipsum_rc(grid = "X") +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                            legend.key.size = unit(0.5, 'cm'),
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
              scale_color_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                scale_fill_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                 scale_y_discrete(expand = c(0.5,0)) +
                 labs(title = paste("Boxplot del índice de calidad del entorno"),
                       subtitle = "Nivel AGEB", 
                       color = "",  
                        fill = "", 
                         x = "", 
                          y = "") 
p
```


```{r}
# Se identifican los outliers en el índice de calidad del entorno
#boxplot.stats(DP2_2010$IM_2010)$out
outliers <- boxplot.stats(ICE_2020$ICE)

## Se crea un índice ficticio quitando los outliers   
ICE_2020 <- ICE_2020 %>%
              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],
                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],
                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) 
```


### Método de estratificación {.unnumbered}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959)\

**Nclass óptimo del método de Dalenius & Hodge**

`alloc` lista que especifica el esquema de asignación. La lista debe contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de asignación general (ver paquete de `stratification`). El valor predeterminado es la asignación de **Neyman** (q1 = q3 = 0.5 y q2 = 0)

```{r, eval = FALSE, cache=TRUE,cache.lazy=TRUE}
start.time <- Sys.time()
# Se define el coeficiente de variación a usar
coef.var <- 0.05

DH_AGEB <- list()
i <- 1
  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)
  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)
  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)
 for (n in seq(5, 1000, 1)){
   DH_AGEB[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)
   cum <- DH_AGEB[[n]]
   sd[i,] <-  c(n, cum$stderr, cum$CV)
   meanh[i,] <- c(n, cum$meanh)
   varh[i,] <-  c(n, cum$varh)
   i <- i + 1
}

colnames(sd) <- c("n","sderr","CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata",5),1:5))
colnames(varh) <- c("nclass",paste0(rep("Strata",5),1:5))

end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken

#Se guardan los resultados de las iteraciones
save(sd, file = paste0(here::here(), "/Output/AGEB/sd.Rdata"))
```

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/AGEB/sd.Rdata"))
```


```{r, collapse=TRUE}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV))
```


<div class = "row">
<div class = "col-md-3">
```{r, echo = FALSE}
min.strata %>%
    kable(col.names = c("n", "Error \n estándar", "CV"),
                   digits = 4, 
                    align = 'c',
                    format.args = list(font_size = '9px', family = "Century Gothic"),
                     format = "html", 
                      booktabs = FALSE) %>% 
            kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
             kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 9) %>%
              column_spec(1, bold = T, border_right = T) %>%
               row_spec(0, bold = T) %>%
                  row_spec(1, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
              footnote(., general = "Elaboración propia", 
                        general_title = "Fuente:", 
                         footnote_as_chunk = T) 
```
</div>

<div class = "col-md-8">
```{r, echo = FALSE, out.width = "80%", out.height= "80%"}
rows <- c(nrow(sd))

p <- sd %>%
      as.data.frame() %>%
       arrange(desc(.$CV)) %>%
        mutate(count = seq(1,nrow(sd))) %>%
         ggplot() + 
          geom_point(aes(x = count, y = CV)) + 
           geom_line(aes(x = count, y = CV)) +
            geom_text(data = min.strata, aes(label = paste("CV = ", round(CV, 4) ," | nclass  =", n), x = rows -300, y = CV),  
                       vjust = -1,
                         size = 3,
                          color = "red",
                           family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
                labs(title = "Método de Dalenius & Hodges óptimo",
                      subtitle = paste("Índice de calidad del entorno | Método iterativo | CV Óptimo"),
                       y = "CV", 
                        x = "iteraciones") 
p
```
</div>
</div>


```{r}
strata.ice <- strata.cumrootf(ICE_2020$ICE_out,
                               CV = 0.05, 
                                Ls = 5,
                                 alloc = c(0.5,0,0.5), 
                                  nclass = min.strata$n)

## Se agrega a la base de datos
ICE_2020 <- ICE_2020 %>%
              select(-ICE_out) %>%   # Se quita el índice ficticio
                mutate(G.ICE = strata.ice[["stratumID"]])


# Se cambian los nombres de las columnas 
colnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "G.ICE")

# Se cambian los levels de D&H
levels(ICE_2020$G.ICE) = c("Completa", "Grave", "Moderada", "Ligera", "No hay")
```


**Indice normalizado**

**Escenarios del mínimo y máximo valor en el índice DP2**

**Se guarda la bases de Datos del ICE por municipio**

```{r}
# Desviación estandar de los indicadores
desvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%
                       as.data.frame() %>%
                        rename("desvest" ="V1") %>%
                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%
                            mutate(desvest.inversa = 1/(.$sd_muestral))

# Escenario mínimo
vector_minimo <- as.matrix(minRV)

tabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])]
minimo <- data.frame(Escenario = "Mínimo", tabla, DP2 = sum(tabla))


# Escenario máximo
vector_maximo <-  c(apply(ICE_2020_data[2:15], 2, max), 
                      IEU = 80.7211704737366)

tabla <- abs(vector_maximo - minRV)*desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])]  %>%
             as.data.frame() 
maximo <- data.frame(Escenario = "Máximo", tabla, DP2 = sum(tabla))

# Indice normalizado
min_DP2 <- minimo$DP2[1]
max_DP2 <- maximo$DP2[1]

ICE_2020 <- ICE_2020 %>%
              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%
               arrange(ICE_Norm)

# Se guarda el índice de calidad del entorno normalizado
save(ICE_2020, file = paste0(here::here(), "/Bases/AGEB/ICE_2020.RData"))
```


<!--chapter:end:05_AGEB.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Criterios de validación {.unlisted .unnumbered}  

En este apartado se desglozaran todos los criterios que se usaron para validar los datos. 

## Municipio {-} 

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.

<a href="/images/Municipio/Comportamiento acumulado_PC1 a PC9_IMM.png" data-lightbox="image-1" data-title="IMM_Sedimentacion">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Municipio/Comportamiento acumulado_PC1 a PC9_IMM.png"))
```
</a>

**Contribución de las variables**
<a href="/images/Municipio/Contribución de las variables_IMM.png" data-lightbox="image-1" data-title="IMM_Contribucion">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/images/Municipio/Contribución de las variables_IMM.png"))
```
</a>


## Localidad {-}

## AGEB {-}

<!--chapter:end:06_Validacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Discusión {.unnumbered}

<!--chapter:end:07_Observaciones.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Anexos (COBAMEX-CIF) {.unnumbered}

En este apartado vamos ir encontrando todas las anotaciones para mi tesis. 

[Trabajo aplicativo ](https://www.notion.so/Trabajo-aplicativo-fd58ff87299e4b68863daa68eb471239?pvs=21) 

[Índice de calidad del entorno](https://www.notion.so/ndice-de-calidad-del-entorno-ad60345edd864bc6ac9b132fb90b033f?pvs=21) 

[PROYECTO de Norma Oficial Mexicana PROY-NOM-039-SSA-2023, en materia de Certificación de la Discapacidad.](https://www.notion.so/PROYECTO-de-Norma-Oficial-Mexicana-PROY-NOM-039-SSA-2023-en-materia-de-Certificaci-n-de-la-Discapac-1e8d63a6634741dba9a16687a0341866?pvs=21)

[Historia ](https://www.notion.so/Historia-81de3d74c9aa4ffebd2766cb21312c7e?pvs=21)

[Referencias](https://www.notion.so/Referencias-6dacbdd8da30450fa1b6c683fa349fc9?pvs=21)

[Términos](https://www.notion.so/T-rminos-bb8c8b2d227840ce943d139d71a67c68?pvs=21)

[**Las personas con discapacidad en México: una visión censal**](https://www.notion.so/Las-personas-con-discapacidad-en-M-xico-una-visi-n-censal-fce0fe5bc6244aec908303615824c6eb?pvs=21)

## Componentes de la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud. {-}

Componentes que interactúan de acuerdo al enfoque integrador biopsicosocial. Inician con una condición de salud y posteriormente se subdividen en dos partes: 

**Parte 1 se ocupa del funcionamiento y la discapacidad** y dentro de ésta están las funciones y **estructuras corporales y actividad y participación**. 

**Parte 2 se ocupa de los factores contextuales**, donde se encuentran los **factores ambientales y los factores personales**. Para la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud, versión para la infancia y la adolescencia, es el mismo modelo. Para una valoración integral se deben considerar todos los componentes tal como se muestra en la figura.  

<a href="/images/Anexos/Componentes_CIF.png" data-lightbox="image-1" data-title="Componentes_CIF">
```{r, echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics(paste0(here::here(), "/images/Anexos/Componentes_CIF.png"))
```
</a>

Figura 1. Interacción de componentes de la CIF

<a href="/images/Anexos/Cuestionarios_CEDis.png" data-lightbox="image-1" data-title="Cuestionarios_CEDis">
```{r, echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics(paste0(here::here(), "/images/Anexos/Cuestionarios_CEDis.png"))
```
</a>

## Generalidades {-}

1. Para fines sanitarios la Secretaría de Salud (SS) es responsable del diseño del certificado de discapacidad, alineado a lo establecido en los tratados internacionales de los que México forma parte, entre los que destaca la Convención sobre los Derechos de las Personas con Discapacidad (CDPD) y adoptar la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud (CIF).   
2. En este sentido, a toda persona que lo solicite y posterior al proceso de valoración se le debe extender un Certificado Electrónico de Discapacidad (CEDis) en términos de lo plasmado en el Capítulo 7 de esta Norma.   
3. La Secretaría de Salud (SS), a través de la Dirección General de Información en Salud (DGIS), es responsable de elaborar, difundir y vigilar la normatividad para los procesos de diseño, captación, integración, procesamiento y difusión de las estadísticas en salud, entre la que se encuentra la relacionada con discapacidad.    
4. Todo personal de la salud o relacionado con la salud que participe en la valoración de la discapacidad, así como el profesional de la medicina o persona autorizada por la autoridad sanitaria para la expedición del Certificado Electrónico de Discapacidad (CEDis), debe estar capacitado en este proceso de acuerdo al enfoque integrador biopsicosocial y en apego a la Convención sobre los Derechos de las Personas con Discapacidad (CDPD) y la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud (CIF).   
5. Los datos personales y sensibles que se obtengan derivado del proceso de valoración y certificación de la discapacidad en cualquiera de sus apartados deben tratarse de conformidad con las disposiciones aplicables en materia de Transparencia, Acceso a la Información y Protección de Datos Personales.    
 
[Expedición del Certificado Electrónico de Discapacidad](https://www.notion.so/Expedici-n-del-Certificado-Electr-nico-de-Discapacidad-389e0fe809ca4d36af13d8ad81a31ea6?pvs=21)

### **Concordancia con normas mexicanas e internacionales**  {-}  

Esta norma tiene concordancia con los tratados internacionales de los que México forma parte, los cuales son:  

11.1.1. Convención sobre los Derechos de las Personas con Discapacidad  

11.1.2 Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud   

[Cuestionarios para la evaluación](https://www.notion.so/Cuestionarios-para-la-evaluaci-n-62628c733f6349f296a5de3e701770e0?pvs=21)

17 de agosto de 2022

- Aprobado en la tercera reunión extraordinaria del CTESS  

<a href="/images/Anexos/CertificadoDiscapacidad.png" data-lightbox="image-1" data-title="CertificadoDiscapacidad">
```{r, echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics(paste0(here::here(), "/images/Anexos/CertificadoDiscapacidad.png"))
```
</a>


<!--chapter:end:08_Anexos.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Marcos Normativos {.unnumbered}

## PROY-NOM-039-SSA-2023 {-}  

### 13 de diciembre de 2006 {-}    

#### La Asamblea General de las Naciones Unidas aprobó la Convención sobre los Derechos delas Personas con Discapacidad. {-}  

La cual tiene como objetivo principal cambiar el paradigma, al pasar de un modelo en el que las personas con discapacidad son tratadas como objeto de tratamiento médico, caridad y protección social a un modelo en el que las personas con discapacidad son reconocidas como titulares de derechos humanos, activas en las decisiones que influyen en su vida y capacitadas para reivindicar sus derechos

Asamblea General de las Naciones Unidas. (2006). Convención sobre los Derechos de las Personas con Discapacidad. Naciones Unidas.

### 30 de marzo de 2007 {-}  

México firmó la Convención y ratificó su Protocolo Facultativo, misma que fue confirmada por la Cámara de Senadores el 27 de septiembre de 2007 y promulgada en el Diario Oficial de la Federación (DOF) el 2 de mayo de2008, convirtiéndose así en parte de los Estados comprometidos a proteger y promover los derechos y la dignidad de las personas con discapacidad, con miras a una sociedad mundial inclusiva;

Diario Oficial de la Federación. (2008, 2 de mayo). Convención sobre los Derechos de las Personas con Discapacidad. México: Secretaría de Gobernación.

### 12 de julio de 2018, {-}  

Se publicó en el DOF el Decreto por el que se reforman y adicionan diversas disposiciones de la Ley General para la Inclusión de las Personas con Discapacidad, de la Ley General de Salud y de la Ley General de Población. En su segundo transitorio establece que el Sector Salud deberá publicar e implementar la Norma Oficial Mexicana en materia de Certificación de la Discapacidad. Esta NOM deberá elaborarse de acuerdo con los tratados internacionales de los que México forma parte y adoptar la Clasificación Internacional del Funcionamiento, la Discapacidad y la Salud;

### Reglamento Interior de la Secretaría de Salud  {-}  

El artículo 24, fracciones VI y VII. La Dirección General de Información en Salud (DGIS), coordina el funcionamiento del Centro Mexicano para la Clasificación de Enfermedades (CEMECE) y promueve y vigila el adecuado uso de clasificaciones internacionales de la Organización Mundial de la Salud;

Secretaría de Salud. (s.f.). Reglamento Interior de la Secretaría de Salud, artículo 24, fracciones VI y VII.

### Ley de Infraestructura de la Calidad  {-}  

Que establece que las Normas Oficiales Mexicanas tienen como fin esencial el fomento de la calidad para el desarrollo económico y la protección de los objetivos legítimos de interés público como la protección y promoción a la salud, mediante el establecimiento de reglas, denominación, especificaciones o características aplicables a un bien, producto, proceso o servicio, así como aquéllas relativas a terminología, marcado o etiquetado y de información; 

Se requiere contar con un documento de certificación con un enfoque integrador biopsicosocial,  por lo cual, es prioritario unificar la metodología de valoración, registro, formatos y presentación de datos para la mejor toma de decisiones en salud pública y cubrir las necesidades de la población.

Secretaría de Economía. (2018). **Ley de Infraestructura de la Calidad**. Diario Oficial de la Federación, 1 de julio de 2018.

### El Comité Consultivo Nacional de Normalización de Salud Pública  {-}  

Aprobó en la Primera Sesión Ordinaria de 2023, la publicación del Proyecto de Norma Oficial Mexicana,
**PROY-NOM-039-SSA-2023**

### Ley General de Salud  {-}  

Artículos 389, fracción I Ter, 389 Bis 2 y 389 Bis 3, establece que para fines sanitarios se extenderán, entre otros certificados, el de Discapacidad, el cual será expedido conforme a la legislación vigente y acorde con los tratados internacionales de los que México forme parte, por las personas profesionales de la medicina o persona autorizada por la autoridad sanitaria.  

Secretaría de Salud. (s.f.). Ley General de Salud, Artículos 389, fracción I Ter, 389 Bis 2 y 389 Bis 3.

## Objetivo y campo de aplicación  {-}  

Esta Norma tiene por objeto establecer los criterios, procesos y metodología para la certificación de la discapacidad bajo el enfoque integrador biopsicosocial, alineado a los tratados internacionales de los que México forma parte en materia de derechos humanos, y a la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud, así como el otorgamiento de la impresión del Certificado Electrónico de Discapacidad a la persona solicitante.

Esta Norma es de **observancia obligatoria en todo el territorio nacional** para los integrantes del Sistema Nacional de Salud que cuenten con Centros de valoración y expedición de Certificado Electrónico
de Discapacidad.

## Referencias normativas  {-}  

Para la correcta aplicación de esta Norma, es necesario consultar las siguientes Normas Oficiales Mexicanas o las que las sustituyan:

### Norma Oficial Mexicana NOM-004-SSA3-2012, Del expediente clínico.  {-}  

La Norma Oficial Mexicana NOM-004-SSA3-2012 regula la elaboración, integración, uso y conservación del expediente clínico en el Sistema Nacional de Salud. Es de cumplimiento obligatorio para todos los profesionales de la salud y tiene como objetivo principal garantizar la calidad y continuidad de la atención médica. Define los componentes esenciales del expediente clínico, como la historia clínica, notas médicas y de enfermería, y reportes de estudios de laboratorio. Además, establece las responsabilidades de los proveedores de servicios de salud respecto a la confidencialidad y protección de la información en los expedientes clínicos.

### Norma Oficial Mexicana NOM-005-SSA3-2018, Que establece los requisitos mínimos de infraestructura y equipamiento de establecimientos para la atención médica de pacientes ambulatorios.  {-}  

La Norma Oficial Mexicana NOM-005-SSA3-2018 establece los requisitos mínimos de infraestructura y equipamiento que deben cumplir los establecimientos para la atención médica de pacientes ambulatorios. Esta norma es de carácter obligatorio y tiene como objetivo asegurar que los servicios de salud proporcionados a pacientes ambulatorios sean de alta calidad y se realicen en condiciones adecuadas. La norma detalla las especificaciones necesarias para las instalaciones físicas, el equipo médico, y otros recursos necesarios para la operación eficiente y segura de estos establecimientos. Además, busca garantizar la seguridad y bienestar tanto de los pacientes como del personal de salud que labora en dichos centros.

### Norma Oficial Mexicana NOM-007-SSA2-2016, Para la atención de la mujer durante el embarazo, parto y puerperio, y dela persona recién nacida.  {-}  

La Norma Oficial Mexicana NOM-007-SSA2-2016 establece los criterios y procedimientos para la atención de la mujer durante el embarazo, parto y puerperio, así como la atención del recién nacido. Su objetivo principal es garantizar la calidad y seguridad en la atención médica proporcionada a mujeres embarazadas y recién nacidos. La norma incluye especificaciones sobre el manejo clínico, la infraestructura y el equipamiento necesario en los establecimientos de salud. También aborda la capacitación del personal y la implementación de protocolos para prevenir y manejar complicaciones durante el embarazo y el parto, con el fin de reducir la mortalidad materna y neonatal.

### Norma Oficial Mexicana NOM-008-SEGOB-2015, Personas con discapacidad. - Acciones de prevención y condiciones de seguridad en materia de protección civil en situación de emergencia o desastre.  {-}  

La Norma Oficial Mexicana NOM-008-SEGOB-2015 establece acciones de prevención y condiciones de seguridad en materia de protección civil para personas con discapacidad en situaciones de emergencia o desastre. Su objetivo es garantizar la seguridad y bienestar de las personas con discapacidad mediante la implementación de medidas específicas que faciliten su evacuación, rescate y atención en contextos de emergencia. La norma detalla las responsabilidades de las autoridades y los procedimientos que deben seguirse para proteger a este grupo vulnerable, asegurando que se tomen en cuenta sus necesidades especiales en planes y operaciones de protección civil.

### Norma Oficial Mexicana NOM-015-SSA3-2012, Para la atención integral de personas con discapacidad.  {-}  

La Norma Oficial Mexicana NOM-015-SSA3-2012 se enfoca en la atención integral de personas con discapacidad. Establece los criterios y procedimientos necesarios para garantizar una atención de calidad, segura y adecuada para este grupo poblacional. La norma detalla las responsabilidades de los profesionales de la salud y las especificaciones sobre la infraestructura y equipamiento necesarios para brindar una atención óptima. Además, busca asegurar que se respeten los derechos humanos de las personas con discapacidad, fomentando su inclusión y bienestar en el sistema de salud.

### Norma Oficial Mexicana NOM-016-SSA3-2012, Que establece las características mínimas de infraestructura y equipamiento de hospitales y consultorios de atención médica especializada.  {-}  

La Norma Oficial Mexicana NOM-016-SSA3-2012 establece las características mínimas de infraestructura y equipamiento que deben cumplir los hospitales y consultorios de atención médica especializada. Su objetivo es garantizar que estos establecimientos proporcionen servicios de salud de alta calidad y en condiciones adecuadas. La norma especifica los requisitos necesarios para las instalaciones físicas, el equipo médico y otros recursos esenciales para la operación eficiente y segura de estos centros. Además, busca asegurar la seguridad y el bienestar tanto de los pacientes como del personal de salud.

### Norma Oficial Mexicana NOM-024-SSA3-2012, Sistemas de información de registro electrónico para la salud. Intercambio de información en salud.  {-}  

La Norma Oficial Mexicana NOM-024-SSA3-2012 establece los criterios y procedimientos para la implementación de sistemas de información de registro electrónico para la salud. Su objetivo principal es garantizar el intercambio eficiente y seguro de información en el sector salud, facilitando la interoperabilidad entre los diferentes sistemas y plataformas utilizados por los proveedores de servicios de salud. La norma define los estándares técnicos y operativos que deben cumplir estos sistemas para asegurar la calidad, confidencialidad y protección de los datos de los pacientes. Además, busca mejorar la continuidad y coordinación de la atención médica, optimizando los procesos administrativos y clínicos.

### Norma Oficial Mexicana NOM-025-SSA2-2014, Para la prestación de servicios de salud en unidades de atención integral hospitalaria médico-psiquiátrica.  {-}  

La Norma Oficial Mexicana NOM-025-SSA2-2014 establece los lineamientos y requisitos para la prestación de servicios de salud en unidades de atención integral hospitalaria médico-psiquiátrica. Su objetivo principal es garantizar la calidad, seguridad y adecuación de los servicios proporcionados a pacientes que requieren atención médico-psiquiátrica en un entorno hospitalario. La norma define las especificaciones necesarias para la infraestructura, el equipamiento y el personal especializado en estas unidades, así como los procedimientos clínicos y administrativos que deben seguirse para asegurar una atención integral y efectiva a los pacientes con trastornos mentales.

### Norma Oficial Mexicana NOM-030-SSA3-2013, Que establece las características arquitectónicas para facilitar el acceso, tránsito, uso y permanencia de las personas con discapacidad en establecimientos para la atención médica ambulatoria y hospitalaria del Sistema Nacional de Salud.  {-}  

La Norma Oficial Mexicana NOM-030-SSA3-2013 establece las características arquitectónicas que deben cumplir los establecimientos de atención médica ambulatoria y hospitalaria del Sistema Nacional de Salud para facilitar el acceso, tránsito, uso y permanencia de las personas con discapacidad. Su objetivo es garantizar que los servicios de salud sean accesibles y adecuados para todos los pacientes, independientemente de sus capacidades físicas, promoviendo así la inclusión y equidad en la atención médica.

### Norma Oficial Mexicana NOM-034-SSA2-2013, Para la prevención y control de los defectos al nacimiento.  {-}  

La Norma Oficial Mexicana NOM-034-SSA2-2013 establece los lineamientos y procedimientos para la prevención y control de los defectos al nacimiento. Su objetivo principal es reducir la incidencia de defectos congénitos a través de estrategias de vigilancia epidemiológica, promoción de la salud y atención médica especializada. La norma detalla las medidas preventivas, como la suplementación con ácido fólico, el diagnóstico prenatal y la educación para la salud, así como los protocolos de atención para los recién nacidos con defectos congénitos. Además, busca garantizar la coordinación entre los diferentes niveles del sistema de salud y promover la investigación y capacitación en este ámbito.

### Norma Oficial Mexicana NOM-035-SSA3-2012, En materia de información en salud.  {-}  

La Norma Oficial Mexicana NOM-035-SSA3-2012 establece los criterios y procedimientos relacionados con la información en salud. Su objetivo principal es garantizar la calidad, disponibilidad, y confidencialidad de la información generada y utilizada en el sector salud. Esta norma busca asegurar que los datos de salud sean precisos y accesibles para mejorar la toma de decisiones, la planificación y la prestación de servicios de salud. Además, promueve la estandarización en la recolección y manejo de información para facilitar su intercambio entre diferentes entidades y sistemas dentro del Sistema Nacional de Salud.

### Norma Oficial Mexicana PROY-NOM-039-SSA-2023, en materia de Certificación de la Discapacidad.  {-}  

La Norma Oficial Mexicana NOM-039-SSA-2023 establece los criterios, procesos y metodología para la certificación de la discapacidad con un enfoque integrador biopsicosocial. Está alineada a los tratados internacionales de derechos humanos y a la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud. Su objetivo es garantizar la emisión del Certificado Electrónico de Discapacidad a las personas que lo soliciten. Es de observancia obligatoria en todo el territorio nacional para los integrantes del Sistema Nacional de Salud que cuenten con centros de valoración y expedición del certificado. Además, la norma se basa en diversas Normas Oficiales Mexicanas relacionadas con la atención médica, infraestructura, equipamiento y protección de personas con discapacidad.

## Referencias  {-}  

1. Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-004-SSA3-2012, Del expediente clínico. Recuperado de [https://www.dof.gob.mx/nota_detalle.php?codigo=5272787&fecha=15/10/2012](https://www.dof.gob.mx/nota_detalle.php?codigo=5272787&fecha=15/10/2012) (consultado el 29 de julio de 2024)
2. Diario Oficial de la Federación. (2018, 24 de enero). Norma Oficial Mexicana NOM-005-SSA3-2018, Que establece los requisitos mínimos de infraestructura y equipamiento de establecimientos para la atención médica de pacientes ambulatorios. Recuperado de [https://www.dof.gob.mx/nota_detalle.php?codigo=5518805&fecha=24/01/2018](https://www.dof.gob.mx/nota_detalle.php?codigo=5518805&fecha=24/01/2018) (consultado el 29 de julio de 2024)
3. Diario Oficial de la Federación. (2016, 7 de abril). Norma Oficial Mexicana NOM-007-SSA2-2016, Para la atención de la mujer durante el embarazo, parto y puerperio, y de la persona recién nacida. Recuperado de [https://www.dof.gob.mx/nota_detalle.php?codigo=5432287&fecha=07/04/2016](https://www.dof.gob.mx/nota_detalle.php?codigo=5432287&fecha=07/04/2016)
4. Diario Oficial de la Federación. (2015, 24 de marzo). Norma Oficial Mexicana NOM-008-SEGOB-2015, Personas con discapacidad. - Acciones de prevención y condiciones de seguridad en materia de protección civil en situación de emergencia o desastre. Recuperado de [https://www.dof.gob.mx/nota_detalle.php?codigo=5383010&fecha=24/03/2015](https://www.dof.gob.mx/nota_detalle.php?codigo=5383010&fecha=24/03/2015)
5. Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-015-SSA3-2012, Para la atención integral de personas con discapacidad. México: Secretaría de Salud.
6. Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-016-SSA3-2012, Que establece las características mínimas de infraestructura y equipamiento de hospitales y consultorios de atención médica especializada. México: Secretaría de Salud.
7. Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-024-SSA3-2012, Sistemas de información de registro electrónico para la salud. Intercambio de información en salud. Recuperado de [URL] (consultado el 29 de julio de 2024)
8. Diario Oficial de la Federación. (2014, 20 de marzo). Norma Oficial Mexicana NOM-025-SSA2-2014, Para la prestación de servicios de salud en unidades de atención integral hospitalaria médico-psiquiátrica. México: Secretaría de Salud.
9. Diario Oficial de la Federación. (2013, 23 de octubre). Norma Oficial Mexicana NOM-030-SSA3-2013, Que establece las características arquitectónicas para facilitar el acceso, tránsito, uso y permanencia de las personas con discapacidad en establecimientos para la atención médica ambulatoria y hospitalaria del Sistema Nacional de Salud. Recuperado de [URL] (consultado el 29 de julio de 2024)
10. Diario Oficial de la Federación. (2013, 24 de octubre). Norma Oficial Mexicana NOM-034-SSA2-2013, Para la prevención y control de los defectos al nacimiento. Recuperado de [URL] (consultado el 29 de julio de 2024)
11. Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-035-SSA3-2012, En materia de información en salud. México: Secretaría de Salud.
12. Diario Oficial de la Federación. (2024, 2 de febrero).  Proyecto de Norma Oficial Mexicana PROY-NOM-039-SSA-2023, en materia de Certificación de la Discapacidad. Recuperado de [https://dof.gob.mx/nota_detalle.php?codigo=5715918&fecha=02/02/2024#gsc.tab=0](https://dof.gob.mx/nota_detalle.php?codigo=5715918&fecha=02/02/2024#gsc.tab=0) (consultado el 29 de julio de 2024)

<!--chapter:end:09_Normas.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Históricos {.unnumbered}

## Ámbito Internacional (Internacional) {-} 

### Panorama de la Discapacidad a Nivel Internacional: Desde sus Inicios hasta la Actualidad {-} 

#### Antigüedad {-} 

En la antigüedad, las percepciones y tratamientos de la discapacidad variaban considerablemente entre culturas. En el **Egipto Antiguo**, las representaciones artísticas sugieren una cierta aceptación social de las personas con discapacidades. Por contraste, en la **Grecia Antigua**, los infanticidios motivados por eugenesia eran comunes, mientras que en **Roma** se observaban actitudes mixtas, con prácticas tanto de infanticidio como de entretenimiento mediante personas con deformidades. En la **China Antigua**, los textos médicos de la dinastía Han describían diversas discapacidades y sus tratamientos, mostrando un enfoque más médico.   

#### Edad Media {-} 

Durante la Edad Media, la percepción de la discapacidad también varió. En el mundo **islámico medieval**, se realizaron avances significativos en la medicina, lo que permitió una mejor comprensión y tratamiento de diversas discapacidades. En **Europa Medieval**, las personas con discapacidades eran a menudo vistas como objeto de caridad cristiana, lo que llevó a la fundación de instituciones benéficas y hospitales.   

#### Renacimiento y Edad Moderna {-} 

El **Renacimiento** trajo un resurgimiento del interés en la ciencia y la medicina, promoviendo un enfoque más racional hacia la discapacidad. En el siglo XVIII, la **Ilustración** introdujo ideas sobre la igualdad y los derechos humanos, influyendo en la percepción y el tratamiento de las personas con discapacidades.   

#### Siglo XX {-} 

El siglo XX fue testigo de cambios significativos. Las **Guerras Mundiales** aumentaron el número de personas con discapacidades debido a las lesiones de guerra, lo que impulsó el desarrollo de nuevas tecnologías de rehabilitación y prótesis. El **movimiento por los derechos civiles** en la segunda mitad del siglo XX también incluyó la lucha por los derechos de las personas con discapacidades, resultando en leyes como el Americans with Disabilities Act (ADA) de 1990.   

En 1981, la ONU declaró el **Año Internacional de las Personas con Discapacidad**, promoviendo la sensibilización y la acción global. En 1980, la OMS publicó la **Clasificación Internacional de Deficiencias, Discapacidades y Minusvalías (CIDDM)**, proporcionando un marco para comprender y clasificar las discapacidades.   

#### Siglo XXI {-} 

En el siglo XXI, se han hecho importantes avances en la inclusión y los derechos de las personas con discapacidades. En 2006, la ONU adoptó la **Convención sobre los Derechos de las Personas con Discapacidad (CDPD)**, un tratado internacional que busca proteger los derechos y la dignidad de las personas con discapacidades.   

Los **Objetivos de Desarrollo Sostenible (ODS)** de 2015 también incluyen varias metas específicas relacionadas con la discapacidad, como garantizar la educación inclusiva y equitativa y promover el empleo pleno y productivo.   

#### Avances Tecnológicos y Educativos {-} 

El desarrollo tecnológico ha permitido la creación de dispositivos avanzados que mejoran la movilidad y la comunicación, como sillas de ruedas motorizadas, software de reconocimiento de voz y prótesis biónicas. Los sistemas educativos han adoptado políticas más inclusivas, promoviendo la participación plena de estudiantes con discapacidades en aulas regulares mediante tecnologías de apoyo y metodologías pedagógicas adaptativas.   

#### Legislación Internacional {-} 

La **Convención sobre los Derechos de las Personas con Discapacidad de la ONU**, adoptada en 2006, ha sido fundamental en la promoción de los derechos y la dignidad de las personas con discapacidades a nivel global, obligando a los estados miembros a implementar políticas inclusivas y accesibles.  

#### Perspectivas Futuras {-} 

El futuro de la discapacidad está marcado por un enfoque en la inclusión, accesibilidad y el respeto a los derechos humanos. Los avances en tecnología asistiva, la educación inclusiva, y la expansión de leyes que protegen los derechos de las personas con discapacidad continúan siendo una prioridad global. Las campañas de sensibilización y educación pública están ayudando a reducir el estigma y promover una mayor comprensión y aceptación de la discapacidad en la sociedad.  

<a href="/images/Anexos/L%C3%ADnea%20de%20tiempo%20sobre%20discapacidad%20(Internacional).png" data-lightbox="image-1" data-title="linea_tiempo_1">
```{r, echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics(paste0(here::here(), "/images/Anexos/Línea de tiempo sobre discapacidad (Internacional).png"))
```
</a>

**Referencias**   
- Metzler, Irina. (2013). *Disability in Medieval Europe: Thinking about Physical Impairment during the High Middle Ages, c. 1100–1400*. Routledge.   
- Rocha, Arturo (2001). Nadie es ombligo en la tierra. Ayac xictli in tlaltícpac. Discapacidad en el México antiguo, Cultura náhuatl. TELETON, Editorial Miguel Ángel Porrúa. México.   
- Aguado Díaz, Antonio León (1993). Historia de las Deficiencias. Colección Tesis y Praxis. Escuela Libre Editorial, Fundación ONCE. Madrid, España.  
- Porter, G.L. (1997). Critical Elements for Inclusive Schools. En: Pijl, S.J., Meijer, C.J.W., y Hegerty, S. (Eds.) Inclusive Education, a Global Agenda. London : Routledge Publishing.  
- Baynton, Douglas C. (2016), “Disability in History”, Disability Studies Quarterly, 28 (3), available at: [http://dsq-sds.org](http://dsq-sds.org/)/article/view/108/108.   
- Harrison, Mark. (2000). *The Medical War: British Military Medicine in the First World War*. Oxford University Press.   
- Lo, V. (2000). *The Influence of Buddhism on Chinese Medicine*. In H. T. Barrett (Ed.), *Chinese medicine and healing: An illustrated history* (pp. 112-137). Harvard University Press.   
- Savage-Smith, E. (1996). Attitudes toward dissection in medieval Islam. *Journal of the history of medicine and allied sciences*, 50(1), 67–110. https://doi.org/10.1093/jhmas/50.1.67   
- Lane, Harlan. (1984). *When the Mind Hears: A History of the Deaf*. New York: Random House.   
- Rose, Sarah F. ‘“Crippled” Hands: Disability in Labor and Working-Class History’, Labor 2:1 (2003), 27–54.    
- Scotch, Richard K. (2001). *From Good Will to Civil Rights: Transforming Federal Disability Policy*. Temple University Press.    
- Instituto Nacional de Estadística, Geografía e Informática (INEGI). (2000). Las personas con discapacidad en México: una visión censal.   

##  Ámbito Nacional (México) {-}   

### Panorama de la Discapacidad a Nivel Nacional en México: Desde sus Inicios hasta la Actualidad {-}    

#### Época Prehispánica en México {-}    

En la época prehispánica, las culturas indígenas de México, como la náhuatl, tenían diversas formas de interpretar y tratar las discapacidades. Las enfermedades y deficiencias eran frecuentemente asociadas a razones naturales, castigos divinos, maleficios o influencias astrológicas. Los códices Florentino y Badiano documentan prácticas terapéuticas complejas, incluyendo el uso de herbolaria y otros tratamientos.   

#### Colonia en México {-}  

Durante la colonia, la atención a las personas con discapacidades comenzó a institucionalizarse. En 1566, se fundó el Hospital de San Hipólito en Ciudad de México, el primer hospital en el continente dedicado a enfermedades mentales. En 1698, José Sáyago fundó el Real Hospital del Divino Salvador, también dedicado a enfermedades mentales. En 1794, se establecieron el Hospital de Belén en Guadalajara y el Hospital Civil en Monterrey, ambos con secciones para atender a personas con deficiencias mentales.   
  
#### Siglo XIX {-}  

El siglo XIX vio avances significativos en la educación y atención a personas con discapacidades. En 1861, Benito Juárez ordenó la creación de una escuela para sordomudos en la Ciudad de México, y en 1866, José Urbano Fonseca fundó dicha escuela. Estos esfuerzos marcaron el inicio de una mayor conciencia y acción hacia la inclusión educativa de personas con discapacidades.   

#### Siglo XX {-}  

A principios del siglo XX, se fundaron varias instituciones dedicadas a personas con discapacidades en ciudades como Veracruz, Yucatán, Jalisco y Puebla. En 1928, se creó el Instituto Nacional de Protección a la Infancia (INPI), precursor del Sistema Nacional para el Desarrollo Integral de la Familia (DIF). En 1970, se estableció el Instituto Nacional de Rehabilitación (INR) para proporcionar atención médica especializada y rehabilitación. En 1995, una reforma constitucional reconoció los derechos de las personas con discapacidades y estableció políticas públicas para su inclusión. En 1997, se creó la Fundación Teletón, que ofrece atención y rehabilitación a través de sus Centros de Rehabilitación e Inclusión Infantil Teletón (CRIT).   

#### Siglo XXI {-}  

En el siglo XXI, México ha continuado avanzando en la inclusión y derechos de las personas con discapacidades. El XII Censo de Población y Vivienda del 2000 proporcionó datos relevantes sobre la población con discapacidad en el país. En 2005, se publicó la Ley General de las Personas con Discapacidad y se creó el Consejo Nacional para el Desarrollo y la Inclusión de las Personas con Discapacidad (CONADIS). En 2007, México ratificó la Convención sobre los Derechos de las Personas con Discapacidad y su Protocolo Facultativo, adoptados por la Asamblea General de las Naciones Unidas en 2006. En 2011, una reforma constitucional amplió los derechos humanos en México, incluyendo a las personas con discapacidades.   

#### Avances Tecnológicos y Educativos {-}  

El desarrollo tecnológico en México ha permitido la creación de dispositivos avanzados que mejoran la movilidad y la comunicación, como sillas de ruedas motorizadas, software de reconocimiento de voz y prótesis biónicas. Los sistemas educativos han adoptado políticas más inclusivas, promoviendo la participación plena de estudiantes con discapacidades en aulas regulares mediante tecnologías de apoyo y metodologías pedagógicas adaptativas.   

#### Perspectivas Futuras {-}  
a
El futuro de la discapacidad en México está marcado por un enfoque en la inclusión, accesibilidad y el respeto a los derechos humanos. Los avances en tecnología asistiva, la educación inclusiva y la expansión de leyes que protegen los derechos de las personas con discapacidad continúan siendo una prioridad. Las campañas de sensibilización y educación pública están ayudando a reducir el estigma y promover una mayor comprensión y aceptación de la discapacidad en la sociedad.   

<a href="/images/Anexos/L%C3%ADnea%20de%20tiempo%20sobre%20discapacidad%20(M%C3%A9xico).png" data-lightbox="image-1" data-title="linea_tiempo_2">
```{r, echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics(paste0(here::here(), "/images/Anexos/Línea de tiempo sobre discapacidad (México).png"))
```
</a>

**Referencias**   
- Alvarez Amézquita, José; Bustamante, Miguel E.; López P. Antonio y Fernández del Castillo Francisco (1960). Historia de la salubridad y de la asistencia en México. Tomo II. SSA. México.   
- Rocha, Arturo (2001). Nadie es ombligo en la tierra. Ayac xictli in tlaltícpac. Discapacidad en el México antiguo, Cultura náhuatl. TELETON, Editorial Miguel Ángel Porrúa. México.    
- Fuentes, Mario Luis (1998). La asistencia social en México. Historia y perspectivas. Ediciones del
Milenio. México, D.F.   
- Secretaría de Salud (SSA). (2003). Historia de la atención a las personas con discapacidad en México. Ciudad de México: Secretaría de Salud.    


<!--chapter:end:10_Historicos.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
```
# Referencias {.unnumbered}

CONAPO [Consejo Nacional de Población]. (2021a). Índice de marginación por entidad federativa y municipio 2020 Nota técnico-metodológica. (2021). Recuperado de:   https://www.gob.mx/cms/uploads/attachment/file/685354/Nota_te_cnica_IMEyM_2020.pdf.   
_________. (2021b). Índice de marginación por localidad 2020 Nota técnico-metodológica. (2021). Recuperado de:  https://www.gob.mx/cms/uploads/attachment/file/685308/Nota_t_cnica_IML_2020.pdf.    

DGIS [Dirección General de Información en Salud]. (2021). Catálogo de Clave Única de Establecimientos de Salud-CLUES. Recuperado de: http://www.dgis.salud.gob.mx/contenidos/sinais/s_clues.html.    

Dalenius y Hodges, J. L., Jr. (1959). Minimum variance stratification. Journal of the American Statistical Association, 54, 88-101. Gunning, P. y Horgan, J. M.     (2004). A new algorithm for the construction of stratum boundaries in skewed populations. Survey Methodology, 30 (2), 159–166.   

Gobierno de México. (2019). Plan Nacional de Desarrollo 2019-2024, Anexo XVIII-Bis, Gaceta Parlamentaria Número 5266-XVIII, Año XXII, Palacio Legislativo San Lázaro, México. Recuperado de: http://gaceta.diputados.gob.mx/PDF/64/2019/abr/20190430-XVIII-1.pdf (consultado el 16/11/2022).  

Gunning, P. y Horgan, J. M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. Survey Methodology, 30 (2), 159–166.   
Hidiroglou, M. A. y Kozak, M. (2018). Stratification of Skewed Populations: A Comparison of Optimizationbased versus Approximate Methods. International Statistical Review, 86 (1), 87–105. Recuperado de: https://doi.org/10.1111/insr.12230.    

Hubert, M. y Vandervieren, E. (2007). An adjusted boxplot for skewed distributions. ScienceDirect, 52 (12), 5186-5201. Recuperado de https://doi.org/10.1016/j.csda.2007.11.008.     

INEGI [Instituto Nacional de Estadística y Geografía]. (2020a). Recuperado de: Censo de Población y Vivienda 2020 https://www.inegi.org.mx/programas/ccpv/2020/    
_________. (2020b). Marco Geoestadístico Nacional 2020. Censo de Población y Vivienda 2020.  Recuperado de: https://www.inegi.org.mx/temas/mg/   
_________. (2020c). Características del Entorno Urbano y Localidad. Recuperado de: https://www.inegi.org.mx/programas/ccpv/2020/    
_________. (2021). Directorio Estadístico Nacional de Unidades Económicas. Recuperado de: https:// www.inegi.org.mx/app/mapa/denue/    
INEGI-IMT/SCT (2020). Instituto Nacional de Estadística y Geografía (INEGI), Instituto Mexicano del Transporte (IMT) y la Secretaría de Comunicaciones y Transportes (SCT). Recuperado   de:  https://www.gob.mx/imt/acciones-y-programas/red-nacional-de-caminos.  

I.T. Jolliffe: “Principal Component Analysis”, Springer, 2002. ISBN: 978-0-387-22440-4   

Martens, H., Naes, T. (1989). Multivariate Calibration. John Wiley & Sons, Chichester, UK.  

Martens, H., Martens, M. (2001). Multivariate Analysis of Quality. John Wiley & Sons, Chichester, UK.  

ONUHABITAT, (2022).  Ciudades - Desarrollo Sostenible Recuperado de: https://www.un.org/sustainabledevelopment/es/cities/   

Pena Trapero, J. B. (1977). Problemas de la medición del bienestar y conceptos afines. Una aplicación al Caso Español. Madrid: INE.  

SEDESOL [Secretaría de Desarrollo Social]. (2012). Estructura del Sistema Normativo de Equipamiento. Recuperado de: http://cdam.unsis.edu.mx/files/Servicios%20publicos%20municipales/4%20Mercados/Sistema%20Normativo%20de%20Equipamiento%20Urbano%20SEDESOL.pdf.  

SIGED [Sistema de Información y Gestión Educativa]. (2021). Secretaría de Educación Pública (SEP). Recuperado de: http://snie.sep.gob.mx/SNIESC/ .   

Somarriba, N. (2008): Aproximación a la medición de la calidad de vida en la Unión Europea. Tesis doctoral, dirigida por J. B. Pena, defendida el 11 de abril de 2008. Facultad de Ciencias Económicas y Empresariales. Universidad de Valladolid. Recuperado de: www.eumed.net/tesis-doctorales/2010/mnsa/index.htm.   

Somarriba, N. y Pena, B. (2009a): Synthetic Indicators of Quality of Life in Europe. Social Indicators Research, doi 10.1007/s11205-008-9356-y. Recuperado de: https://link.springer.com/referenceworkentry/10.1007%2F978-94-007-0753-5_3729.    

Somarriba, N. y Pena, B. (2009b): La medición de la calidad de vida en Europa, el papel de la información subjetiva. Estudios de economía aplicada, Vol. 27(2).    

Somarriba, N. y Pena, B. (2010): Un análisis dinámico de la Calidad de Vida y de la Convergencia en Europa. Anales de Estudios Económicos y Empresariales, núm. 20, pp. 283-324.   

Zarzosa, P. (Dir.) (2005): La calidad de vida en los municipios de la provincia de Valladolid. Valladolid: Diputación Provincial de Valladolid.      

Zarzosa, P. (2009): Estimación de la pobreza en las Comunidades Autónomas españolas, mediante la Distancia DP2 de Pena. Estudios de Economía Aplicada, Vol. 27(2), pp. 397-416.  

Zarzosa, P. (2012): The Social Welfare in Spain before the Crisis: Territorial and Chronological Analysis. International Journal of Advances in Management and Economics. Vol. 1, núm. 4, pp. 165-171.  

Zarzosa, P. y Somarriba, N. (2013): An Assessment of Social Welfare in Spain: Territorial Analysis Using a Synthetic Welfare Indicator.  Social Indicators Research, Vol. 111, pp. 1-23.   


Las librerías que se usaron para este projecto. 

```{r, collapse=FALSE}
sesion_info <- devtools::session_info()
```


```{r, echo = FALSE}
kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
   kable_classic(full_width = TRUE, html_font = "Century Gothic", font_size = 10) 
```

Nota:
https://www.yotambien.mx/opinion/los-factores-ambientales-y-la-discapacidad    

Artículos
https://www.gob.mx/cms/uploads/attachment/file/869213/Articulo_3_Parte1.pdf   
https://www.gob.mx/cms/uploads/attachment/file/869214/Articulo_3_Parte2.pdf   

página y la metodología 
https://www.gob.mx/conapo/documentos/indice-de-calidad-del-entorno?idiom=es   
https://www.gob.mx/cms/uploads/attachment/file/784373/Nota_t_cnica_ICE_2020.pdf   

DOF del Índice de Calidad del Entorno 
https://www.dof.gob.mx/nota_detalle.php?codigo=5715917&fecha=02/02/2024#gsc.tab=0   

Norma Oficial de Discapacidad 
https://dof.gob.mx/nota_detalle.php?codigo=5715918&fecha=02/02/2024#gsc.tab=0   

Metodología 
https://dvillasanao.github.io/ICE_2020/  


<!--chapter:end:11_Referencias.Rmd-->

