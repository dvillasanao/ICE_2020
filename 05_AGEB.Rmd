# AGEB {.unlisted .unnumbered}


```{r, echo = FALSE, out.width = '100%', fig.asp = 1, fig.align='center'}
readRDS(file = paste0(here::here(), "/Output/AGEB/Network_AGEB.rds"))
```



Se toma como referencia el marco geoestadístico nacional 2020 a nivel localidad 

```{r}
load(paste0(here::here(), "/Bases/AGEB/MGN_ageb.Rdata"))
```



## Marginación {.unnumbered}

Se vuelve a reestructurar la base de datos a nivel AGEB 2020, donde los principales cambios que se hacen: 
-	Se agregan esas AGEB con el margen de error mayores al 90%.
-	En la base publicada del índice de marginación a nivel AGEB, Se excluyeron a aquellas AGEB que no presentaban a algún cálculo en uno de los indicadores. 
- También se quita el filtro de 20 viviendas totales y se contempla a el total de viviendas. 

**Bases de datos**

Se carga la nueva base del índice de marginación 2020. 

Para el cálculo de los componentes principales depende de las unidades
de medida empleadas en las variables. Por lo que es importante, antes de
aplicar `PCA`, estandarizar los indicadores simples para que tengan
media **0** y desviación estándar **1**, ya que, de lo contrario, las
variables con mayor varianza dominarían al resto, aunque en el caso en
que las variables estén medidas en las mismas unidades, podemos optar
por no estandarizarlas. La estandarización se lleva a cabo restando a
cada observación la media y dividiendo entre la desviación estándar de
la variable a la que pertenece:

$$Z_{i}=\frac{x_{i}-\bar{x}}{\sigma_{i}}$$

Se utiliza la función $PCA$ del parquete **FactoMiner**, donde se
especifica que se estandaricen las vairables con el parámetro
*scale.unit=TRUE*

**Análisis de componentes principales**



**Se utilizan todas las variables** 

```{r, eval = FALSE}
load(paste0(here::here(), "/Bases/AGEB/IMU.Rdata"))

PCA_IMU <- PCA(IMU[, c(2:ncol(IMU))],
                 scale.unit = TRUE, 
                  ncp = ncol(IMU[, c(2:ncol(IMU))]),
                   graph = FALSE) 
```


**Es importante seleccionar que gráficos se pueden incluir en el análisis**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada

Por otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos a través de descomposición de valores singulares (`SVD`) de la matriz de datos.

$$\mathbf X = \mathbf U \mathbf S \mathbf V^\top$$ - Segundo, desde el punto de vista `PCA` que requiere el cálculo de los valores propios y
los vectores propios, haciendo la descomposición propia de $\mathbf X \mathbf X^{T}$.

$$\mathbf X \mathbf V = \mathbf U \mathbf S \mathbf V^\top \mathbf V = \mathbf U \mathbf S$$

Donde - $\mathbf V$ son los eigenvectors - $\mathbf U$ es la matriz unitaria - $\mathbf S$ es la traza de los eigenvalues

Las columnas de $\mathbf {US}$ son los pesos de las componentes principales

**Se generan los índices de cada uno de los subsistemas** **Se utilizan
a los componentes principales que expliquen el máximo de la información**

Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.


```{r, eval = FALSE}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 6

# Índices de las componentes principales seleccionados
PC_IMU <-  IMU %>%
              select(CVE_AGEB) %>%
               mutate(PC = as.numeric(scale(as.matrix(IMU[,c(2:ncol(IMU))])) %*% 
                                       as.matrix(PCA_IMU[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_IMU[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()
save(PC_IMU, file = paste0(here::here(), "/Output/AGEB/PC_IMU.Rdata"))
```

**Resumen**

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/AGEB/facto_summarize_IMU.Rdata"))
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de marginación utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:11, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


## Equipamiento {.unnumbered}

**Claves económicas**

### DENUE {.unnumbered}

Se anexan los indicadores simples, de acuerdo a la clasificación económica del DENUE (**01**)

```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/AGEB/Indicadores_DENUE.RData"))
```

Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUE

```{r, class.source = "fold-show"}
load(paste0(here::here(), "/Bases/Claves_subsistema_SCIAN2018.RData"))
```



**Subramos**

Se dividen los indicadores simples de acuerdo a los 13 subsitemas económicos

```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
tablas <- names(Subsitemas)

for(i in 1:11){
assign(paste0("tabla_",tablas[i]), denue_ageb %>%
                                     ungroup() %>%
                                      select(CVE_AGEB, Subsitemas[[paste(tablas[i])]]) %>%
                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%
                                        mutate(suma = as.numeric(.$suma)) %>%
                                          filter(.$suma != 0) %>%
                                           select(-suma))
}
```

**Dimensiones de cálculo**

```{r, echo = FALSE}
tabla <- matrix(data = NA, nrow = 11, ncol = 3)
for(i in 1:11){
  tabla[i, 1] <- paste(tablas[i])
  tabla[i, 2] <- nrow(get(paste0("tabla_", tablas[i])))
  tabla[i, 3] <- length(Subsitemas[[paste(tablas[i])]])
}
colnames(tabla) <- c("Indicadores", "Observaciones", "Dimensiones")

tabla %>% 
  as.data.frame() %>%
    mutate(Observaciones = as.numeric(.$Observaciones)) %>%
  kable(caption = "Tabla: Dimensiones de cálculo", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic", big.mark = " "),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:11, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

**Análisis de componentes principales**

```{r, class.source = "fold-show"}
ncp <- c(2, 4, 2, 4, 4, 5, 2, 3, 5, 4, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))

PCA_Subsistemas <- NULL
for(i in 1:11){
  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0("tabla_", tablas[i]))[, c(2:ncol(get(paste0("tabla_", tablas[i]))))], 
                                              scale.unit = TRUE, 
                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),
                                                graph = FALSE) 
}
```

```{r}
# Índices de las componentes principales seleccionados
PC_DENUE <- NULL
for(i in 1:11){
  PC_DENUE[[i]] <- get(paste0("tabla_", tablas[i]))[1] %>%
                     select(CVE_AGEB) %>%
                       mutate(PC = as.numeric(scale(as.matrix(get(paste0("tabla_", tablas[i]))[,-1])) %*% 
                                               as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["var"]][["coord"]][,1:ncp[i]]) %*% 
                                                as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][["eig"]][,2][1:ncp[i]]/100))) %>%
                        as.data.frame()
}   

save(PC_DENUE, file = paste0(here::here(), "/Output/AGEB/PC_DENUE.Rdata"))
```


```{r, echo = FALSE}
tabla <- NULL 
for(i in 1:11){
 tabla[[paste0(tablas[i])]] <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i])
}

# Asistencia Social 
i <- 2
tabla <- facto_summarize(PCA_Subsistemas[[paste0(tablas[i])]], "var", axes = 1:ncp[i]) %>%
          select(-name) %>%
           as.data.frame() 

tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de asistencia social", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:5, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
require(pls)
## Principal Components Regression (PCR)
pcr_model <- NULL
for(i in 1:11){
pcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0("tabla_",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = "LOO")
}

saveRDS(pcr_model, paste0(here::here(), "/Output/AGEB/pcr_model_denue.rds"))
## Caso máximo
pcr_pred_max <- NULL
for(i in 1:11){
  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)
  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), ".comp"))
}

## Caso mínimos 
pcr_pred_min <- NULL
for(i in 1:11){
  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() 
  colnames(test) <- Subsitemas[[paste(tablas[i])]]
  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)
}


pcr_extremos <- matrix(NA, nrow = 11, ncol = 3)
for(i in 1:11){
  pcr_extremos[i, 1] <- paste(tablas[i])
  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]
  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]
}
colnames(pcr_extremos) <- c("Indicadores", "Máximo", "Mínimo")
write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_DENUE.txt"), sep = ",")
```


### Educación {.unnumbered}

```{r}
load(paste0(here::here(), "/Bases/AGEB/Indicadores_Escuelas_SEP.RData"))

sep_ageb <- sep_ageb %>%
             mutate(suma = rowSums(.[3:11])) %>%
               mutate(suma = as.numeric(.$suma)) %>%
                filter(.$suma != 0) %>%
                  select(-suma)
```

**Análisis de componentes principales**

```{r}
PCA_SEP <- PCA(sep_ageb[, c(3:11)],
                scale.unit = TRUE, 
                 ncp = ncol(sep_ageb[, c(3:11)]),
                  graph = FALSE)
```


```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 5

# Índices de las componentes principales seleccionados
PC_SEP <-  sep_ageb %>%
              select(CVE_AGEB)  %>%
               mutate(PC = as.numeric(scale(as.matrix(sep_ageb[, c(3:11)])) %*% 
                              as.matrix(PCA_SEP[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_SEP[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_SEP,  file = paste0(here::here(), "/Output/AGEB/PC_SEP.Rdata"))
```

```{r, echo = FALSE}
tabla <- facto_summarize(PCA_SEP, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de educación utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:9, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


#### Valores extremos {.unnumbered}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_SEP$PC~., data = sep_ageb[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/AGEB/pcr_model_sep.rds"))
## Caso máximo
test <- t(rep(100, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_ageb[,c(3:11)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 9)) %>% as.data.frame() 
colnames(test) <- names(sep_ageb[,c(3:11)])
pcr_pred_min <- predict(pcr_model, test)


pcr_extremos <- data.frame("Indicadores" = c("Educación"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_SEP.txt"), sep = ",")
```


### Salud {.unnumbered}

```{r}
load(paste0(here::here(), "/Bases/AGEB/Indicadores_CLUES.RData"))

clues_ageb <- clues_ageb %>%
               mutate(suma = rowSums(.[3:6])) %>%
                 mutate(suma = as.numeric(.$suma)) %>%
                  filter(.$suma != 0) %>%
                    select(-suma)
```

```{r}
PCA_CLUES <- PCA(clues_ageb[, c(3:6)],
                  scale.unit = TRUE, 
                   ncp = ncol(clues_ageb[, c(3:6)]),
                    graph = FALSE) 
```

```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 3

# Índices de las componentes principales seleccionados
PC_CLUES <-  clues_ageb %>%
              select(CVE_AGEB) %>%
               mutate(PC = as.numeric(scale(as.matrix(clues_ageb[, c(3:6)])) %*% 
                                       as.matrix(PCA_CLUES[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_CLUES[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()

save(PC_CLUES,  file = paste0(here::here(), "/Output/AGEB/PC_CLUES.Rdata"))
```


```{r, echo = FALSE}
tabla <- facto_summarize(PCA_CLUES, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de salud utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:4, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```


#### Caso extremos {-}


```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_CLUES$PC~., data = clues_ageb[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "LOO")

saveRDS(pcr_model, paste0(here::here(), "/Output/AGEB/pcr_model_clues.rds"))
## Caso máximo
test <- t(rep(100, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_ageb[, c(3:6)])
pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0, 4)) %>% as.data.frame() 
colnames(test) <- names(clues_ageb[, c(3:6)])
pcr_pred_min <- predict(pcr_model, test)

pcr_extremos <- data.frame("Indicadores" = c("Salud"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_CLUES.txt"), sep = ",")
```


## Entorno urbano {.unnumbered}


- Son 2852 casos que no cuentan con alguna viviendas particulares habitadas 
- Son 2760 casos que no cuentan con población. 


```{r}
load(paste0(here::here(), "/Bases/AGEB/EU_ageb.RData"))

EU_ageb <- EU_ageb %>%
            select(CVE_AGEB, PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N, C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N, C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)
```


- Son 2852 casos que no cuentan con alguna viviendas particulares habitadas 
- Son 2760 casos que no cuentan con población. 

**Análisis de componentes principales**

```{r}
PCA_EU <- PCA(EU_ageb[, c(2:ncol(EU_ageb))],
               scale.unit = TRUE, 
                  ncp = ncol(EU_ageb[,c(2:ncol(EU_ageb))]),
                   graph = FALSE) 
```



```{r}
# Índice estandarizado (SVD)
# Componentes seleccionadas
ncp <- 7

# Índices de las componentes principales seleccionados
PC_EU <-  EU_ageb %>%
              select(CVE_AGEB) %>%
               mutate(PC = as.numeric(scale(as.matrix(EU_ageb[, c(2:ncol(EU_ageb))])) %*% 
                                       as.matrix(PCA_EU[["var"]][["coord"]][,1:ncp]) %*% 
                                        as.matrix(PCA_EU[["eig"]][,2][1:ncp]/100))) %>%
                 as.data.frame()
save(PC_EU,  file = paste0(here::here(), "/Output/AGEB/PC_EU.Rdata"))
```

```{r, echo = FALSE}
tabla <- facto_summarize(PCA_EU, "var", axes = 1:ncp) %>%
          select(-name) %>%
           as.data.frame() 
tabla %>%
  kable(caption = "Tabla: Resumen de los indicadores de salud utilizando PCA", 
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:19, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

#### Caso extremos {-}

```{r, eval = FALSE}
## Principal Components Regression (PCR)
pcr_model <- pcr(PC_EU$PC~., data = EU_ageb[, c(2:ncol(EU_ageb))], ncomp = ncp,  scale = TRUE, center = TRUE, validation = "CV", segments = 1000)

saveRDS(pcr_model, file = paste0(here::here(), "/Output/AGEB/pcr_model_eu.rds"))

## Caso máximo
test <- t(rep(100,19)) %>% as.data.frame() 
colnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])

pcr_pred_max <- predict(pcr_model, test)

## Caso mínimos 
test <- t(rep(0,19)) %>% as.data.frame() 
colnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])

pcr_pred_min <- predict(pcr_model, test)

pcr_extremos <- data.frame("Indicadores" = c("Entorno Urbano"),
                           "Máximo" = pcr_pred_max[,1,][ncp],
                           "Mínimo" = pcr_pred_min[,1,][ncp]) 

write.table(pcr_extremos, file = paste0(here::here(), "/Output/AGEB/PCR_EU.txt"), sep = ",")
```


Son 387 AGEB Urbanas que no contienen cálculo de entorono urbano. 
Se anexan los indicadores sin cálculo de entorno urbano, el cual se les imputaron los valores a nivel localidad y a tres de ellos a nivel municipal. 

```{r, echo = FALSE}
pcr_model <- readRDS(paste0(here::here(), "/Output/AGEB/pcr_model_eu.rds"))
```


```{r}
load(paste0(here::here(), "/Output/AGEB/EU_imputacion.Rdata"))
```

**Modelo predictivo**
**Se une los datos imputados y los datos de entorno urbano por AGEB Urbana**

```{r}
# Modelo predictivo de los datos imputados
pcr_pred <- predict(pcr_model, EU_imputacion[-1]) 
pcr_pred <- data.frame(CVE_AGEB = EU_imputacion$CVE_AGEB, PC = pcr_pred) %>%
              select(., c(1, ncp + 1)) %>% 
               mutate(Indicadora = "Datos imputados_Entorno Urbano")
colnames(pcr_pred) <- c("CVE_AGEB", "PC", "Indicadora")

PC_EU <- PC_EU %>%
          mutate(Indicadora = "") %>%
           rbind(pcr_pred)

save(PC_EU, file = paste0(here::here(), "/Output/AGEB/PC_EU.Rdata"))           
```



```{r, echo = FALSE, out.width = "60%"}
tabla <- PC_EU %>%
          arrange(PC) %>%
            mutate(n = seq_len(nrow(PC_EU)))

p <-  tabla %>%
       ggplot() +
  #      annotation_custom(mont, -Inf, Inf, -Inf, Inf) +
        geom_line(data = tabla %>% filter(Indicadora == ""), aes(x = n, y = PC, color = "LINE1"), size = 2, alpha = 0.5) + 
         geom_point(data = tabla %>% filter(Indicadora == "Datos imputados_Entorno Urbano"), aes(x = n, y = PC, color = "LINE2"), size = 2, alpha = 1) + 
         theme_ipsum_es(grid="X") +
           theme(title = element_text(size = 15, family = "Century Gothic"),
                  plot.title = element_text(size = 12,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 10, hjust = 0.5, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.line.x = element_line(color="black", size = 0.6),
                             axis.line.y = element_line(color="black", size = 0.6),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
            scale_color_manual(labels = c("Entorno Urbano", "Datos imputados"), values = c("#337EFF", "#828282")) + 
            scale_fill_manual(labels = c("Entorno Urbano", "Datos imputados"), values = c("#337EFF", "#101395")) + 
              labs(title = "Principal Components Regression (PCR)",
                   x = paste(ncp, "Componentes"),
                   y = "fitted.values", 
                   color = "", 
                    fill = "")
p
```


```{r, echo=FALSE}
rm(list = ls())
```

## Calidad del entorno {-}

**Marco Geoestadístico Nacional**

```{r}
load(paste0(here::here(), "/Bases/AGEB/MGN_ageb.Rdata"))
```

**Marginación**

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_IMU.Rdata"))

IMU <- PC_IMU %>%
         rename("IMU" = "PC")
```


**DENUE**

Se excluyen los subsistemas de `Educación` y `Salud`. 

```{r}
load(paste0(here::here(), "/Bases/Subsistemas_DENUE.Rdata"))
Indicadores <- names(Subsitemas)

load(paste0(here::here(), "/Output/AGEB/PC_DENUE.Rdata"))

tabla <- NULL
for(i in 1:11){
  if(i %in% 1){
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c("CVE_AGEB"))
  } else {
  tabla_DENUE <- PC_DENUE[[i]]
  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c("CVE_AGEB")) %>%
                 select(.,2)
  }
}

DENUE <- do.call(cbind.data.frame, tabla)
colnames(DENUE) <- c("CVE_AGEB", Indicadores)
rm(tabla_DENUE)
```



**SEP** 

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_SEP.Rdata"))
SEP <- PC_SEP %>%
         rename("Educacion" = "PC")
```

**CLUES**

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_CLUES.Rdata"))

CLUES <- PC_CLUES %>%
          rename("Salud" = "PC")
```


**Entorno Urbano** 

```{r}
load(paste0(here::here(), "/Output/AGEB/PC_EU.Rdata"))

EU <- PC_EU %>%
       rename("EU" = "PC")
```


**Integración del ICE**

**Imputación de valores faltantes**

A los valores faltantes de equipamiento se les imputa el valor mínimos
que puede obtener cada subsistema, calculados por el método de
componentes principales. Siendo estos los valores extremos (falta de
equipamiento), este valor se formuló utilizando Principal Component
Regresion (PCR) y de esta manera poder obtener el valor predictivo del
valor mínimo.

**Integración del ICE **

**Imputación de valores faltantes**

A los valores faltantes de equipamiento se les imputa el valor mínimos que puede obtener cada subsistema, calculados por el método de componentes principales. Siendo estos los valores extremos (falta de equipamiento), este valor se formuló utilizando Principal Component Regresion (PCR) y de esta manera poder obtener el valor predictivo del valor mínimo.  

```{r}
PCR_pred <- read.table(paste0(here::here(), "/Output/AGEB/PCR_SEP.txt"), header = TRUE, sep = ",") %>% 
             rbind(.,read.table(paste0(here::here(), "/Output/AGEB/PCR_CLUES.txt"), header = TRUE, sep = ",")) %>%
              rbind(., read.table(paste0(here::here(), "/Output/AGEB/PCR_DENUE.txt"), header = TRUE, sep = ","))
```

```{r}
ICE_2020 <- MGN_ageb %>%
             select(CVE_AGEB) %>%
              left_join(., IMU, by = c("CVE_AGEB")) %>%
               left_join(., SEP, by = c("CVE_AGEB")) %>%
                left_join(., CLUES, by = c("CVE_AGEB")) %>%
                 left_join(., DENUE, by = c("CVE_AGEB")) %>% 
                  left_join(., EU, by = c("CVE_AGEB")) %>% 
                   mutate_at(vars(2:16), as.numeric)

ICE_2020 <- ICE_2020 %>%
                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),
                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),
                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),
                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),
                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),
                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),
                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),
                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),
                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),
                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),
                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),
                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),
                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,
                   mutate(Indicadora = case_when(is.na(.$IMU) ~ "Sin cálculo de marginación",
                                                 is.na(.$EU) ~ "Sin cálculo de entorno urbano", 
                                                 .$Indicadora == "Datos imputados_Entorno Urbano" ~ "Datos imputados_Entorno Urbano"))
table(ICE_2020$Indicadora)
```

**Se anexan los datos a la base `MGN`**

**Son 387 observaciones que no tiene cálculo del entorno urbano**

Es importante determinar que sucede con las AGEB que no tienen cálculo

```{r}
ICE_2020 <- ICE_2020 %>%
             filter(is.na(.$Indicadora)  | .$Indicadora == "Datos imputados_Entorno Urbano") %>%
              select(-Indicadora) 
```


### Método de Distancias $DP_2$ {.unnumbered}

José Bernardo Pena Trapero:
`Problemas de la medición del bienestar y conceptos afines (1977)`

Primeramente se define como es la entrada de los indicadores simples.\
Este tipo de método - Índice de marginación (Negativo) (Marginación baja
(-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento +
CLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de
accesibilidad (Negativo) (Accesibilidad alta (cercanos a cero) /
Accesibilidad baja (Alejados del cero))


```{r}
ICE_2020_data <- ICE_2020 %>%
                   mutate(IMU = -1*.$IMU)
```


**Base de referencia**

**Nota.-** Se toma como base de referencia el valor del mínimo de cada
indicador simple.

```{r}
minRV <- makeReferenceVector(X = ICE_2020_data[2:16], 
                             reference_vector_function = 'min')
minRV
```

```{r, echo = FALSE}
tabla <- t(minRV) %>%
           as.data.frame() %>%
            tibble::rownames_to_column(var = "Indicadores")
tabla %>%              
  kable(caption = "Tabla: Base de referencia a nivel AGEB", 
         col.names = c("Indicadores", "Base de referencia"),
               digits = 3, 
                align = 'c',
                format.args = list(font_size = '10px', family = "Century Gothic"),
                 format = "html", 
                  booktabs = FALSE) %>% 
        kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
         kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 8) %>%
          column_spec(1, bold = T, border_right = T) %>%
           row_spec(0, bold = T) %>%
            row_spec(1:15, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
        footnote(., general = "Elaboración propia", 
                  general_title = "Fuente:", 
                   footnote_as_chunk = T) 
```

**Método de Distancia** $DP_{2}$

```{r}
##Calculo del Método de Distancias DP2
ind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), 
                       reference_vector = minRV, 
                        iterations = 50)
```

El modelo converge a la cuarta iteración

```{r}
ind_ice$iteration
```


```{r}
ICE_2020 <- cbind(ICE_2020, ind_ice[["p2distance"]])

# Se cambian los nombres de las columnas 
names(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "ICE")
```


```{r, echo = FALSE, fig.height=3, fig.width=7}
p <- ICE_2020 %>%
      ggplot() + 
       geom_boxplot(aes(x = ICE, y = "", color = ICE), fill = "transparent", size = 0.5) + 
        geom_jitter(aes(x = ICE, y = "", color = ICE, fill = ICE), size = 0.1, alpha = 0.1) + 
         theme_ipsum_rc(grid = "X") +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                            legend.key.size = unit(0.5, 'cm'),
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
              scale_color_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                scale_fill_viridis_c(option = "A", begin = 0.3, end = 0.8) + 
                 scale_y_discrete(expand = c(0.5,0)) +
                 labs(title = paste("Boxplot del índice de calidad del entorno"),
                       subtitle = "Nivel AGEB", 
                       color = "",  
                        fill = "", 
                         x = "", 
                          y = "") 
p
```


```{r}
# Se identifican los outliers en el índice de calidad del entorno
#boxplot.stats(DP2_2010$IM_2010)$out
outliers <- boxplot.stats(ICE_2020$ICE)

## Se crea un índice ficticio quitando los outliers   
ICE_2020 <- ICE_2020 %>%
              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],
                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],
                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) 
```


### Método de estratificación {.unnumbered}

`strata.cumrootf`: cumulative root frequency method by Dalenius and
Hodges (1959)\

**Nclass óptimo del método de Dalenius & Hodge**

`alloc` lista que especifica el esquema de asignación. La lista debe
contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de
asignación general (ver paquete de `stratification`). El valor
predeterminado es la asignación de **Neyman** (q1 = q3 = 0.5 y q2 = 0)

```{r, eval = FALSE, cache=TRUE,cache.lazy=TRUE}
start.time <- Sys.time()
# Se define el coeficiente de variación a usar
coef.var <- 0.05

DH_AGEB <- list()
i <- 1
  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)
  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)
  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)
 for (n in seq(5, 1000, 1)){
   DH_AGEB[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)
   cum <- DH_AGEB[[n]]
   sd[i,] <-  c(n, cum$stderr, cum$CV)
   meanh[i,] <- c(n, cum$meanh)
   varh[i,] <-  c(n, cum$varh)
   i <- i + 1
}

colnames(sd) <- c("n","sderr","CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata",5),1:5))
colnames(varh) <- c("nclass",paste0(rep("Strata",5),1:5))

end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken

#Se guardan los resultados de las iteraciones
save(sd, file = paste0(here::here(), "/Output/AGEB/sd.Rdata"))
```

```{r, echo = FALSE}
load(paste0(here::here(), "/Output/AGEB/sd.Rdata"))
```


```{r, collapse=TRUE}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV))
```


<div class = "row">
<div class = "col-md-3">
```{r, echo = FALSE}
min.strata %>%
    kable(col.names = c("n", "Error \n estándar", "CV"),
                   digits = 4, 
                    align = 'c',
                    format.args = list(font_size = '9px', family = "Century Gothic"),
                     format = "html", 
                      booktabs = FALSE) %>% 
            kable_classic(full_width = FALSE, html_font = "Century Gothic", position = "center") %>% 
             kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 9) %>%
              column_spec(1, bold = T, border_right = T) %>%
               row_spec(0, bold = T) %>%
                  row_spec(1, extra_css = 'vertical-align: middle !important; padding: 2px 8px;') %>%
              footnote(., general = "Elaboración propia", 
                        general_title = "Fuente:", 
                         footnote_as_chunk = T) 
```
</div>

<div class = "col-md-8">
```{r, echo = FALSE, out.width = "80%", out.height= "80%"}
rows <- c(nrow(sd))

p <- sd %>%
      as.data.frame() %>%
       arrange(desc(.$CV)) %>%
        mutate(count = seq(1,nrow(sd))) %>%
         ggplot() + 
          geom_point(aes(x = count, y = CV)) + 
           geom_line(aes(x = count, y = CV)) +
            geom_text(data = min.strata, aes(label = paste("CV = ", round(CV, 4) ," | nclass  =", n), x = rows -300, y = CV),  
                       vjust = -1,
                         size = 3,
                          color = "red",
                           family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() +
                     theme(title = element_text(size = 15, family = "Century Gothic"),
                            plot.title = element_text(size = 15,family = "Century Gothic"),
                            plot.subtitle = element_text(size = 12, hjust = 0, family = "Century Gothic"),
                             plot.caption = element_text(size = 9, family = "Century Gothic"),
                             axis.text.x = element_text(size = 6, family = "Century Gothic"), 
                             axis.text.y = element_text(size = 6, family = "Century Gothic"), 
                              axis.title = element_text(size = 10, family = "Century Gothic"), 
                               axis.title.y = element_text(size = 10, family = "Century Gothic"), 
                                axis.title.x = element_text(size = 10, family = "Century Gothic"), 
                               legend.text =element_text(size = 10, family = "Century Gothic"), 
                                legend.title = element_text(size = 12, family = "Century Gothic")) + 
                labs(title = "Método de Dalenius & Hodges óptimo",
                      subtitle = paste("Índice de calidad del entorno | Método iterativo | CV Óptimo"),
                       y = "CV", 
                        x = "iteraciones") 
p
```
</div>
</div>


```{r}
strata.ice <- strata.cumrootf(ICE_2020$ICE_out,
                               CV = 0.05, 
                                Ls = 5,
                                 alloc = c(0.5,0,0.5), 
                                  nclass = min.strata$n)

## Se agrega a la base de datos
ICE_2020 <- ICE_2020 %>%
              select(-ICE_out) %>%   # Se quita el índice ficticio
                mutate(G.ICE = strata.ice[["stratumID"]])


# Se cambian los nombres de las columnas 
colnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], "G.ICE")

# Se cambian los levels de D&H
levels(ICE_2020$G.ICE) = c("Completa", "Grave", "Moderada", "Ligera", "No hay")
```


**Indice normalizado**

**Escenarios del mínimo y máximo valor en el índice DP2**

**Se guarda la bases de Datos del ICE por municipio**

```{r}
# Desviación estandar de los indicadores
desvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%
                       as.data.frame() %>%
                        rename("desvest" ="V1") %>%
                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%
                            mutate(desvest.inversa = 1/(.$sd_muestral))

# Escenario mínimo
vector_minimo <- as.matrix(minRV)

tabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])]
minimo <- data.frame(Escenario = "Mínimo", tabla, DP2 = sum(tabla))


# Escenario máximo
vector_maximo <-  c(apply(ICE_2020_data[2:15], 2, max), 
                      IEU = 80.7211704737366)

tabla <- abs(vector_maximo - minRV)*desvest$desvest.inversa *
           ind_ice[["correction_factors"]][names(ICE_2020[,c(2:16)])]  %>%
             as.data.frame() 
maximo <- data.frame(Escenario = "Máximo", tabla, DP2 = sum(tabla))

# Indice normalizado
min_DP2 <- minimo$DP2[1]
max_DP2 <- maximo$DP2[1]

ICE_2020 <- ICE_2020 %>%
              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%
               arrange(ICE_Norm)

# Se guarda el índice de calidad del entorno normalizado
save(ICE_2020, file = paste0(here::here(), "/Bases/AGEB/ICE_2020.RData"))
```

