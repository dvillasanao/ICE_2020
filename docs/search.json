[{"path":"index.html","id":"introducción","chapter":"Introducción","heading":"Introducción","text":"Promoción de la Urbanización Sostenible por ONU-HabitatLa Organización de las Naciones Unidas, través de ONU-Habitat, impulsa una urbanización sostenible como motor de desarrollo, paz y derechos humanos. La rápida urbanización ha incrementado los habitantes en barrios pobres, infraestructuras y servicios sobrecargados, empeorando la contaminación del aire y el crecimiento urbano descontrolado. Por ello, el Objetivo 11 de los Objetivos de Desarrollo Sostenible (ODS) es crucial: “lograr que las ciudades y los asentamientos humanos sean inclusivos, seguros, resilientes y sostenibles”.Plan Nacional de Desarrollo 2019–2024En México, el Plan Nacional de Desarrollo 2019–2024 promueve garantizar los derechos económicos, sociales, culturales y ambientales en poblaciones y territorios, alineado con los objetivos de desarrollo sostenible.Índice de Calidad del Entorno (ICE) por CONAPOLa Secretaría General del Consejo Nacional de Población (CONAPO) presenta el Índice de Calidad del Entorno (ICE), un indicador compuesto que analiza las características de los asentamientos humanos, determinadas por las condiciones de marginación y la disponibilidad de servicios y equipamiento urbano. El ICE se desglosa en dos niveles geográficos: municipio y localidad, y se estructura en tres dimensiones:Dimensión sociodemográfica: Basada en indicadores socioeconómicos de los índices de marginación nivel municipal y localidad (CONAPO, 2021a y 2021b).Dimensión de equipamiento: Analiza la disponibilidad de equipamiento y servicios públicos y privados, organizados en subsistemas según el Sistema Normativo de Equipamiento (SEDESOL, 2012). Los datos provienen de fuentes como el DENUE (INEGI, 2021), SIGED (SEP, 2021) y CLUES (DGIS, 2021).\nDimensión de accesibilidad y aislamiento geográfico: Utiliza el tiempo de viaje centros urbanos según el censo 2020, como parte del estudio de accesibilidad geoespacial (CONAPO/IMT/CentroGeo, 2022).","code":""},{"path":"index.html","id":"estructura-del-índice-de-calidad-del-entorno","chapter":"Introducción","heading":"Estructura del índice de calidad del entorno","text":"Metodología del ICE.La construcción del ICE se realizó en cuatro etapas:Generación y análisis de indicadores simples asociados las dimensiones.Análisis de Componentes Principales (ACP): Reducción de variables componentes que explican la mayor varianza de los datos originales, generando un sistema de ponderación.Regresión de Componentes Principales (RCP): Método predictivo para estimar escenarios extremos y aplicar el método de distancias \\(DP_2\\) para obtener el ICE.Generación del ICE con el método \\(DP_2\\): Obtención de un índice sintético agregando la información de los indicadores.Técnicas Multivariantes ComplementariasEl uso de \\(ACP\\) y \\(DP_{2}\\) ha sido explorado en otras investigaciones. Pena (1977) argumenta que ambas técnicas son consistentes para comparar la posición relativa de las filas y obtener factores comunes de las columnas. Somarriba (2008) resalta que las agrupaciones en componentes condicionan los resultados del indicador sintético, enfocándose en los indicadores relevantes. Investigaciones adicionales que han utilizado estas técnicas incluyen trabajos de Zarzosa y Somarriba.Este resumen proporciona una visión integral del Índice de Calidad del Entorno, destacando su relevancia en la evaluación de los asentamientos humanos y la importancia de la urbanización sostenible en el marco del desarrollo nacional y global.Estrcutura del documentoMetodologíaFuentes de informaciónÍndice de Calidad del Entorno (Nivel Municipal)Índice de Calidad del Entorno (Nivel Localidad)Índice de Calidad del Entorno (Nivel AGEB)Resumen General","code":""},{"path":"metodología.html","id":"metodología","chapter":"Metodología","heading":"Metodología","text":"\n","code":""},{"path":"metodología.html","id":"primera-etapa-construcción-de-indicadores","chapter":"Metodología","heading":"Primera etapa: construcción de indicadores","text":"De acuerdo con los 13 subsistemas de equipamiento, se tomaron en consideración 71 variables que agruparon los sectores propuesto en el Sistema Normativo de Equipamiento (SEDESOL, 2012). Dada las limitaciones en la disponibilidad de datos e información oficial disponible para la conformación de las variables, estas se construyeron como porcentaje de los equipamientos disponibles en las localidades respecto al total del municipio y sector correspondiente:\\[w_{hjk} = \\sum_{h=1}^{N_{h}} \\sum_{j=1}^{n_{h}}\\frac{S_{hjk}}{S_{hk}}; \\text{donde k: 1,2,...,m} \\]\ndonde:\\(w_{hjk}\\): Razón de la característica de interés en la \\(j-ésima\\) localidad del \\(h-ésimo\\) municipio,\\(n_{h}\\): Número de localidades en el \\(h-ésimo\\) municipio,\\(N_{h}\\): Total de localidades en el \\(h-ésimo\\) municipio,\\(S_{hk}\\): Total de la característica de interés del \\(h-ésimo\\) municipio,\\(S_{hk}\\): Total de la característica de interés en la localidad \\(j-ésima\\) del \\(h-ésimo\\) municipio.","code":""},{"path":"metodología.html","id":"segunda-etapa-análisis-de-componentes-principales-pca","chapter":"Metodología","heading":"Segunda etapa: Análisis de Componentes Principales (PCA)","text":"El Análisis de Componentes Principales (PCA, por sus siglas en inglés) es un método estadístico utilizado para reducir la complejidad de un conjunto de datos. El objetivo es transformar las variables originales en un conjunto más pequeño y manejable de nuevas variables llamadas “componentes principales”.Este método se basa en el cálculo de una matriz de covarianzas o correlaciones entre las variables originales, y en la posterior obtención de los vectores y valores propios de esta matriz. Los vectores propios representan las direcciones en las que los datos tienen la mayor variabilidad, y los valores propios indican la cantidad de variabilidad explicada por cada componente principal. Los valores propios se ordenan de mayor menor, de manera que el primer componente principal explica la mayor parte de la variabilidad en los datos, y cada componente subsiguiente explica una proporción menor. Los componentes principales se utilizan para describir los datos y construir modelos estadísticos más sencillos.En resumen, el PCA es un método estadístico que reduce la complejidad de un conjunto de datos al transformar las variables originales en un conjunto más pequeño de nuevas variables que explican la mayor parte de la variabilidad de los datos.","code":""},{"path":"metodología.html","id":"ventajas-y-desventajas-del-pca","chapter":"Metodología","heading":"Ventajas y Desventajas del PCA","text":"Ventajas:Reducción de la dimensionalidad: PCA permite reducir el número de variables utilizadas para describir un conjunto de datos, facilitando su visualización y análisis.Identificación de patrones: Al identificar los componentes principales, el PCA puede ayudar encontrar patrones o relaciones entre las variables que eran evidentes en los datos originales.Eliminación de variables redundantes: PCA puede eliminar variables altamente correlacionadas, mejorando la eficiencia computacional y la interpretación de los resultados.Normalización de los datos: PCA normaliza los datos, eliminando problemas de escala o unidades diferentes entre las variables originales.Desventajas:Interpretación: La interpretación de los componentes principales puede ser difícil, especialmente si se tiene un conocimiento profundo del conjunto de datos.Pérdida de información: PCA puede eliminar información útil si se descartan componentes con baja variabilidad que podrían ser importantes para la descripción de los datos.Sensibilidad los datos atípicos: PCA puede verse afectado por datos atípicos, resultando en componentes que reflejan adecuadamente la variabilidad en los datos.Requisitos computacionales: PCA puede requerir muchos recursos computacionales, especialmente para conjuntos de datos grandes.","code":""},{"path":"metodología.html","id":"aplicación-del-pca","chapter":"Metodología","heading":"Aplicación del PCA","text":"El PCA es una técnica estadística supervisada que permite reducir la complejidad de múltiples dimensiones, conservando la información en unas pocas componentes. Dada una matriz de datos con \\(p \\times p\\) variables y \\(n \\times n\\) observaciones, donde los datos están centrados y escalados con su desviación estándar, se asegura que la nube de datos esté centrada en el origen de las componentes principales, sin verse afectada por las relaciones espaciales entre las variables.El PCA busca transformar el espacio vectorial generado por un vector \\(\\mathrm{X=}\\left(\\mathrm{\\ }X_{n1},\\ {\\ X}_{n2},\\ ...\\ ,\\ X_{np}\\right)\\) en un nuevo conjunto \\(\\mathrm{Z\\ =\\ }\\left(\\mathrm{\\ }Z_1,\\ {\\ Z}_2,\\ ...\\ ,\\ Z_k\\right),\\ \\ k\\le p\\), que sean combinaciones lineales de los indicadores y que expliquen la mayor parte de la variabilidad. Esto se expresa como:\\[Z\\ =\\ XA\\]\ndonde:\\(\\ =\\ \\left(a_{n1},\\ a_{n2},\\ ...,\\ a_{np}\\right)\\) representa las posiciones de cada observación en este nuevo sistema de coordenadas de componentes principales, denominadas loadings, y se calculan como combinaciones lineales de las variables originales y los pesos \\(a_{np}\\).El PCA también permite conocer la proporción de la varianza explicada por cada componente principal, además de la varianza total presente en un conjunto de datos:\\[\\sum_{j=1}^{p}{Var\\left(X_j\\right)\\ =}\\ \\sum_{j=1}^{p}\\frac{1}{n}\\sum_{=1}^{n}x_{ij}^2\\]\nLa varianza explicada por el \\(k-ésima\\) componente principal se define como:\\[\\frac{1}{n}\\sum_{1=1}^{n}z_{ik}^2=\\frac{1}{n}\\sum_{1=1}^{n}\\left(\\sum_{j=1}^{p}{a_{nj}x_{ij}}\\right)^2\\ \\]Por lo tanto, la proporción de la varianza explicada del \\(k-ésimo\\) componente principal está dada por:\\[\\frac{\\sum_{=1}^{n}\\left(\\sum_{j=1}^{p}{a_{nj}x_{ij}}\\right)^2}{\\sum_{j=1}^{p}\\frac{1}{n}\\sum_{=1}^{n}x_{ij}^2}\\]En total, hay \\(min(n\\ -\\ 1,\\ \\ p))\\) componentes principales, y la suma de la proporción de la varianza explicada es uno.","code":""},{"path":"metodología.html","id":"validación-del-pca","chapter":"Metodología","heading":"Validación del PCA","text":"Para validar el PCA, se considera la calidad de la representación de las variables en la construcción del modelo, lo que permite evaluar la estabilidad de las variables en los componentes. También se identifican los valores atípicos y se determina en qué medida influyen en la construcción de los indicadores.","code":""},{"path":"metodología.html","id":"descomposición-de-componentes-principales","chapter":"Metodología","heading":"Descomposición de componentes principales","text":"En el análisis de componentes principales, se puede descomponer la matriz de varianzas y covarianzas de dos maneras diferentes:Descomposición en valores propios (eigendecomposition): Esta descomposición se utiliza cuando la matriz de varianzas y covarianzas es simétrica y definida positiva. En este caso, la matriz se descompone en una matriz de autovectores y una matriz diagonal de valores propios. Los autovectores forman una base ortogonal que describe las direcciones principales de la varianza en los datos, mientras que los valores propios indican la importancia relativa de cada dirección.Descomposición en valores singulares (singular value decomposition, SVD): Esta descomposición se utiliza cuando la matriz de varianzas y covarianzas es simétrica o es definida positiva. En este caso, la matriz se descompone en tres matrices: una matriz de autovectores izquierdos, una matriz de autovectores derechos y una matriz diagonal de valores singulares. Los autovectores izquierdos y derechos forman una base ortogonal que describe las direcciones principales de la varianza en los datos, mientras que los valores singulares indican la importancia relativa de cada dirección.En ambas descomposiciones, se pueden seleccionar las componentes principales más importantes para reducir la dimensionalidad de los datos y simplificar su análisis.\n\n","code":""},{"path":"metodología.html","id":"identificación-de-datos-atípicos","chapter":"Metodología","heading":"Identificación de datos atípicos","text":"Los datos atípicos (también conocidos como valores extremos o outliers) pueden tener un impacto significativo en los resultados del método de componentes principales (PCA). Si los datos atípicos se manejan adecuadamente, pueden llevar resultados sesgados o incorrectos. Por lo tanto, es importante identificarlos y considerar cuidadosamente cómo manejarlos antes de realizar el análisis de PCA.Existen algunas estrategias para manejar los datos atípicos dentro del análisis de PCA:Identificación de los datos atípicos: Es importante identificar los datos atípicos antes de realizar el análisis de PCA. Esto se puede hacer mediante la visualización de los datos o mediante pruebas estadísticas.Identificación de los datos atípicos: Es importante identificar los datos atípicos antes de realizar el análisis de PCA. Esto se puede hacer mediante la visualización de los datos o mediante pruebas estadísticas.Exclusión de los datos atípicos: Una estrategia común para manejar los datos atípicos es excluirlos del análisis. Sin embargo, esto debe hacerse con cuidado, ya que la exclusión de los datos atípicos puede resultar en una pérdida de información importante.Exclusión de los datos atípicos: Una estrategia común para manejar los datos atípicos es excluirlos del análisis. Sin embargo, esto debe hacerse con cuidado, ya que la exclusión de los datos atípicos puede resultar en una pérdida de información importante.Transformación de los datos: Otra estrategia es transformar los datos antes de realizar el análisis de PCA. Las transformaciones comunes incluyen la transformación logarítmica o la normalización de los datos. Estas transformaciones pueden reducir la influencia de los datos atípicos y mejorar los resultados de PCA.Transformación de los datos: Otra estrategia es transformar los datos antes de realizar el análisis de PCA. Las transformaciones comunes incluyen la transformación logarítmica o la normalización de los datos. Estas transformaciones pueden reducir la influencia de los datos atípicos y mejorar los resultados de PCA.Uso de métodos robustos: Existen métodos robustos que pueden manejar los datos atípicos de manera efectiva en PCA, como el método de componentes principales robustos (RPCA, por sus siglas en inglés). Estos métodos son menos sensibles los datos atípicos y pueden proporcionar resultados más precisos.Uso de métodos robustos: Existen métodos robustos que pueden manejar los datos atípicos de manera efectiva en PCA, como el método de componentes principales robustos (RPCA, por sus siglas en inglés). Estos métodos son menos sensibles los datos atípicos y pueden proporcionar resultados más precisos.","code":""},{"path":"metodología.html","id":"método-de-componentes-principales-robustos-rpca","chapter":"Metodología","heading":"Método de Componentes Principales Robustos RPCA","text":"El método de componentes principales robustos (RPCA, por sus siglas en inglés) se utiliza cuando se sospecha que los datos contienen valores atípicos o errores que pueden afectar los resultados del análisis de componentes principales (PCA).El RPCA es una versión modificada del método de componentes principales tradicional que es menos sensible los valores atípicos y los errores en los datos. En lugar de minimizar la varianza total de los datos como en PCA, RPCA minimiza la varianza total de los datos después de excluir los valores atípicos o errores. Ete tipo de análisis puede ser útil en una variedad de situaciones, como en el análisis de datos biomédicos, análisis financiero, análisis de datos climáticos, entre otros.En general, se recomienda utilizar RPCA cuando:Los datos pueden contener valores atípicos o errores.Los datos pueden contener valores atípicos o errores.Los datos tienen una distribución normal.Los datos tienen una distribución normal.Las variables tienen diferentes escalas.Las variables tienen diferentes escalas.El tamaño de la muestra es pequeño en comparación con la dimensión de los datos.El tamaño de la muestra es pequeño en comparación con la dimensión de los datos.Se necesita una mayor precisión en los resultados del análisis.Se necesita una mayor precisión en los resultados del análisis.Observaciones del método RPCAEs importante tener en cuenta que RPCA siempre es necesario y puede ser computacionalmente más costoso que el método de componentes principales tradicional. Por lo tanto, es importante evaluar cuidadosamente si RPCA es apropiado para los datos que se estan tratando y los objetivos de análisis antes de utilizarlo.Aunque el método de componentes principales robustos (RPCA), es útil para manejar valores atípicos y errores en los datos, también presenta algunas desventajas que deben tenerse en cuenta:Mayor complejidad computacional: El método RPCA puede ser más costoso computacionalmente que el método de componentes principales tradicional debido la necesidad de excluir los valores atípicos o errores en los datos.Mayor complejidad computacional: El método RPCA puede ser más costoso computacionalmente que el método de componentes principales tradicional debido la necesidad de excluir los valores atípicos o errores en los datos.Pérdida de información: Al excluir los valores atípicos o errores en los datos, puede perderse información importante, lo que puede afectar la precisión de los resultados del análisis.Pérdida de información: Al excluir los valores atípicos o errores en los datos, puede perderse información importante, lo que puede afectar la precisión de los resultados del análisis.Dependencia del modelo: El método RPCA se basa en un modelo específico de distribución de datos, por lo que si los datos se ajustan este modelo, los resultados pueden ser incorrectos o inexactos.Dependencia del modelo: El método RPCA se basa en un modelo específico de distribución de datos, por lo que si los datos se ajustan este modelo, los resultados pueden ser incorrectos o inexactos.Selección de parámetros: El método RPCA requiere la selección de parámetros para determinar qué valores se consideran atípicos o errores, lo que puede ser subjetivo y afectar los resultados del análisis.Selección de parámetros: El método RPCA requiere la selección de parámetros para determinar qué valores se consideran atípicos o errores, lo que puede ser subjetivo y afectar los resultados del análisis.","code":""},{"path":"metodología.html","id":"tercera-etapa-regresión-de-componentes-principales-pcr","chapter":"Metodología","heading":"Tercera etapa: Regresión de Componentes Principales (PCR)","text":"El modelo de PCR es un método utilizado para reducir la dimensionalidad de los datos y evitar problemas de multicolinealidad en un modelo de regresión lineal múltiple. Este modelo se basa en la descomposición en valores singulares (SVD) de la matriz de datos originales, lo que permite identificar las componentes principales que explican la mayor parte de la varianza en los datos.partir de las componentes principales seleccionadas, se construye un modelo de regresión lineal múltiple utilizando estas componentes como variables predictoras. El número de componentes principales seleccionadas se determina de acuerdo con un criterio predefinido, como la cantidad de varianza explicada o un límite para el número de componentes.El modelo de PCR puede ser una alternativa útil la selección tradicional de variables predictoras en un modelo de regresión lineal, ya que permite reducir la dimensionalidad de los datos y evitar problemas de multicolinealidad. Sin embargo, es importante tener en cuenta que el modelo de PCR también tiene algunas limitaciones, como la interpretación de los coeficientes de regresión y la posible pérdida de información importante en los datos. Por lo tanto, se recomienda utilizar el modelo de PCR en combinación con otras técnicas de análisis de datos para obtener una comprensión completa del problema.Singular value descomposiciónEn el modelo de Regresión de Componentes Principales (PCR, por sus siglas en inglés), se utiliza la descomposición en valores singulares (SVD) para encontrar las componentes principales de los datos y reducir su dimensionalidad.La idea detrás del PCR es utilizar las componentes principales de los datos (obtenidas través de la SVD) como variables predictoras en un modelo de regresión lineal múltiple. De esta manera, se puede reducir el número de variables predictoras y evitar problemas de multicolinealidad, lo que puede mejorar la precisión del modelo y hacerlo más interpretable.En resumen, para implementar el modelo de PCR se utilizan los resultados de la descomposición en valores singulares (SVD) para seleccionar las componentes principales de los datos y construir un modelo de regresión lineal múltiple. Por lo tanto, se utiliza la descomposición en eigenvectores y eigenvalores.","code":""},{"path":"metodología.html","id":"método-de-distancias-ponderadas-al-cuadrado-dp_2","chapter":"Metodología","heading":"Método de distancias ponderadas al cuadrado \\(DP_2\\)","text":"El método de distancias ponderadas al cuadrado (DP2) de José Bernardo Peña Trapero es una técnica estadística utilizada para medir la similitud entre diferentes objetos o casos. Este método se basa en una medida de distancia que se calcula sumando las diferencias al cuadrado ponderadas entre las características de dos objetos y tomando la raíz cuadrada del resultado. La ponderación de las características permite que las más importantes tengan un mayor impacto en el resultado final mientras que las menos importantes tienen un menor impacto.El método DP2 de Peña Trapero se utiliza en una variedad de aplicaciones, como la clasificación de imágenes y la evaluación de la similitud entre diferentes textos. Una de las ventajas del método DP2 es que puede manejar datos de diferentes tipos y escalas, lo que lo hace útil en situaciones donde los datos son heterogéneos.Sin embargo, también hay algunas desventajas en el uso del método DP2, como la selección subjetiva de la función de ponderación de características y el costo computacional en grandes conjuntos de datos. Por lo tanto, se deben evaluar cuidadosamente los datos y los objetivos de análisis antes de aplicar este método.En resumen, el método DP2 de Peña Trapero es una técnica útil para medir la similitud entre diferentes objetos o casos, pero se debe aplicar con cuidado y evaluar cuidadosamente en función de los datos y objetivos de análisis.","code":""},{"path":"fuentes-de-información.html","id":"fuentes-de-información","chapter":"Fuentes de información","heading":"Fuentes de información","text":"Primeramente, las fuentes de información que se utilizaron para la realización del índice de calidad del entorno se enumeran continuación:","code":""},{"path":"fuentes-de-información.html","id":"cpv2020","chapter":"Fuentes de información","heading":"CPV2020","text":"El Censo de Población y Vivienda 2020 (CPV2020) del INEGI (Instituto Nacional de Estadística y Geografía) el objetivo fue recopilar información detallada y actualizada sobre la población y las viviendas de México para ser utilizada en la toma de decisiones y la planificación de políticas públicas y privadas en el país. Esto incluye datos sobre la cantidad y características de las personas que viven en el país, como su edad, sexo, educación, ocupación, entre otros aspectos, así como información sobre la estructura y características de las viviendas en las que habitan. El cúal este tpo de informción es importante para la planificación y la toma de decisiones en áreas como la política pública, la inversión en infraestructura, la distribución de recursos y servicios, la investigación demográfica y social, y muchas otras. Además, también es utilizado por empresas y organizaciones para el análisis de mercado y la toma de decisiones estratégicas.","code":""},{"path":"fuentes-de-información.html","id":"equipamiento","chapter":"Fuentes de información","heading":"Equipamiento","text":"\n","code":""},{"path":"fuentes-de-información.html","id":"denue","chapter":"Fuentes de información","heading":"DENUE","text":"El Directorio Estadístico Nacional de Unidades Económicas (DENUE) es la infraestructura mínima del Subsistema Nacional de Información Económica (SNIE), cuyo propósito es proveer los usuarios tanto especializados como especializados de los datos de identificación, ubicación y contacto de las unidades económicas activas en el territorio nacional para el desarrollo y evaluación, tanto de políticas públicas como de programas de fomento económico en los tres niveles de gobierno; así como apoyo en el proceso de toma de decisiones para direccionar la inversión y optimizar recursos tanto en el ámbito público como en el privado.El Directorio Estadístico Nacional de Unidades Económicas (DENUE) del INEGI cuyo objetivo es proporcionar una base de datos actualizada y completa de las unidades económicas en México. Esto incluye empresas, establecimientos, instituciones gubernamentales, organizaciones sin fines de lucro, entre otras entidades que realizan actividades económicas en el país. Este tipo de insumo sirve como base para la planificación económica, la investigación y la toma de decisiones en áreas como la inversión, el análisis de mercado, el diseño de políticas públicas, la identificación de oportunidades comerciales, entre otras. Además, también es utilizado por el sector empresarial para el análisis de la competencia, la segmentación de mercado, la identificación de clientes potenciales, entre otros fines.[Sistema de Clasificación Industrial de América del Norte, 2018 (SCIAN)]El objetivo del SCIAN México es proporcionar un marco único, consistente y actualizado para la recopilación, análisis y presentación de estadísticas de tipo económico, que refleje la estructura de la economía mexicana. El SCIAN México es la base para la generación, presentación y difusión de todas las estadísticas económicas del INEGI. Su adopción por parte de las Unidades del Estado, permitirá homologar la información económica que se produce en el país, y con ello contribuir la de la región de América del Norte.UNIDAD DE ANÁLISISLas unidades económicas las que está referida la información del DENUE son dos: El establecimiento y la empresa.El establecimiento: unidad económica que, en una sola ubicación física, asentada en un lugar de manera permanente y delimitada por construcciones e instalaciones fijas, combina acciones y recursos bajo el control de una sola entidad propietaria o controladora para realizar alguna actividad económica sea con fines de lucro o .\nIncluye las viviendas en las que se realizan actividades económicas y excluye las viviendas en las que se llevan cabo actividades económicas con fines de autoconsumo, así como los servicios que se realizan en otros sitios.El establecimiento: unidad económica que, en una sola ubicación física, asentada en un lugar de manera permanente y delimitada por construcciones e instalaciones fijas, combina acciones y recursos bajo el control de una sola entidad propietaria o controladora para realizar alguna actividad económica sea con fines de lucro o .Incluye las viviendas en las que se realizan actividades económicas y excluye las viviendas en las que se llevan cabo actividades económicas con fines de autoconsumo, así como los servicios que se realizan en otros sitios.La empresa: organización, propiedad de una sola entidad jurídica, que realiza una o más actividades económicas, con autonomía en la toma de decisiones de mercadeo, financiamiento e inversión, al contar con la autoridad y responsabilidad de distribuir recursos de acuerdo con un plan o estrategia de producción de bienes y servicios, pudiendo estar ubicada u operar en varios domicilios.La empresa: organización, propiedad de una sola entidad jurídica, que realiza una o más actividades económicas, con autonomía en la toma de decisiones de mercadeo, financiamiento e inversión, al contar con la autoridad y responsabilidad de distribuir recursos de acuerdo con un plan o estrategia de producción de bienes y servicios, pudiendo estar ubicada u operar en varios domicilios.Se excluye las unidades económicas que llevan cabo actividades de manera ambulante o aquellas en las que los locales en los que se efectúa la actividad económica son desmontables y se remueven diariamente.Se excluye las unidades económicas que llevan cabo actividades de manera ambulante o aquellas en las que los locales en los que se efectúa la actividad económica son desmontables y se remueven diariamente.Se consideran 13 subsistemas económicos de los cuales se clasificaron 52 elementos económicos que pertenecen los subistemas.Se cargan todas las bases del DENUE 2021 que se van usar, el cúal después se van seleccionar los subramos económicos.Descarga masiva\nEn esta sección podrás descargar los archivos del DENUE, el Banco de Indicadores, el Inventario Nacional de Viviendas, Microdatos y la Sala de prensa por área geográfica, proyectos, años de la información, temas y formatos para poder utilizar la información en forma local en tu equipo.\nTitle: Directorio Estadístico Nacional de Unidades Económicas (DENUE) 05_2021Se muestra el algoritmo para integrar el DENUESe integran las claves geoestadísticas para la elaboración de los indicadores simples","code":"\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\ntablas <- c(\"43\", \"46111\", \"46112-46311\",\"46321-46531\", \"46591-46911\", \"48-49\", \"51\", \"52\", \"56\", \"61\", \"62\", \"71\",  \"72_1\", \"72_2\", \"81_1\", \"81_2\")\n\n# Enlaces de las bases de datos (Descargas masivas | INEGI | DENUE)\n#https://www.inegi.org.mx/app/descarga/default.html\nurl <- read.table(file = \"Bases/DENUE/Enlaces_DENUE_0521.txt\", sep = \",\")\n\nfor(i in 1:16){\n  if(!file.exists(paste0(here::here(), \"/Bases/DENUE/denue_00_\", tablas[i], \"_0521_csv.zip\"))){\n  download.file(url[i,], paste0(here::here(), \"/Bases/DENUE/denue_00_\", tablas[i], \"_0521_csv.zip\"), mode = \"wb\")\n  }\n}\n\n# Se agrupan 16 bases de datos en formato CVS en un solo data.frame \nfor(i in tablas){\n  assign(paste0(\"df_\",i), read.csv(paste0(here::here(), \"/DENUE/CSV/CSV/conjunto_de_datos/denue_inegi_\",i,\"_.csv\"), fileEncoding = \"latin1\"))\n}\n\n# Se agrupan todas las tablas en una sola\nlista <- ls(pattern =  \"df_\")\ndenue_2021 <- do.call(rbind.data.frame, mget(lista))\n\ndenue_2021 <- denue_2021 %>%\n               select(codigo_act, nombre_act, cve_ent, entidad, cve_mun, municipio, cve_loc, localidad, ageb, manzana) %>% \n                 mutate(cve_ent = stringr::str_pad(.$cve_ent, 2, \"left\", pad = \"0\"), \n                        cve_mun = stringr::str_pad(.$cve_mun, 3, \"left\", pad = \"0\"),\n                        cve_loc = stringr::str_pad(.$cve_loc, 4, \"left\", pad = \"0\"),\n                        ageb = stringr::str_pad(.$ageb, 4, \"left\", pad = \"0\"),\n                        manzana = stringr::str_pad(.$manzana, 3, \"left\", pad = \"0\")) %>%\n                   mutate(CVE_MUN = paste0(.$cve_ent, .$cve_mun),\n                          CVE_LOC = paste0(.$cve_ent, .$cve_mun, .$cve_loc),\n                          CVE_AGEB = paste0(.$cve_ent, .$cve_mun, .$cve_loc, .$ageb), \n                          CVE_MZA =  paste0(.$cve_ent, .$cve_mun, .$cve_loc, .$ageb, .$manzana)) %>%\n# Se anexa la base de Claves\n                    left_join(., SCIAN, \n                               by = c(\"codigo_act\" = \"CODIGO\")) %>%\n                      mutate(CVE_ELE = as.character(.$CVE_ELE))\n\n# Se guarda la base de datos donde se integran 16 bases de datos\nsave(denue2021, file = paste0(here::here(), \"/Bases/DENUE/denue2021.RData\"))\n# Estructura integrada del DENUE\nload(paste0(here::here(), \"/Bases/denue_integrado.RData\"))\ncodigo <- unique(SCIAN$CODIGO)"},{"path":"fuentes-de-información.html","id":"municipio","chapter":"Fuentes de información","heading":"Municipio","text":"","code":"\ndenue_mun <- denue_2021 %>%\n              filter(.$codigo_act %in% codigo) %>%\n               select(ELEMENTO, CVE_MUN) %>%\n                melt(., id = c(\"CVE_MUN\"))  %>%\n                 mutate(value = as.character(.$value)) %>%\n                  acast(., CVE_MUN ~ value, drop = FALSE) %>% \n                   as.data.frame() %>% \n                    tibble::rownames_to_column(., \"CVE_MUN\") %>%\n                     mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%\n                      relocate(CVE_ENT, .before = \"CVE_MUN\") %>%\n                       group_by(CVE_ENT) %>%\n                        mutate_at(vars(c(-CVE_ENT, -CVE_MUN)), funs(./sum(.)*100))%>%\n                         replace(., is.na(.), 0)\n\nsave(denue_mun, file = paste0(here::here(), \"/Bases/Municipio/Indicadores_DENUE.RData\"))"},{"path":"fuentes-de-información.html","id":"localidad","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\ndenue_loc <- denue_2021 %>%\n              filter(.$codigo_act %in% codigo) %>%\n               select(ELEMENTO, CVE_LOC) %>%\n                melt(., id = c(\"CVE_LOC\"))  %>%\n                 mutate(value = as.character(.$value)) %>%\n                  acast(., CVE_LOC ~ value, drop = FALSE) %>% \n                   as.data.frame() %>% \n                    tibble::rownames_to_column(., \"CVE_LOC\") %>%\n                     mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%\n                      relocate(CVE_MUN, .before = \"CVE_LOC\") %>%\n                       group_by(CVE_MUN) %>%\n                        mutate_at(vars(c(-CVE_MUN, -CVE_LOC)), funs(./sum(.)*100))%>%\n                         replace(., is.na(.), 0)\n\nsave(denue_loc, file = paste0(here::here(), \"/Bases/Localidad/Indicadores_DENUE.RData\"))"},{"path":"fuentes-de-información.html","id":"ageb","chapter":"Fuentes de información","heading":"AGEB","text":"","code":"\ndenue_ageb <- denue_2021 %>%\n               filter(.$codigo_act %in% codigo) %>%\n                select(ELEMENTO, CVE_AGEB) %>%\n                 melt(., id = c(\"CVE_AGEB\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_AGEB ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_AGEB\")  %>%\n                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%\n                       relocate(CVE_LOC, .before = \"CVE_AGEB\") %>%\n                        group_by(CVE_LOC) %>%\n                         mutate_at(vars(c(-CVE_LOC, -CVE_AGEB)), funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(denue_ageb, file = paste0(here::here(), \"/Bases/AGEB/Indicadores_DENUE.RData\"))"},{"path":"fuentes-de-información.html","id":"sep","chapter":"Fuentes de información","heading":"SEP","text":"","code":"\nload(paste0(here::here(), \"/Bases/SEP_Estructura.RData\"))"},{"path":"fuentes-de-información.html","id":"municipio-1","chapter":"Fuentes de información","heading":"Municipio","text":"Se utiliza la base de datos nivel municipio, ya que esta presenta todo el universo de escuelas en el país.","code":"\nsep_mun <- SEP %>%\n            select(CVE_MUN, `Nivel educativo`) %>%\n             reshape2::melt(., id = c(\"CVE_MUN\")) %>%\n              acast(., CVE_MUN ~ value, drop = FALSE) %>%\n               as.data.frame() %>% \n                tibble::rownames_to_column(., \"CVE_MUN\") %>%\n                 mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%\n                  relocate(CVE_ENT, .before = \"CVE_MUN\") %>%\n                   group_by(CVE_ENT) %>%\n                    mutate_at(vars(c(-CVE_MUN, -CVE_ENT)), funs(./sum(.)*100))%>%\n                     replace(., is.na(.), 0)\nsave(sep_mun, file = paste0(here::here(), \"/Bases/Municipio/Indicadores_Escuelas_SEP.RData\"))"},{"path":"fuentes-de-información.html","id":"localidad-1","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\nsep_loc <- SEP %>%\n                select(CVE_LOC, `Nivel educativo`) %>%\n                 reshape2::melt(., id = c(\"CVE_LOC\")) %>%\n                   acast(., CVE_LOC ~ value, drop = FALSE) %>%\n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_LOC\") %>%\n                      mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%\n                        relocate(CVE_MUN, .before = \"CVE_LOC\") %>%\n                         group_by(CVE_MUN) %>%\n                          mutate_at(vars(c(-CVE_LOC, -CVE_MUN)), funs(./sum(.)*100))%>%\n                           replace(., is.na(.), 0)\n\nsave(sep_loc, file = paste0(here::here(), \"/Bases/Localidad/Indicadores_Escuelas_SEP.RData\"))"},{"path":"fuentes-de-información.html","id":"ageb-1","chapter":"Fuentes de información","heading":"AGEB","text":"","code":"\nload(\"Bases/SEP_Estructura_AGEB.RData\")\nsep_ageb <- sep_ageb %>%\n                select(CVE_AGEB, `Nivel educativo`) %>%\n                 reshape2::melt(., id = c(\"CVE_AGEB\")) %>%\n                   acast(., CVE_AGEB ~ value, drop = TRUE) %>% # drop = FALSE\n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_AGEB\") %>%\n                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%\n                        relocate(CVE_LOC, .before = \"CVE_AGEB\") %>%\n                         group_by(CVE_LOC) %>%\n                          mutate_at(vars(c(-CVE_AGEB, -CVE_LOC)), funs(./sum(.)*100))%>%\n                           replace(., is.na(.), 0)\n\nsave(sep_ageb, file = paste0(here::here(), \"/Bases/AGEB/Indicadores_Escuelas_SEP.RData\"))"},{"path":"fuentes-de-información.html","id":"clues","chapter":"Fuentes de información","heading":"CLUES","text":"","code":"\nload(\"Bases/CLUES_Estructura.RData\")"},{"path":"fuentes-de-información.html","id":"municipio-2","chapter":"Fuentes de información","heading":"Municipio","text":"","code":"\nclues_mun <- CLUES %>%\n                select(`Nivel de atención`, CVE_MUN) %>%\n                 melt(., id = c(\"CVE_MUN\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_MUN ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_MUN\") %>%\n                      mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%\n                       relocate(CVE_ENT, .before = \"CVE_MUN\") %>%\n                        group_by(CVE_ENT) %>%\n                         mutate_at(vars(c(-CVE_ENT, -CVE_MUN)),funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(clues_mun, file = paste0(here::here(), \"/Bases/Municipio/Indicadores_CLUES.RData\"))"},{"path":"fuentes-de-información.html","id":"localidad-2","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\nclues_loc <- CLUES %>%\n                select(`Nivel de atención`, CVE_LOC) %>%\n                 melt(., id = c(\"CVE_LOC\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_LOC ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_LOC\") %>%\n                      mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%\n                       relocate(CVE_MUN, .before = \"CVE_LOC\") %>%\n                        group_by(CVE_MUN) %>%\n                         mutate_at(vars(c(-CVE_MUN, -CVE_LOC)),funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(clues_loc, file = paste0(here::here(), \"/Bases/Localidad/Indicadores_CLUES.RData\"))"},{"path":"fuentes-de-información.html","id":"ageb-2","chapter":"Fuentes de información","heading":"AGEB","text":"","code":"\nload(paste0(here::here(), \"/Bases/CLUES_Estructura_AGEB.RData\"))\nclues_ageb <- CLUES_AGEB %>%\n                select(`Nivel de atención`, CVE_AGEB) %>%\n                 melt(., id = c(\"CVE_AGEB\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_AGEB ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_AGEB\") %>%\n                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%\n                       relocate(CVE_LOC, .before = \"CVE_AGEB\") %>%\n                        group_by(CVE_LOC) %>%\n                         mutate_at(vars(c(-CVE_LOC, -CVE_AGEB)),funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(clues_ageb, file = paste0(here::here(), \"/Bases/AGEB/Indicadores_CLUES.RData\"))"},{"path":"fuentes-de-información.html","id":"ial","chapter":"Fuentes de información","heading":"IAL","text":"","code":""},{"path":"fuentes-de-información.html","id":"municipio-3","chapter":"Fuentes de información","heading":"Municipio","text":"","code":"\nload(paste0(here::here(), \"/Bases/Municipio/IA_municipio.Rdata\"))"},{"path":"fuentes-de-información.html","id":"localidad-3","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\nload(paste0(here::here(), \"/Bases/Localidad/IA_localidad.Rdata\"))"},{"path":"fuentes-de-información.html","id":"entorno-urbano","chapter":"Fuentes de información","heading":"Entorno Urbano","text":"Dada la importancia de los proyectos sobre el entorno urbano, destacada por informes como el que presentó ONU-Hábitat sobre el Estado de las ciudades en América Latina y el Caribe 2012 o el de CEPAL-CELADE en el cual se afirma que debe adoptarse como acuerdo de trabajo que los temas de entorno, equipamiento y medio ambiente se incorporen los censos para definir la calidad y adecuación de la vivienda, en particular la urbana.Algortinmo de integración del Entorno UrbanoNo enfocamos en los indicadores númericos.","code":"\ntablas <- c(paste0(\"0\", seq(1, 9, 1)), seq(10, 32, 1))\n\nfor(i in tablas){\n assign(paste0(\"TI_\", i), read_sav(paste0(here::here(), \"/TI_MANZANA/TI_MANZANA_EU_\",i,\".SAV\")))\n}\n\n# Se agrupan todas las tablas en una sola\nlista <- ls(pattern = \"TI_\")\nMANZANA_EU_2020 <- do.call(rbind.data.frame, mget(lista))\n\nMANZANA_EU_2020 <- MANZANA_EU_2020 %>% \n                    select(\"ENT\", \"CVE_MUN\",\"CVE_LOC\",\"CVE_AGEB\",\"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n                     mutate(PAVIM_ADOQ_N = .$PAVIM_N + .$ADOQ_N) %>%\n                      select(\"ENT\", \"CVE_MUN\",\"CVE_LOC\",\"CVE_AGEB\",\"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N,\n                             C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N,\n                             C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)\n\n# Se guarda la base de datos donde se integran 16 bases de datos\nsave(MANZANA_EU_2020, file = paste0(here::here(), \"/Bases/MANZANA_EU_2020.RData\"))\nload(paste0(here::here(), \"/Bases/MANZANA_EU_2020.RData\"))"},{"path":"fuentes-de-información.html","id":"caso-particular","chapter":"Fuentes de información","heading":"Caso particular","text":"Caso particular\nMunicpio de Ocampo / Localidad Melchor Ocampo\nDebido la falta de información de este municipio, se toma como referencia los municipios vecinos.08009 Bocoyna08031 Guerrero08041 Maguarichi08047 Boris08063 Temósachic08066 UruachiFuente: Espacio y datos de México (INEGI)","code":"\nEU_mun <- MANZANA_EU_2020 %>%\n           select(\"ENT\", \"CVE_MUN\", \"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n             filter(CVE_MUN %in% c(\"08009\", \"08031\", \"08041\", \"08047\", \"08063\", \"08066\")) %>%\n              select(-CVE_MUN) %>%\n                group_by(ENT) %>% \n                  summarise(across(where(is.numeric), sum)) %>%\n                   ungroup() %>%\n                    mutate_at(vars(c(-ENT, -PERSONAS,-VIVPARHAB,-TOTLADO)),funs((./TOTLADO)*100))\n\nsave(EU_mun, file = paste0(here::here(), \"/Bases/Municipio/EU_mun.RData\"))"},{"path":"fuentes-de-información.html","id":"nivel-localidad","chapter":"Fuentes de información","heading":"Nivel Localidad","text":"","code":"\nEU_loc <- MANZANA_EU_2020 %>%\n             select(\"CVE_LOC\", \"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n              group_by(CVE_LOC) %>% \n               summarise(across(where(is.numeric), sum)) %>%\n                ungroup() %>%\n                 mutate_at(vars(c(-CVE_LOC, -PERSONAS,-VIVPARHAB,-TOTLADO)), funs((./TOTLADO)*100))\n\nsave(EU_loc, file = paste0(here::here(), \"/Bases/Localidad/EU_loc.RData\"))"},{"path":"fuentes-de-información.html","id":"nivel-ageb","chapter":"Fuentes de información","heading":"Nivel AGEB","text":"","code":"\nEU_ageb <- MANZANA_EU_2020 %>%\n            select(\"CVE_AGEB\", \"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n              group_by(CVE_AGEB) %>% \n               summarise(across(where(is.numeric), sum)) %>%\n                ungroup() %>%\n                 mutate_at(vars(c(-CVE_AGEB, -PERSONAS,-VIVPARHAB,-TOTLADO)), funs((./TOTLADO)*100))\n\nsave(EU_ageb, file = paste0(here::here(), \"/Bases/AGEB/EU_ageb.RData\"))"},{"path":"municipio-4.html","id":"municipio-4","chapter":"Municipio","heading":"Municipio","text":"Se toma como referencia el marco geoestadístico nacional 2020 Nivel\nMunicipal.","code":"\nload(paste0(here::here(), \"/Bases/Municipio/MGN.Rdata\"))"},{"path":"municipio-4.html","id":"marginación","chapter":"Municipio","heading":"Marginación","text":"Se carga la nueva base del índice de marginación 2020.Para el cálculo de los componentes principales depende de las unidades\nde medida empleadas en las variables. Por lo que es importante, antes de\naplicar PCA, estandarizar los indicadores simples para que tengan\nmedia 0 y desviación estándar 1, ya que, de lo contrario, las\nvariables con mayor varianza dominarían al resto, aunque en el caso en\nque las variables estén medidas en las mismas unidades, podemos optar\npor estandarizarlas. La estandarización se lleva cabo restando \ncada observación la media y dividiendo entre la desviación estándar de\nla variable la que pertenece:\\[Z_{}=\\frac{x_{}-\\bar{x}}{\\sigma_{}}\\]Se utiliza la función \\(PCA\\) del parquete FactoMiner, donde se\nespecifica que se estandaricen las vairables con el parámetro\nscale.unit=TRUEAnálisis de componentes principalesSe utilizan todas las variablesEs importante seleccionar que gráficos se pueden incluir en el\nanálisisSe utilizó como criterio los gráficos de sedimentación y la contriución\nde la variables en cada uno de los componentes y la varianza acumuladaPor otro lado se generan dos índices, de los cuales: - Uno se\nestandariza para explicarlos través de descomposición de valores\nsingulares (SVD) de la matriz de datos.\\[\\mathbf X = \\mathbf U \\mathbf S \\mathbf V^\\top\\] - Segundo, desde el\npunto de vista PCA que requiere el cálculo de los valores propios y\nlos vectores propios, haciendo la descomposición propia de\n\\(\\mathbf X \\mathbf X^{T}\\).\\[\\mathbf X \\mathbf V = \\mathbf U \\mathbf S \\mathbf V^\\top \\mathbf V = \\mathbf U \\mathbf S\\]Donde - \\(\\mathbf V\\) son los eigenvectors - \\(\\mathbf U\\) es la matriz\nunitaria - \\(\\mathbf S\\) es la traza de los eigenvaluesLas columnas de \\(\\mathbf {US}\\) son los pesos de las componentes\nprincipalesSe generan los índices de cada uno de los subsistemas Se utilizan\nlos componentes principales que expliquen el máximo de la\ninformaciónSe utilizó como criterio los gráficos de sedimentación y la contriución\nde la variables en cada uno de los componentes y la varianza acumulada.Resumen\nTable 1: Tabla: Resumen de los indicadores de marginación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/Municipio/IMM.Rdata\"))\n\nPCA_IMM <- PCA(IMM[, c(2:ncol(IMM))],\n                scale.unit = TRUE, \n                 ncp = ncol(IMM[, c(2:ncol(IMM))]),\n                  graph = FALSE) \n# Componentes seleccionadas\nncp <- 3\n\n# Índices de las componentes principales seleccionados\nPC_IMM <-  IMM %>%\n              select(CVE_MUN) %>%\n                mutate(PC = as.numeric(scale(as.matrix(IMM[,c(2:10)])) %*% \n                                        as.matrix(PCA_IMM[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                          as.matrix(PCA_IMM[[\"eig\"]][,2][1:ncp]/100))) %>%\n                   as.data.frame()\n\nsave(PC_IMM, file = paste0(here::here(), \"/Output/Municipio/PC_IMM.Rdata\"))"},{"path":"municipio-4.html","id":"equipamiento-1","chapter":"Municipio","heading":"Equipamiento","text":"Claves económicas","code":""},{"path":"municipio-4.html","id":"denue-1","chapter":"Municipio","heading":"DENUE","text":"Se anexan los indicadores simples, de acuerdo la clasificación\neconómica del DENUE (01)Se utiliza la nueva reclasificación de los subsitemas, de los cuales\nfueron obtenidos del DENUESubramosSe toman como referencia 13 subsitemas económicos y 64 elementos\neconómicos que lo integranDimensiones de cálculo\nTable 2: Tabla: Dimensiones de cálculo\nAnálisis de componentes principales\nTable 3: Tabla: Resumen de los indicadores de asistencia social\n","code":"\nload(paste0(here::here(), \"/Bases/Municipio/Indicadores_DENUE.RData\"))\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\ntablas <- names(Subsitemas)\ntablas\n#>  [1] \"Cultura\"                \"Asistencia_social\"      \"Comercio\"              \n#>  [4] \"Comunicaciones\"         \"Transporte\"             \"Deporte_Recreacion\"    \n#>  [7] \"Administracion_publica\" \"Servicios_urbanos\"      \"Servicios_financieros\" \n#> [10] \"Hoteleria_Restaurantes\" \"Talleres\"\nfor(i in 1:11){\nassign(paste0(\"tabla_\",tablas[i]), denue_mun %>%\n                                     ungroup() %>%\n                                      select(CVE_MUN, Subsitemas[[paste(tablas[i])]]) %>%\n                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%\n                                        mutate(suma = as.numeric(.$suma)) %>%\n                                          filter(.$suma != 0) %>%\n                                           select(-suma))\n}\nncp <- c(1, 1, 1, 1, 3, 1 ,1, 1, 1, 1, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))\n\nPCA_Subsistemas <- NULL\nfor(i in 1:11){\n  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0(\"tabla_\", tablas[i]))[, c(2:ncol(get(paste0(\"tabla_\", tablas[i]))))], \n                                              scale.unit = TRUE, \n                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),\n                                                graph = FALSE) \n}\n# Índices de las componentes principales seleccionados\nPC_DENUE <- NULL\nfor(i in 1:11){\n  PC_DENUE[[i]] <- get(paste0(\"tabla_\", tablas[i]))[1] %>%\n                     select(CVE_MUN) %>%\n                       mutate(PC = scale(as.matrix(get(paste0(\"tabla_\", tablas[i]))[,-1])) %*% \n                                    as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"var\"]][[\"coord\"]][,1:ncp[i]]) %*% \n                                      as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"eig\"]][,2][1:ncp[i]]/100)) %>% \n                         as.data.frame()\n}\nsave(PC_DENUE, file = paste0(here::here(), \"/Output/Municipio/PC_DENUE.Rdata\"))"},{"path":"municipio-4.html","id":"valores-extremos","chapter":"Municipio","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\",tablas[i]))[-1], ncomp = ncp[i], scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\n## Se guardan los resultados \nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_denue.rds\"))\n\n## Caso máximo\npcr_pred_max <- NULL\nfor(i in 1:11){\n  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)\n  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), \".comp\"))\n}\n\n## Caso mínimos \npcr_pred_min <- NULL\nfor(i in 1:11){\n  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)\n}\n\npcr_extremos <- matrix(NA, nrow = 11, ncol = 3)\nfor(i in 1:11){\n  pcr_extremos[i, 1] <- paste(tablas[i])\n  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]\n  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]\n}\ncolnames(pcr_extremos) <- c(\"Indicadores\", \"Máximo\", \"Mínimo\")\n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_DENUE.txt\", sep = \",\"))"},{"path":"municipio-4.html","id":"educación","chapter":"Municipio","heading":"Educación","text":"Análisis de componentes principales\nTable 4: Tabla: Resumen de los indicadores de educación utilizando PCA\n","code":"\nload(\"Bases/Municipio/Indicadores_Escuelas_SEP.RData\")\n\nsep_mun <- sep_mun %>%\n             mutate(suma = rowSums(.[3:11])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_SEP <- PCA(sep_mun[, c(3:11)],\n                scale.unit = TRUE, \n                 ncp = ncol(sep_mun[, c(3:11)]),\n                  graph = FALSE)\n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 2\n# Índices de las componentes principales seleccionados\nPC_SEP <-  sep_mun %>%\n              select(CVE_MUN) %>%\n               mutate(PC = as.numeric(scale(as.matrix(sep_mun[, c(3:11)])) %*% \n                              as.matrix(PCA_SEP[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_SEP[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\nsave(PC_SEP,  file = paste0(here::here(), \"/Output/Municipio/PC_SEP.Rdata\"))"},{"path":"municipio-4.html","id":"valores-extremos-1","chapter":"Municipio","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_SEP$PC~., data = sep_mun[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_sep.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_mun[,c(3:11)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_mun[,c(3:11)])\npcr_pred_min <- predict(pcr_model, test)\n\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_SEP.txt\", sep = \",\"))"},{"path":"municipio-4.html","id":"salud","chapter":"Municipio","heading":"Salud","text":"","code":"\nload(paste0(here::here(), \"/Bases/Municipio/Indicadores_CLUES.RData\"))\n\nclues_mun <- clues_mun %>%\n             mutate(suma = rowSums(.[3:6])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_CLUES <- PCA(clues_mun[, c(3:6)],\n                  scale.unit = TRUE, \n                   ncp = ncol(clues_mun[, c(3:6)]),\n                    graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 1\n\n# Índices de las componentes principales seleccionados\nPC_CLUES <-  clues_mun %>%\n              select(CVE_MUN) %>%\n               mutate(PC = as.numeric(scale(as.matrix(clues_mun[, c(3:6)])) %*% \n                                       as.matrix(PCA_CLUES[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_CLUES[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_CLUES,  file = paste0(here::here(), \"/Output/Municipio/PC_CLUES.Rdata\"))"},{"path":"municipio-4.html","id":"caso-extremos","chapter":"Municipio","heading":"Caso extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_CLUES$PC~., data = clues_mun[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_clues.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_mun[,c(3:6)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_mun[,c(3:6)])\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_CLUES.txt\"), sep = \",\")"},{"path":"municipio-4.html","id":"accesibilidad","chapter":"Municipio","heading":"Accesibilidad","text":"Índice de accesibilidad","code":"\nload(paste0(here::here(), \"/Bases/Municipio/IA_municipio.Rdata\"))"},{"path":"municipio-4.html","id":"calidad-del-entorno","chapter":"Municipio","heading":"Calidad del entorno","text":"MGNDENUESe excluyen los subsistemas de Educación y Salud.SEPCLUES** Índice de accesibilidad nivel municipio**Integración del ICEImputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos\nque puede obtener cada subsistema, calculados por el método de\ncomponentes principales. Siendo estos los valores extremos (falta de\nequipamiento), este valor se formuló utilizando Principal Component\nRegresion (PCR) y de esta manera poder obtener el valor predictivo del\nvalor mínimo.","code":"\nload(paste0(here::here(), \"/Bases/Municipio/MGN.RData\"))\nload(paste0(here::here(), \"/Output/Municipio/PC_IMM.Rdata\"))\n\nIMM <- PC_IMM %>%\n        rename(\"IMM\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\nIndicadores <- names(Subsitemas)\n\nload(paste0(here::here(), \"/Output/Municipio/PC_DENUE.Rdata\"))\n\ntabla <- NULL\nfor(i in 1:11){\n  if(i %in% 1){\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_mun %>% select(CVE_MUN), tabla_DENUE, by = c(\"CVE_MUN\"))\n  } else {\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_mun %>% select(CVE_MUN), tabla_DENUE, by = c(\"CVE_MUN\")) %>%\n                 select(.,2)\n  }\n}\n\nDENUE <- do.call(cbind.data.frame, tabla)\ncolnames(DENUE) <- c(\"CVE_MUN\", Indicadores)\nrm(tabla_DENUE)\nload(paste0(here::here(), \"/Output/Municipio/PC_SEP.RData\"))\nSEP <- PC_SEP %>%\n         rename(\"Educacion\" = \"PC\")\nload(paste0(here::here(), \"/Output/Municipio/PC_CLUES.RData\"))\nCLUES <- PC_CLUES %>%\n          rename(\"Salud\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Municipio/IA_municipio.Rdata\"))\nIAL <- accesibilidad_mun %>%\n         select(CVE_MUN, IAL) \nPCR_pred <- read.table(paste0(here::here(), \"/Output/Municipio/PCR_SEP.txt\"), header = TRUE, sep = \",\") %>% \n             rbind(.,read.table(paste0(here::here(), \"/Output/Municipio/PCR_CLUES.txt\"), header = TRUE, sep = \",\")) %>%\n              rbind(., read.table(paste0(here::here(), \"/Output/Municipio/PCR_DENUE.txt\"), header = TRUE, sep = \",\"))\nICE_2020 <- MGN_mun %>%\n             select(CVE_MUN) %>%\n              left_join(., IMM, by = c(\"CVE_MUN\")) %>%\n               left_join(., SEP, by = c(\"CVE_MUN\")) %>%\n                left_join(., CLUES, by = c(\"CVE_MUN\")) %>%\n                 left_join(., DENUE, by = c(\"CVE_MUN\")) %>% \n                  left_join(., IAL, by = c(\"CVE_MUN\")) %>% \n                   mutate_at(vars(2:16), as.numeric) \n\nICE_2020 <- ICE_2020 %>%\n                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),\n                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),\n                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),\n                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),\n                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),\n                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),\n                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),\n                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),\n                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),\n                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),\n                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),\n                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),\n                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)\n                       )"},{"path":"municipio-4.html","id":"método-de-distancias-dp_2","chapter":"Municipio","heading":"Método de Distancias \\(DP_2\\)","text":"José Bernardo Pena Trapero:\nProblemas de la medición del bienestar y conceptos afines (1977)Primeramente se define como es la entrada de los indicadores simples.\nEste tipo de método - Índice de marginación (Negativo) (Marginación baja\n(-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento +\nCLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de\naccesibilidad (Negativo) (Accesibilidad alta (cercanos cero) /\nAccesibilidad baja (Alejados del cero))Base de referenciaNota.- Se toma como base de referencia el valor del mínimo de cada\nindicador simple.\nTable 5: Tabla: Base de referencia nivel municipal\nMétodo de Distancia \\(DP_{2}\\)El modelo converge la cuarta iteración","code":"\nrequire(p2distance)\nICE_2020_data <- ICE_2020 %>%\n                   mutate(IMM = -1*.$IMM,\n                          IAL = -1*.$IAL)\nrequire(p2distance)\nminRV <- p2distance::makeReferenceVector(X = ICE_2020_data[-1], \n                                          reference_vector_function = 'min')\n##Calculo del Método de Distancias DP2\nind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), \n                       reference_vector = minRV, \n                        iterations = 50)\n#> [1] \"Iteration 1\"\n#> [1] \"Iteration 2\"\n#> [1] \"Iteration 3\"\nind_ice$iteration\n#> [1] 3\nICE_2020 <- cbind(ICE_2020, ind_ice[[\"p2distance\"]])\n\n# Se cambian los nombres de las columnas \nnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"ICE\")\n# Se identifican los outliers en el índice de calidad del entorno\n#boxplot.stats(DP2_2010$IM_2010)$out\noutliers <- boxplot.stats(ICE_2020$ICE)\n\n## Se crea un índice ficticio quitando los outliers   \nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],\n                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],\n                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) "},{"path":"municipio-4.html","id":"método-de-estratificación","chapter":"Municipio","heading":"Método de estratificación","text":"strata.cumrootf: cumulative root frequency method Dalenius \nHodges (1959)Nclass óptimo del método de Dalenius & Hodgealloc lista que especifica el esquema de asignación. La lista debe\ncontener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de\nasignación general (ver paquete de stratification). El valor\npredeterminado es la asignación de Neyman (q1 = q3 = 0.5 y q2 = 0)","code":"\nstart.time <- Sys.time()\n# Se define el coeficiente de variación a usar\ncoef.var <- 0.05\n\nDH_Municipio <- list()\ni <- 1\n  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)\n  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)\n  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)\n for (n in seq(5, 1000, 1)){\n   DH_Municipio[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)\n   cum <- DH_Municipio[[n]]\n   sd[i,] <-  c(n, cum$stderr, cum$CV)\n   meanh[i,] <- c(n, cum$meanh)\n   varh[i,] <-  c(n, cum$varh)\n   i <- i + 1\n}\n\ncolnames(sd) <- c(\"n\", \"sderr\", \"CV\")\ncolnames(meanh) <- c(\"nclass\", paste0(rep(\"Strata\", 5), 1:5))\ncolnames(varh) <- c(\"nclass\", paste0(rep(\"Strata\", 5), 1:5))\n\nend.time <- Sys.time()\ntime.taken <- round(end.time - start.time, 2)\ntime.taken\n\n#Se guardan los resultados de las iteraciones\nsave(sd, file = paste0(here::here(), \"/Output/Municipio/sd.Rdata\"))\nmin.strata <- sd %>%\n               as.data.frame() %>% \n                slice(which.min(.$CV))\nstrata.ice <- strata.cumrootf(ICE_2020$ICE_out,\n                               CV = 0.05,  ## Revisar que tenga el mismo CV\n                                Ls = 5,\n                                 alloc = c(0.5,0,0.5), \n                                  nclass = min.strata$n)\n\n## Se agrega a la base de datos\nICE_2020 <- ICE_2020 %>%\n              select(-ICE_out) %>%   # Se quita el índice ficticio\n                mutate(G.ICE = strata.ice[[\"stratumID\"]])\n\n\n# Se cambian los nombres de las columnas \ncolnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"G.ICE\")\n\n# Se cambian los levels de D&H\nlevels(ICE_2020$G.ICE) = c(\"Completa\", \"Grave\", \"Moderada\", \"Ligera\", \"No hay\")"},{"path":"municipio-4.html","id":"índice-normalizado","chapter":"Municipio","heading":"Índice normalizado","text":"Indice normalizadoEscenarios del mínimo y máximo valor en el índice DP2Se guarda la bases de Datos del ICE por municipio","code":"\n# Desviación estandar de los indicadores\ndesvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%\n                       as.data.frame() %>%\n                        rename(\"desvest\" =\"V1\") %>%\n                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%\n                            mutate(desvest.inversa = 1/(.$sd_muestral))\n\n# Escenario mínimo\nvector_minimo <- as.matrix(minRV)\n\ntabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]\nminimo <- data.frame(Escenario = \"Mínimo\", tabla, DP2 = sum(tabla))\n\n# Escenario mínimo  \nvector_maximo <- p2distance::makeReferenceVector(ICE_2020_data[-1], reference_vector_function = 'max')\n\ntabla <- abs(vector_maximo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])] \n\nmaximo <- data.frame(Escenario = \"Máximo\", tabla, DP2 = sum(tabla))\n\n# Indice normalizado\nmin_DP2 <- minimo$DP2[1]\nmax_DP2 <- maximo$DP2[1]\n\nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2))\n\n# Se guarda el índice de calidad del entorno normalizado\nsave(ICE_2020, file = paste0(here::here(), \"/Bases/Municipio/ICE_2020.RData\"))"},{"path":"localidad-4.html","id":"localidad-4","chapter":"Localidad","heading":"Localidad","text":"Se toma como referencia el marco geoestadístico nacional 2020 nivel localidad","code":"\nload(paste0(here::here(), \"/Bases/Localidad/MGN.Rdata\"))"},{"path":"localidad-4.html","id":"marginación-1","chapter":"Localidad","heading":"Marginación","text":"Se vuelve reestructurar la base de datos nivel localidad 2020, donde los principales cambios que se hacen:\n- Se agregan esas localidades con el margen de error mayores al 90%.\n- En la base publicada del índice de marginación nivel localidad. Se excluyeron aquellas localidades que presentaban algún cálculo en uno de los indicadores. Pero en este caso se incluyen todas las localidades, para que puedan coincidir con los datos oficiales del INEGI para el Censo de Población y Vivienda 2020.Al final del cálculo se van desplegar las localidades menores 2 viviendas particulares, en las cuales están agrupadas nivel municipal. Finalmente puedan ser usadas en el ICE.Bases de datosSe carga la nueva base del índice de marginación 2020.Para el cálculo de los componentes principales depende de las unidades\nde medida empleadas en las variables. Por lo que es importante, antes de\naplicar PCA, estandarizar los indicadores simples para que tengan\nmedia 0 y desviación estándar 1, ya que, de lo contrario, las\nvariables con mayor varianza dominarían al resto, aunque en el caso en\nque las variables estén medidas en las mismas unidades, podemos optar\npor estandarizarlas. La estandarización se lleva cabo restando \ncada observación la media y dividiendo entre la desviación estándar de\nla variable la que pertenece:\\[Z_{}=\\frac{x_{}-\\bar{x}}{\\sigma_{}}\\]Se utiliza la función \\(PCA\\) del parquete FactoMiner, donde se\nespecifica que se estandaricen las vairables con el parámetro\nscale.unit=TRUEAnálisis de componentes principalesSe utilizan todas las variablesEs importante seleccionar que gráficos se pueden incluir en el análisisSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumuladaPor otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos través de descomposición de valores singulares (SVD) de la matriz de datos.\\[\\mathbf X = \\mathbf U \\mathbf S \\mathbf V^\\top\\] - Segundo, desde el punto de vista PCA que requiere el cálculo de los valores propios y\nlos vectores propios, haciendo la descomposición propia de \\(\\mathbf X \\mathbf X^{T}\\).\\[\\mathbf X \\mathbf V = \\mathbf U \\mathbf S \\mathbf V^\\top \\mathbf V = \\mathbf U \\mathbf S\\]Donde - \\(\\mathbf V\\) son los eigenvectors - \\(\\mathbf U\\) es la matriz unitaria - \\(\\mathbf S\\) es la traza de los eigenvaluesLas columnas de \\(\\mathbf {US}\\) son los pesos de las componentes principalesSe generan los índices de cada uno de los subsistemas Se utilizan\nlos componentes principales que expliquen el máximo de la informaciónSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.Resumen\nTable 6: Tabla: Resumen de los indicadores de marginación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/Localidad/IML.Rdata\"))\n\nPCA_IML <- PCA(IML[, c(2:ncol(IML))],\n                 scale.unit = TRUE, \n                  ncp = ncol(IML[, c(2:ncol(IML))]),\n                   graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 4\n\n# Índices de las componentes principales seleccionados\nPC_IML <-  IML %>%\n             select(CVE_LOC) %>%\n               mutate(PC = as.numeric(scale(as.matrix(IML[,c(2:ncol(IML))])) %*% \n                                       as.matrix(PCA_IML[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_IML[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\nsave(PC_IML, file = paste0(here::here(), \"/Output/Localidad/PC_IML.Rdata\"))"},{"path":"localidad-4.html","id":"equipamiento-2","chapter":"Localidad","heading":"Equipamiento","text":"Claves económicas","code":""},{"path":"localidad-4.html","id":"denue-2","chapter":"Localidad","heading":"DENUE","text":"Se anexan los indicadores simples, de acuerdo la clasificación económica del DENUE (01)Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUESubramosSe toman como referencia 13 subsitemas económicos y 64 elementos\neconómicos que lo integranIntegrarlo en una base de datos para saturar la página webDimensiones de cálculo\nTable 7: Tabla: Dimensiones de cálculo\nAnálisis de componentes principales\nTable 8: Tabla: Resumen de los indicadores de asistencia social\n","code":"\nload(paste0(here::here(), \"/Bases/Localidad/Indicadores_DENUE.RData\"))\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\ntablas <- names(Subsitemas)\n\nfor(i in 1:11){\nassign(paste0(\"tabla_\",tablas[i]), denue_loc %>%\n                                     ungroup() %>%\n                                      select(CVE_LOC, Subsitemas[[paste(tablas[i])]]) %>%\n                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%\n                                        mutate(suma = as.numeric(.$suma)) %>%\n                                          filter(.$suma != 0) %>%\n                                           select(-suma))\n}\nncp <- c(2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))\n\nPCA_Subsistemas <- NULL\nfor(i in 1:11){\n  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0(\"tabla_\", tablas[i]))[, c(2:ncol(get(paste0(\"tabla_\", tablas[i]))))], \n                                              scale.unit = TRUE, \n                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),\n                                                graph = FALSE) \n}\n# Índices de las componentes principales seleccionados\nPC_DENUE <- NULL\nfor(i in 1:11){\n  PC_DENUE[[i]] <- get(paste0(\"tabla_\", tablas[i]))[1] %>%\n                     select(CVE_LOC) %>%\n                       mutate(PC = scale(as.matrix(get(paste0(\"tabla_\", tablas[i]))[,-1])) %*% \n                                    as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"var\"]][[\"coord\"]][,1:ncp[i]]) %*% \n                                      as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"eig\"]][,2][1:ncp[i]]/100)) %>% \n                         as.data.frame()\n}\nsave(PC_DENUE, file = paste0(here::here(), \"/Output/Localidad/PC_DENUE.Rdata\"))"},{"path":"localidad-4.html","id":"valores-extremos-2","chapter":"Localidad","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\n## Se guardan los resultados \nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_denue.rds\"))\n\n## Caso máximo\npcr_pred_max <- NULL\nfor(i in 1:11){\n  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)\n  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), \".comp\"))\n}\n\n## Caso mínimos \npcr_pred_min <- NULL\nfor(i in 1:11){\n  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)\n}\n\n\npcr_extremos <- matrix(NA, nrow = 11, ncol = 3)\nfor(i in 1:11){\n  pcr_extremos[i, 1] <- paste(tablas[i])\n  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]\n  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]\n}\ncolnames(pcr_extremos) <- c(\"Indicadores\", \"Máximo\", \"Mínimo\")\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_DENUE.txt\"), sep = \",\")"},{"path":"localidad-4.html","id":"educación-1","chapter":"Localidad","heading":"Educación","text":"Análisis de componentes principales\nTable 9: Tabla: Resumen de los indicadores de educación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/Localidad/Indicadores_Escuelas_SEP.RData\"))\n\nsep_loc <- sep_loc %>%\n             mutate(suma = rowSums(.[3:11])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_SEP <- PCA(sep_loc[, c(3:11)],\n                scale.unit = TRUE, \n                 ncp = ncol(sep_loc[, c(3:11)]),\n                  graph = FALSE)\n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 4\n\n# Índices de las componentes principales seleccionados\nPC_SEP <-  sep_loc %>%\n              select(CVE_LOC) %>%\n               mutate(PC = as.numeric(scale(as.matrix(sep_loc[, c(3:11)])) %*% \n                              as.matrix(PCA_SEP[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_SEP[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_SEP,  file = paste0(here::here(), \"/Output/Localidad/PC_SEP.Rdata\"))"},{"path":"localidad-4.html","id":"valores-extremos-3","chapter":"Localidad","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_SEP$PC~., data = sep_loc[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_sep.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_loc[,c(3:11)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_loc[,c(3:11)])\npcr_pred_min <- predict(pcr_model, test)\n\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_SEP.txt\"), sep = \",\")"},{"path":"localidad-4.html","id":"salud-1","chapter":"Localidad","heading":"Salud","text":"\nTable 10: Tabla: Resumen de los indicadores de salud utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/Localidad/Indicadores_CLUES.RData\"))\n\nclues_loc <- clues_loc %>%\n               mutate(suma = rowSums(.[3:6])) %>%\n                 mutate(suma = as.numeric(.$suma)) %>%\n                  filter(.$suma != 0) %>%\n                    select(-suma)\nPCA_CLUES <- PCA(clues_loc[, c(3:6)],\n                  scale.unit = TRUE, \n                   ncp = ncol(clues_loc[, c(3:6)]),\n                    graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 2\n\n# Índices de las componentes principales seleccionados\nPC_CLUES <-  clues_loc %>%\n              select(CVE_LOC) %>%\n               mutate(PC = as.numeric(scale(as.matrix(clues_loc[, c(3:6)])) %*% \n                                       as.matrix(PCA_CLUES[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_CLUES[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_CLUES,  file = paste0(here::here(), \"/Output/Localidad/PC_CLUES.Rdata\"))"},{"path":"localidad-4.html","id":"caso-extremos-1","chapter":"Localidad","heading":"Caso extremos","text":"Índice de accesibilidad","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_CLUES$PC~., data = clues_loc[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_clues.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_loc[, c(3:6)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_loc[, c(3:6)])\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Salud\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_CLUES.txt\"), sep = \",\")\nload(paste0(here::here(), \"/Bases/Localidad/IA_localidad.Rdata\"))"},{"path":"localidad-4.html","id":"calidad-del-entorno-1","chapter":"Localidad","heading":"Calidad del entorno","text":"MGNMarginaciónLocalidades confidencialesPara la obtención de las localidades confidenciales se requirio agruparlas nivel municipal, lo que permitio poder contemplar el 100 por ciento de las localidades reconocidas en el marco geoestadístico.Se analizan 81 105 localidades confidencialesDENUESe excluyen los subsistemas de Educación y Salud.*SEPCLUESAccesibilidadIntegración del ICEImputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos\nque puede obtener cada subsistema, calculados por el método de\ncomponentes principales. Siendo estos los valores extremos (falta de\nequipamiento), este valor se formuló utilizando Principal Component\nRegresion (PCR) y de esta manera poder obtener el valor predictivo del\nvalor mínimo.Es importante determinar que sucede con las localidades que tienen cálculoJosé Bernardo Pena Trapero: Problemas de la medición del bienestar y conceptos afines (1977)Primeramente se define como es la entrada de los indicadores simples. Este tipo de método\n- Índice de marginación (Negativo) (Marginación baja (-Negativa) / Marginación alta (Positiva))\n- Índice de equipamiento\n+ CLUES (Postivo)\n+ SEP (Postivo)\n+ DENUE (Positivo)\n- Indice de accesibilidad (Negativo)Base de referenciaNota.- Se toma como base de referencia el valor del mínimo de cada\nindicador simple.\nTable 11: Tabla: Base de referencia nivel localidad\nMétodo de Distancia \\(DP_{2}\\)El modelo converge la cuarta iteración","code":"\nload(paste0(here::here(), \"/Bases/Localidad/MGN.RData\")) \nload(paste0(here::here(), \"/Output/Localidad/PC_IML.Rdata\"))\nload(file = paste0(here::here(), \"/Bases/Localidad/Loc_Confidenciales_Claves.Rdata\"))\n\nIML <- PC_IML %>%\n           filter(substr(.$CVE_LOC,6,9) != '9999') %>%\n            rbind(., Loc_Confidenciales %>% select(CVE_LOC, PC)) \n\nIML <- IML %>%\n           rename(\"IML\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\nIndicadores <- names(Subsitemas)\n\nload(paste0(here::here(), \"/Output/Localidad/PC_DENUE.Rdata\"))\n\ntabla <- NULL\nfor(i in 1:11){\n  if(i %in% 1){\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_loc %>% select(CVE_LOC), tabla_DENUE, by = c(\"CVE_LOC\"))\n  } else {\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_loc %>% select(CVE_LOC), tabla_DENUE, by = c(\"CVE_LOC\")) %>%\n                 select(.,2)\n  }\n}\n\nDENUE <- do.call(cbind.data.frame, tabla)\ncolnames(DENUE) <- c(\"CVE_LOC\", Indicadores)\nrm(tabla_DENUE)\nload(paste0(here::here(), \"/Output/Localidad/PC_SEP.RData\"))\n\nSEP <- PC_SEP %>%\n         rename(\"Educacion\" = \"PC\")\nload(paste0(here::here(), \"/Output/Localidad/PC_CLUES.RData\"))\n\nCLUES <- PC_CLUES %>%\n          rename(\"Salud\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Localidad/IA_localidad.Rdata\")) \n\nIAL <- accesibilidad_loc %>%\n         select(CVE_LOC, IAL) \nPCR_pred <- read.table(paste0(here::here(), \"/Output/Localidad/PCR_SEP.txt\"), header = TRUE, sep = \",\") %>% \n             rbind(.,read.table(paste0(here::here(), \"/Output/Localidad/PCR_CLUES.txt\"), header = TRUE, sep = \",\")) %>%\n              rbind(., read.table(paste0(here::here(), \"/Output/Localidad/PCR_DENUE.txt\"), header = TRUE, sep = \",\"))\nICE_2020 <- MGN_loc %>%\n             select(CVE_LOC, Indicadora) %>%\n              left_join(., IML, by = c(\"CVE_LOC\")) %>%\n               left_join(., SEP, by = c(\"CVE_LOC\")) %>%\n                left_join(., CLUES, by = c(\"CVE_LOC\")) %>%\n                 left_join(., DENUE, by = c(\"CVE_LOC\")) %>% \n                  left_join(., IAL, by = c(\"CVE_LOC\")) %>% \n                   mutate_at(vars(3:17), as.numeric)\n\nICE_2020 <- ICE_2020 %>%\n                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),\n                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),\n                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),\n                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),\n                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),\n                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),\n                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),\n                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),\n                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),\n                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),\n                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),\n                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),\n                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,\n                  mutate(IAL = ifelse(is.na(.$IAL) == TRUE, 810, .$IAL)) %>%\n                   mutate(Indicadora = case_when(nchar(.$Indicadora)>0 ~ .$Indicadora,\n                                                 is.na(.$IAL) ~ \"Sin localización en la red\",\n                                                 is.na(.$IML) ~ \"Sin cálculo de marginación\"))\ntable(ICE_2020$Indicadora)\n#> \n#>                              Localidad confindencial \n#>                                                81097 \n#> Localidad confindencial | Sin cálculo de marginación \n#>                                                    8 \n#>                           Sin cálculo de marginación \n#>                                                   32 \n#>                 Sin viviendas particulares habitadas \n#>                                                  148 \n#>      Tiene cálculo | Margén de error alto en IM_2020 \n#>                                                    3\nICE_2020 <- ICE_2020 %>%\n             filter(nchar(.$IML)> 0) %>%\n              select(., c(1, 3:17)) \nICE_2020_data <- ICE_2020 %>%\n                   mutate(IML = -1*.$IML,\n                          IAL = -1*.$IAL)\nminRV <- makeReferenceVector(X = ICE_2020_data[-1], \n                             reference_vector_function = 'min')\n#require(p2distance)\n##Calculo del Método de Distancias DP2\nind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), \n                       reference_vector = minRV, \n                        iterations = 50)\n#> [1] \"Iteration 1\"\n#> [1] \"Iteration 2\"\n#> [1] \"Iteration 3\"\nind_ice$iteration\n#> [1] 3\nICE_2020 <- cbind(ICE_2020, ind_ice[[\"p2distance\"]])\n\n# Se cambian los nombres de las columnas \nnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"ICE\")\n# Se identifican los outliers en el índice de calidad del entorno\n#boxplot.stats(DP2_2010$IM_2010)$out\noutliers <- boxplot.stats(ICE_2020$ICE)\n\n## Se crea un índice ficticio quitando los outliers   \nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],\n                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],\n                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) "},{"path":"localidad-4.html","id":"método-de-estratificación-1","chapter":"Localidad","heading":"Método de estratificación","text":"strata.cumrootf: cumulative root frequency method Dalenius \nHodges (1959)Nclass óptimo del método de Dalenius & Hodgealloc lista que especifica el esquema de asignación. La lista debe\ncontener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de\nasignación general (ver paquete de stratification). El valor\npredeterminado es la asignación de Neyman (q1 = q3 = 0.5 y q2 = 0)","code":"\nstart.time <- Sys.time()\n# Se define el coeficiente de variación a usar\ncoef.var <- 0.05\n\nDH_Localidad <- list()\ni <- 1\n  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)\n  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)\n  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)\n for (n in seq(5, 1000, 1)){\n   DH_Localidad[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)\n   cum <- DH_Localidad[[n]]\n   sd[i,] <-  c(n, cum$stderr, cum$CV)\n   meanh[i,] <- c(n, cum$meanh)\n   varh[i,] <-  c(n, cum$varh)\n   i <- i + 1\n}\n\ncolnames(sd) <- c(\"n\",\"sderr\",\"CV\")\ncolnames(meanh) <- c(\"nclass\", paste0(rep(\"Strata\",5),1:5))\ncolnames(varh) <- c(\"nclass\",paste0(rep(\"Strata\",5),1:5))\n\nend.time <- Sys.time()\ntime.taken <- round(end.time - start.time, 2)\ntime.taken\n\n#Se guardan los resultados de las iteraciones\nsave(sd, file = paste0(here::here(), \"/Output/Localidad/sd.Rdata\"))\nmin.strata <- sd %>%\n               as.data.frame() %>% \n                slice(which.min(.$CV))\nstrata.ice <- strata.cumrootf(ICE_2020$ICE_out,\n                               CV = 0.05, \n                                Ls = 5,\n                                 alloc = c(0.5,0,0.5), \n                                  nclass = min.strata$n)\n\n## Se agrega a la base de datos\nICE_2020 <- ICE_2020 %>%\n              select(-ICE_out) %>%   # Se quita el índice ficticio\n                mutate(G.ICE = strata.ice[[\"stratumID\"]])\n\n\n# Se cambian los nombres de las columnas \ncolnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"G.ICE\")\n\n# Se cambian los levels de D&H\nlevels(ICE_2020$G.ICE) = c(\"Completa\", \"Grave\", \"Moderada\", \"Ligera\", \"No hay\")"},{"path":"localidad-4.html","id":"índice-normalizado-1","chapter":"Localidad","heading":"Índice normalizado","text":"Indice normalizadoEscenarios del mínimo y máximo valor en el índice DP2Se guarda la bases de Datos del ICE por municipio","code":"\n# Desviación estandar de los indicadores\ndesvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%\n                       as.data.frame() %>%\n                        rename(\"desvest\" =\"V1\") %>%\n                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%\n                            mutate(desvest.inversa = 1/(.$sd_muestral))\n\n# Escenario mínimo\nvector_minimo <- as.matrix(minRV)\n\ntabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]\nminimo <- data.frame(Escenario = \"Mínimo\", tabla, DP2 = sum(tabla))\n\n# Escenario mínimo  \nvector_maximo <- p2distance::makeReferenceVector(ICE_2020_data[-1], reference_vector_function = 'max')\n\ntabla <- abs(vector_maximo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])] \n\nmaximo <- data.frame(Escenario = \"Máximo\", tabla, DP2 = sum(tabla))\n\n# Indice normalizado\nmin_DP2 <- minimo$DP2[1]\nmax_DP2 <- maximo$DP2[1]\n\nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%\n               arrange(ICE_Norm)\n\n# Se guarda el índice de calidad del entorno normalizado\nsave(ICE_2020, file = paste0(here::here(), \"/Bases/Localidad/ICE_2020.RData\"))"},{"path":"ageb-3.html","id":"ageb-3","chapter":"AGEB","heading":"AGEB","text":"Se toma como referencia el marco geoestadístico nacional 2020 nivel localidad","code":"\nload(paste0(here::here(), \"/Bases/AGEB/MGN_ageb.Rdata\"))"},{"path":"ageb-3.html","id":"marginación-2","chapter":"AGEB","heading":"Marginación","text":"Se vuelve reestructurar la base de datos nivel AGEB 2020, donde los principales cambios que se hacen:\n- Se agregan esas AGEB con el margen de error mayores al 90%.\n- En la base publicada del índice de marginación nivel AGEB, Se excluyeron aquellas AGEB que presentaban algún cálculo en uno de los indicadores.\n- También se quita el filtro de 20 viviendas totales y se contempla el total de viviendas.Bases de datosSe carga la nueva base del índice de marginación 2020.Para el cálculo de los componentes principales depende de las unidades\nde medida empleadas en las variables. Por lo que es importante, antes de\naplicar PCA, estandarizar los indicadores simples para que tengan\nmedia 0 y desviación estándar 1, ya que, de lo contrario, las\nvariables con mayor varianza dominarían al resto, aunque en el caso en\nque las variables estén medidas en las mismas unidades, podemos optar\npor estandarizarlas. La estandarización se lleva cabo restando \ncada observación la media y dividiendo entre la desviación estándar de\nla variable la que pertenece:\\[Z_{}=\\frac{x_{}-\\bar{x}}{\\sigma_{}}\\]Se utiliza la función \\(PCA\\) del parquete FactoMiner, donde se\nespecifica que se estandaricen las vairables con el parámetro\nscale.unit=TRUEAnálisis de componentes principalesSe utilizan todas las variablesEs importante seleccionar que gráficos se pueden incluir en el análisisSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumuladaPor otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos través de descomposición de valores singulares (SVD) de la matriz de datos.\\[\\mathbf X = \\mathbf U \\mathbf S \\mathbf V^\\top\\] - Segundo, desde el punto de vista PCA que requiere el cálculo de los valores propios y\nlos vectores propios, haciendo la descomposición propia de \\(\\mathbf X \\mathbf X^{T}\\).\\[\\mathbf X \\mathbf V = \\mathbf U \\mathbf S \\mathbf V^\\top \\mathbf V = \\mathbf U \\mathbf S\\]Donde - \\(\\mathbf V\\) son los eigenvectors - \\(\\mathbf U\\) es la matriz unitaria - \\(\\mathbf S\\) es la traza de los eigenvaluesLas columnas de \\(\\mathbf {US}\\) son los pesos de las componentes principalesSe generan los índices de cada uno de los subsistemas Se utilizan\nlos componentes principales que expliquen el máximo de la informaciónSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.Resumen\nTable 12: Tabla: Resumen de los indicadores de marginación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/IMU.Rdata\"))\n\nPCA_IMU <- PCA(IMU[, c(2:ncol(IMU))],\n                 scale.unit = TRUE, \n                  ncp = ncol(IMU[, c(2:ncol(IMU))]),\n                   graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 6\n\n# Índices de las componentes principales seleccionados\nPC_IMU <-  IMU %>%\n              select(CVE_AGEB) %>%\n               mutate(PC = as.numeric(scale(as.matrix(IMU[,c(2:ncol(IMU))])) %*% \n                                       as.matrix(PCA_IMU[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_IMU[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\nsave(PC_IMU, file = paste0(here::here(), \"/Output/AGEB/PC_IMU.Rdata\"))"},{"path":"ageb-3.html","id":"equipamiento-3","chapter":"AGEB","heading":"Equipamiento","text":"Claves económicas","code":""},{"path":"ageb-3.html","id":"denue-3","chapter":"AGEB","heading":"DENUE","text":"Se anexan los indicadores simples, de acuerdo la clasificación económica del DENUE (01)Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUESubramosSe dividen los indicadores simples de acuerdo los 13 subsitemas económicosDimensiones de cálculo\nTable 13: Tabla: Dimensiones de cálculo\nAnálisis de componentes principales\nTable 14: Tabla: Resumen de los indicadores de asistencia social\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/Indicadores_DENUE.RData\"))\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\ntablas <- names(Subsitemas)\n\nfor(i in 1:11){\nassign(paste0(\"tabla_\",tablas[i]), denue_ageb %>%\n                                     ungroup() %>%\n                                      select(CVE_AGEB, Subsitemas[[paste(tablas[i])]]) %>%\n                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%\n                                        mutate(suma = as.numeric(.$suma)) %>%\n                                          filter(.$suma != 0) %>%\n                                           select(-suma))\n}\nncp <- c(2, 4, 2, 4, 4, 5, 2, 3, 5, 4, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))\n\nPCA_Subsistemas <- NULL\nfor(i in 1:11){\n  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0(\"tabla_\", tablas[i]))[, c(2:ncol(get(paste0(\"tabla_\", tablas[i]))))], \n                                              scale.unit = TRUE, \n                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),\n                                                graph = FALSE) \n}\n# Índices de las componentes principales seleccionados\nPC_DENUE <- NULL\nfor(i in 1:11){\n  PC_DENUE[[i]] <- get(paste0(\"tabla_\", tablas[i]))[1] %>%\n                     select(CVE_AGEB) %>%\n                       mutate(PC = as.numeric(scale(as.matrix(get(paste0(\"tabla_\", tablas[i]))[,-1])) %*% \n                                               as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"var\"]][[\"coord\"]][,1:ncp[i]]) %*% \n                                                as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"eig\"]][,2][1:ncp[i]]/100))) %>%\n                        as.data.frame()\n}   \n\nsave(PC_DENUE, file = paste0(here::here(), \"/Output/AGEB/PC_DENUE.Rdata\"))"},{"path":"ageb-3.html","id":"valores-extremos-4","chapter":"AGEB","heading":"Valores extremos","text":"","code":"\nrequire(pls)\n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/AGEB/pcr_model_denue.rds\"))\n## Caso máximo\npcr_pred_max <- NULL\nfor(i in 1:11){\n  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)\n  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), \".comp\"))\n}\n\n## Caso mínimos \npcr_pred_min <- NULL\nfor(i in 1:11){\n  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)\n}\n\n\npcr_extremos <- matrix(NA, nrow = 11, ncol = 3)\nfor(i in 1:11){\n  pcr_extremos[i, 1] <- paste(tablas[i])\n  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]\n  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]\n}\ncolnames(pcr_extremos) <- c(\"Indicadores\", \"Máximo\", \"Mínimo\")\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_DENUE.txt\"), sep = \",\")"},{"path":"ageb-3.html","id":"educación-2","chapter":"AGEB","heading":"Educación","text":"Análisis de componentes principales\nTable 15: Tabla: Resumen de los indicadores de educación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/Indicadores_Escuelas_SEP.RData\"))\n\nsep_ageb <- sep_ageb %>%\n             mutate(suma = rowSums(.[3:11])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_SEP <- PCA(sep_ageb[, c(3:11)],\n                scale.unit = TRUE, \n                 ncp = ncol(sep_ageb[, c(3:11)]),\n                  graph = FALSE)\n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 5\n\n# Índices de las componentes principales seleccionados\nPC_SEP <-  sep_ageb %>%\n              select(CVE_AGEB)  %>%\n               mutate(PC = as.numeric(scale(as.matrix(sep_ageb[, c(3:11)])) %*% \n                              as.matrix(PCA_SEP[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_SEP[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_SEP,  file = paste0(here::here(), \"/Output/AGEB/PC_SEP.Rdata\"))"},{"path":"ageb-3.html","id":"valores-extremos-5","chapter":"AGEB","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_SEP$PC~., data = sep_ageb[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/AGEB/pcr_model_sep.rds\"))\n## Caso máximo\ntest <- t(rep(100, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_ageb[,c(3:11)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_ageb[,c(3:11)])\npcr_pred_min <- predict(pcr_model, test)\n\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_SEP.txt\"), sep = \",\")"},{"path":"ageb-3.html","id":"salud-2","chapter":"AGEB","heading":"Salud","text":"\nTable 16: Tabla: Resumen de los indicadores de salud utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/Indicadores_CLUES.RData\"))\n\nclues_ageb <- clues_ageb %>%\n               mutate(suma = rowSums(.[3:6])) %>%\n                 mutate(suma = as.numeric(.$suma)) %>%\n                  filter(.$suma != 0) %>%\n                    select(-suma)\nPCA_CLUES <- PCA(clues_ageb[, c(3:6)],\n                  scale.unit = TRUE, \n                   ncp = ncol(clues_ageb[, c(3:6)]),\n                    graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 3\n\n# Índices de las componentes principales seleccionados\nPC_CLUES <-  clues_ageb %>%\n              select(CVE_AGEB) %>%\n               mutate(PC = as.numeric(scale(as.matrix(clues_ageb[, c(3:6)])) %*% \n                                       as.matrix(PCA_CLUES[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_CLUES[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_CLUES,  file = paste0(here::here(), \"/Output/AGEB/PC_CLUES.Rdata\"))"},{"path":"ageb-3.html","id":"caso-extremos-2","chapter":"AGEB","heading":"Caso extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_CLUES$PC~., data = clues_ageb[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/AGEB/pcr_model_clues.rds\"))\n## Caso máximo\ntest <- t(rep(100, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_ageb[, c(3:6)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_ageb[, c(3:6)])\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Salud\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_CLUES.txt\"), sep = \",\")"},{"path":"ageb-3.html","id":"entorno-urbano-1","chapter":"AGEB","heading":"Entorno urbano","text":"Son 2852 casos que cuentan con alguna viviendas particulares habitadasSon 2760 casos que cuentan con población.Son 2852 casos que cuentan con alguna viviendas particulares habitadasSon 2760 casos que cuentan con población.Análisis de componentes principales\nTable 17: Tabla: Resumen de los indicadores de salud utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/EU_ageb.RData\"))\n\nEU_ageb <- EU_ageb %>%\n            select(CVE_AGEB, PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N, C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N, C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)\nPCA_EU <- PCA(EU_ageb[, c(2:ncol(EU_ageb))],\n               scale.unit = TRUE, \n                  ncp = ncol(EU_ageb[,c(2:ncol(EU_ageb))]),\n                   graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 7\n\n# Índices de las componentes principales seleccionados\nPC_EU <-  EU_ageb %>%\n              select(CVE_AGEB) %>%\n               mutate(PC = as.numeric(scale(as.matrix(EU_ageb[, c(2:ncol(EU_ageb))])) %*% \n                                       as.matrix(PCA_EU[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_EU[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\nsave(PC_EU,  file = paste0(here::here(), \"/Output/AGEB/PC_EU.Rdata\"))"},{"path":"ageb-3.html","id":"caso-extremos-3","chapter":"AGEB","heading":"Caso extremos","text":"Son 387 AGEB Urbanas que contienen cálculo de entorono urbano.\nSe anexan los indicadores sin cálculo de entorno urbano, el cual se les imputaron los valores nivel localidad y tres de ellos nivel municipal.Modelo predictivo\nSe une los datos imputados y los datos de entorno urbano por AGEB Urbana","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_EU$PC~., data = EU_ageb[, c(2:ncol(EU_ageb))], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"CV\", segments = 1000)\n\nsaveRDS(pcr_model, file = paste0(here::here(), \"/Output/AGEB/pcr_model_eu.rds\"))\n\n## Caso máximo\ntest <- t(rep(100,19)) %>% as.data.frame() \ncolnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])\n\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0,19)) %>% as.data.frame() \ncolnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])\n\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Entorno Urbano\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_EU.txt\"), sep = \",\")\nload(paste0(here::here(), \"/Output/AGEB/EU_imputacion.Rdata\"))\n# Modelo predictivo de los datos imputados\npcr_pred <- predict(pcr_model, EU_imputacion[-1]) \npcr_pred <- data.frame(CVE_AGEB = EU_imputacion$CVE_AGEB, PC = pcr_pred) %>%\n              select(., c(1, ncp + 1)) %>% \n               mutate(Indicadora = \"Datos imputados_Entorno Urbano\")\ncolnames(pcr_pred) <- c(\"CVE_AGEB\", \"PC\", \"Indicadora\")\n\nPC_EU <- PC_EU %>%\n          mutate(Indicadora = \"\") %>%\n           rbind(pcr_pred)\n\nsave(PC_EU, file = paste0(here::here(), \"/Output/AGEB/PC_EU.Rdata\"))           "},{"path":"ageb-3.html","id":"calidad-del-entorno-2","chapter":"AGEB","heading":"Calidad del entorno","text":"Marco Geoestadístico NacionalMarginaciónDENUESe excluyen los subsistemas de Educación y Salud.SEPCLUESEntorno UrbanoIntegración del ICEImputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos\nque puede obtener cada subsistema, calculados por el método de\ncomponentes principales. Siendo estos los valores extremos (falta de\nequipamiento), este valor se formuló utilizando Principal Component\nRegresion (PCR) y de esta manera poder obtener el valor predictivo del\nvalor mínimo.Integración del ICE Imputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos que puede obtener cada subsistema, calculados por el método de componentes principales. Siendo estos los valores extremos (falta de equipamiento), este valor se formuló utilizando Principal Component Regresion (PCR) y de esta manera poder obtener el valor predictivo del valor mínimo.Se anexan los datos la base MGNSon 387 observaciones que tiene cálculo del entorno urbanoEs importante determinar que sucede con las AGEB que tienen cálculo","code":"\nload(paste0(here::here(), \"/Bases/AGEB/MGN_ageb.Rdata\"))\nload(paste0(here::here(), \"/Output/AGEB/PC_IMU.Rdata\"))\n\nIMU <- PC_IMU %>%\n         rename(\"IMU\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\nIndicadores <- names(Subsitemas)\n\nload(paste0(here::here(), \"/Output/AGEB/PC_DENUE.Rdata\"))\n\ntabla <- NULL\nfor(i in 1:11){\n  if(i %in% 1){\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c(\"CVE_AGEB\"))\n  } else {\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c(\"CVE_AGEB\")) %>%\n                 select(.,2)\n  }\n}\n\nDENUE <- do.call(cbind.data.frame, tabla)\ncolnames(DENUE) <- c(\"CVE_AGEB\", Indicadores)\nrm(tabla_DENUE)\nload(paste0(here::here(), \"/Output/AGEB/PC_SEP.Rdata\"))\nSEP <- PC_SEP %>%\n         rename(\"Educacion\" = \"PC\")\nload(paste0(here::here(), \"/Output/AGEB/PC_CLUES.Rdata\"))\n\nCLUES <- PC_CLUES %>%\n          rename(\"Salud\" = \"PC\")\nload(paste0(here::here(), \"/Output/AGEB/PC_EU.Rdata\"))\n\nEU <- PC_EU %>%\n       rename(\"EU\" = \"PC\")\nPCR_pred <- read.table(paste0(here::here(), \"/Output/AGEB/PCR_SEP.txt\"), header = TRUE, sep = \",\") %>% \n             rbind(.,read.table(paste0(here::here(), \"/Output/AGEB/PCR_CLUES.txt\"), header = TRUE, sep = \",\")) %>%\n              rbind(., read.table(paste0(here::here(), \"/Output/AGEB/PCR_DENUE.txt\"), header = TRUE, sep = \",\"))\nICE_2020 <- MGN_ageb %>%\n             select(CVE_AGEB) %>%\n              left_join(., IMU, by = c(\"CVE_AGEB\")) %>%\n               left_join(., SEP, by = c(\"CVE_AGEB\")) %>%\n                left_join(., CLUES, by = c(\"CVE_AGEB\")) %>%\n                 left_join(., DENUE, by = c(\"CVE_AGEB\")) %>% \n                  left_join(., EU, by = c(\"CVE_AGEB\")) %>% \n                   mutate_at(vars(2:16), as.numeric)\n\nICE_2020 <- ICE_2020 %>%\n                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),\n                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),\n                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),\n                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),\n                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),\n                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),\n                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),\n                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),\n                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),\n                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),\n                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),\n                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),\n                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,\n                   mutate(Indicadora = case_when(is.na(.$IMU) ~ \"Sin cálculo de marginación\",\n                                                 is.na(.$EU) ~ \"Sin cálculo de entorno urbano\", \n                                                 .$Indicadora == \"Datos imputados_Entorno Urbano\" ~ \"Datos imputados_Entorno Urbano\"))\ntable(ICE_2020$Indicadora)\n#> \n#> Datos imputados_Entorno Urbano     Sin cálculo de marginación \n#>                            385                             31\nICE_2020 <- ICE_2020 %>%\n             filter(is.na(.$Indicadora)  | .$Indicadora == \"Datos imputados_Entorno Urbano\") %>%\n              select(-Indicadora) "},{"path":"ageb-3.html","id":"método-de-distancias-dp_2-1","chapter":"AGEB","heading":"Método de Distancias \\(DP_2\\)","text":"José Bernardo Pena Trapero:\nProblemas de la medición del bienestar y conceptos afines (1977)Primeramente se define como es la entrada de los indicadores simples.\nEste tipo de método - Índice de marginación (Negativo) (Marginación baja\n(-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento +\nCLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de\naccesibilidad (Negativo) (Accesibilidad alta (cercanos cero) /\nAccesibilidad baja (Alejados del cero))Base de referenciaNota.- Se toma como base de referencia el valor del mínimo de cada\nindicador simple.\nTable 18: Tabla: Base de referencia nivel AGEB\nMétodo de Distancia \\(DP_{2}\\)El modelo converge la cuarta iteración","code":"\nICE_2020_data <- ICE_2020 %>%\n                   mutate(IMU = -1*.$IMU)\nminRV <- makeReferenceVector(X = ICE_2020_data[2:16], \n                             reference_vector_function = 'min')\nminRV\n#>            IMU  Educacion      Salud    Cultura Asistencia_social   Comercio\n#> [1,] -16.68513 -0.6404264 -0.3372863 -0.3508965        -0.2722898 -0.4698561\n#>      Comunicaciones Transporte Deporte_Recreacion Administracion_publica\n#> [1,]     -0.2825618 -0.4771963         -0.3112705             -0.3907859\n#>      Servicios_urbanos Servicios_financieros Hoteleria_Restaurantes  Talleres\n#> [1,]        -0.4844911            -0.2213161              -0.344338 -0.738592\n#>             EU\n#> [1,] -3.187468\n##Calculo del Método de Distancias DP2\nind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), \n                       reference_vector = minRV, \n                        iterations = 50)\n#> [1] \"Iteration 1\"\n#> [1] \"Iteration 2\"\n#> [1] \"Iteration 3\"\nind_ice$iteration\n#> [1] 3\nICE_2020 <- cbind(ICE_2020, ind_ice[[\"p2distance\"]])\n\n# Se cambian los nombres de las columnas \nnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"ICE\")\n# Se identifican los outliers en el índice de calidad del entorno\n#boxplot.stats(DP2_2010$IM_2010)$out\noutliers <- boxplot.stats(ICE_2020$ICE)\n\n## Se crea un índice ficticio quitando los outliers   \nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],\n                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],\n                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) "},{"path":"ageb-3.html","id":"método-de-estratificación-2","chapter":"AGEB","heading":"Método de estratificación","text":"strata.cumrootf: cumulative root frequency method Dalenius \nHodges (1959)Nclass óptimo del método de Dalenius & Hodgealloc lista que especifica el esquema de asignación. La lista debe\ncontener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de\nasignación general (ver paquete de stratification). El valor\npredeterminado es la asignación de Neyman (q1 = q3 = 0.5 y q2 = 0)Indice normalizadoEscenarios del mínimo y máximo valor en el índice DP2Se guarda la bases de Datos del ICE por municipio","code":"\nstart.time <- Sys.time()\n# Se define el coeficiente de variación a usar\ncoef.var <- 0.05\n\nDH_AGEB <- list()\ni <- 1\n  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)\n  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)\n  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)\n for (n in seq(5, 1000, 1)){\n   DH_AGEB[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)\n   cum <- DH_AGEB[[n]]\n   sd[i,] <-  c(n, cum$stderr, cum$CV)\n   meanh[i,] <- c(n, cum$meanh)\n   varh[i,] <-  c(n, cum$varh)\n   i <- i + 1\n}\n\ncolnames(sd) <- c(\"n\",\"sderr\",\"CV\")\ncolnames(meanh) <- c(\"nclass\", paste0(rep(\"Strata\",5),1:5))\ncolnames(varh) <- c(\"nclass\",paste0(rep(\"Strata\",5),1:5))\n\nend.time <- Sys.time()\ntime.taken <- round(end.time - start.time, 2)\ntime.taken\n\n#Se guardan los resultados de las iteraciones\nsave(sd, file = paste0(here::here(), \"/Output/AGEB/sd.Rdata\"))\nmin.strata <- sd %>%\n               as.data.frame() %>% \n                slice(which.min(.$CV))\nstrata.ice <- strata.cumrootf(ICE_2020$ICE_out,\n                               CV = 0.05, \n                                Ls = 5,\n                                 alloc = c(0.5,0,0.5), \n                                  nclass = min.strata$n)\n\n## Se agrega a la base de datos\nICE_2020 <- ICE_2020 %>%\n              select(-ICE_out) %>%   # Se quita el índice ficticio\n                mutate(G.ICE = strata.ice[[\"stratumID\"]])\n\n\n# Se cambian los nombres de las columnas \ncolnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"G.ICE\")\n\n# Se cambian los levels de D&H\nlevels(ICE_2020$G.ICE) = c(\"Completa\", \"Grave\", \"Moderada\", \"Ligera\", \"No hay\")\n# Desviación estandar de los indicadores\ndesvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%\n                       as.data.frame() %>%\n                        rename(\"desvest\" =\"V1\") %>%\n                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%\n                            mutate(desvest.inversa = 1/(.$sd_muestral))\n\n# Escenario mínimo\nvector_minimo <- as.matrix(minRV)\n\ntabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]\nminimo <- data.frame(Escenario = \"Mínimo\", tabla, DP2 = sum(tabla))\n\n\n# Escenario máximo\nvector_maximo <-  c(apply(ICE_2020_data[2:15], 2, max), \n                      IEU = 80.7211704737366)\n\ntabla <- abs(vector_maximo - minRV)*desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]  %>%\n             as.data.frame() \nmaximo <- data.frame(Escenario = \"Máximo\", tabla, DP2 = sum(tabla))\n\n# Indice normalizado\nmin_DP2 <- minimo$DP2[1]\nmax_DP2 <- maximo$DP2[1]\n\nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%\n               arrange(ICE_Norm)\n\n# Se guarda el índice de calidad del entorno normalizado\nsave(ICE_2020, file = paste0(here::here(), \"/Bases/AGEB/ICE_2020.RData\"))"},{"path":"resumen-general.html","id":"resumen-general","chapter":"Resumen general","heading":"Resumen general","text":"","code":""},{"path":"referencias.html","id":"referencias","chapter":"Referencias","heading":"Referencias","text":"CONAPO [Consejo Nacional de Población]. (2021a). Índice de marginación por entidad federativa y municipio 2020 Nota técnico-metodológica. (2021). Recuperado de: https://www.gob.mx/cms/uploads/attachment/file/685354/Nota_te_cnica_IMEyM_2020.pdf.\n_________. (2021b). Índice de marginación por localidad 2020 Nota técnico-metodológica. (2021). Recuperado de: https://www.gob.mx/cms/uploads/attachment/file/685308/Nota_t_cnica_IML_2020.pdf.DGIS [Dirección General de Información en Salud]. (2021). Catálogo de Clave Única de Establecimientos de Salud-CLUES. Recuperado de: http://www.dgis.salud.gob.mx/contenidos/sinais/s_clues.html.Dalenius y Hodges, J. L., Jr. (1959). Minimum variance stratification. Journal American Statistical Association, 54, 88-101. Gunning, P. y Horgan, J. M. (2004). new algorithm construction stratum boundaries skewed populations. Survey Methodology, 30 (2), 159–166.Gobierno de México. (2019). Plan Nacional de Desarrollo 2019-2024, Anexo XVIII-Bis, Gaceta Parlamentaria Número 5266-XVIII, Año XXII, Palacio Legislativo San Lázaro, México. Recuperado de: http://gaceta.diputados.gob.mx/PDF/64/2019/abr/20190430-XVIII-1.pdf (consultado el 16/11/2022).Gunning, P. y Horgan, J. M. (2004). new algorithm construction stratum boundaries skewed populations. Survey Methodology, 30 (2), 159–166.\nHidiroglou, M. . y Kozak, M. (2018). Stratification Skewed Populations: Comparison Optimizationbased versus Approximate Methods. International Statistical Review, 86 (1), 87–105. Recuperado de: https://doi.org/10.1111/insr.12230.Hubert, M. y Vandervieren, E. (2007). adjusted boxplot skewed distributions. ScienceDirect, 52 (12), 5186-5201. Recuperado de https://doi.org/10.1016/j.csda.2007.11.008.INEGI [Instituto Nacional de Estadística y Geografía]. (2020a). Recuperado de: Censo de Población y Vivienda 2020 https://www.inegi.org.mx/programas/ccpv/2020/\n_________. (2020b). Marco Geoestadístico Nacional 2020. Censo de Población y Vivienda 2020. Recuperado de: https://www.inegi.org.mx/temas/mg/\n_________. (2020c). Características del Entorno Urbano y Localidad. Recuperado de: https://www.inegi.org.mx/programas/ccpv/2020/\n_________. (2021). Directorio Estadístico Nacional de Unidades Económicas. Recuperado de: https:// www.inegi.org.mx/app/mapa/denue/\nINEGI-IMT/SCT (2020). Instituto Nacional de Estadística y Geografía (INEGI), Instituto Mexicano del Transporte (IMT) y la Secretaría de Comunicaciones y Transportes (SCT). Recuperado de: https://www.gob.mx/imt/acciones-y-programas/red-nacional-de-caminos..T. Jolliffe: “Principal Component Analysis”, Springer, 2002. ISBN: 978-0-387-22440-4Martens, H., Naes, T. (1989). Multivariate Calibration. John Wiley & Sons, Chichester, UK.Martens, H., Martens, M. (2001). Multivariate Analysis Quality. John Wiley & Sons, Chichester, UK.ONUHABITAT, (2022). Ciudades - Desarrollo Sostenible Recuperado de: https://www.un.org/sustainabledevelopment/es/cities/Pena Trapero, J. B. (1977). Problemas de la medición del bienestar y conceptos afines. Una aplicación al Caso Español. Madrid: INE.SEDESOL [Secretaría de Desarrollo Social]. (2012). Estructura del Sistema Normativo de Equipamiento. Recuperado de: http://cdam.unsis.edu.mx/files/Servicios%20publicos%20municipales/4%20Mercados/Sistema%20Normativo%20de%20Equipamiento%20Urbano%20SEDESOL.pdf.SIGED [Sistema de Información y Gestión Educativa]. (2021). Secretaría de Educación Pública (SEP). Recuperado de: http://snie.sep.gob.mx/SNIESC/ .Somarriba, N. (2008): Aproximación la medición de la calidad de vida en la Unión Europea. Tesis doctoral, dirigida por J. B. Pena, defendida el 11 de abril de 2008. Facultad de Ciencias Económicas y Empresariales. Universidad de Valladolid. Recuperado de: www.eumed.net/tesis-doctorales/2010/mnsa/index.htm.Somarriba, N. y Pena, B. (2009a): Synthetic Indicators Quality Life Europe. Social Indicators Research, doi 10.1007/s11205-008-9356-y. Recuperado de: https://link.springer.com/referenceworkentry/10.1007%2F978-94-007-0753-5_3729.Somarriba, N. y Pena, B. (2009b): La medición de la calidad de vida en Europa, el papel de la información subjetiva. Estudios de economía aplicada, Vol. 27(2).Somarriba, N. y Pena, B. (2010): Un análisis dinámico de la Calidad de Vida y de la Convergencia en Europa. Anales de Estudios Económicos y Empresariales, núm. 20, pp. 283-324.Zarzosa, P. (Dir.) (2005): La calidad de vida en los municipios de la provincia de Valladolid. Valladolid: Diputación Provincial de Valladolid.Zarzosa, P. (2009): Estimación de la pobreza en las Comunidades Autónomas españolas, mediante la Distancia DP2 de Pena. Estudios de Economía Aplicada, Vol. 27(2), pp. 397-416.Zarzosa, P. (2012): Social Welfare Spain Crisis: Territorial Chronological Analysis. International Journal Advances Management Economics. Vol. 1, núm. 4, pp. 165-171.Zarzosa, P. y Somarriba, N. (2013): Assessment Social Welfare Spain: Territorial Analysis Using Synthetic Welfare Indicator. Social Indicators Research, Vol. 111, pp. 1-23.Las librerías que se usaron para este projecto.","code":"\nsesion_info <- devtools::session_info()"}]
