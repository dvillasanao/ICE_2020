[{"path":"index.html","id":"introducción","chapter":"Introducción","heading":"Introducción","text":"Promoción de la Urbanización Sostenible por ONU-HabitatLa Organización de las Naciones Unidas, través de ONU-Habitat, impulsa una urbanización sostenible como motor de desarrollo, paz y derechos humanos. La rápida urbanización ha incrementado los habitantes en barrios pobres, infraestructuras y servicios sobrecargados, empeorando la contaminación del aire y el crecimiento urbano descontrolado. Por ello, el Objetivo 11 de los Objetivos de Desarrollo Sostenible (ODS) es crucial: “lograr que las ciudades y los asentamientos humanos sean inclusivos, seguros, resilientes y sostenibles”.Plan Nacional de Desarrollo 2019–2024En México, el Plan Nacional de Desarrollo 2019–2024 promueve garantizar los derechos económicos, sociales, culturales y ambientales en poblaciones y territorios, alineado con los objetivos de desarrollo sostenible.Índice de Calidad del Entorno (ICE) por CONAPOLa Secretaría General del Consejo Nacional de Población (CONAPO) presenta el Índice de Calidad del Entorno (ICE), un indicador compuesto que analiza las características de los asentamientos humanos, determinadas por las condiciones de marginación y la disponibilidad de servicios y equipamiento urbano. El ICE se desglosa en dos niveles geográficos: municipio y localidad, y se estructura en tres dimensiones:Dimensión sociodemográfica: Basada en indicadores socioeconómicos de los índices de marginación nivel municipal y localidad (CONAPO, 2021a y 2021b).Dimensión de equipamiento: Analiza la disponibilidad de equipamiento y servicios públicos y privados, organizados en subsistemas según el Sistema Normativo de Equipamiento (SEDESOL, 2012). Los datos provienen de fuentes como el DENUE (INEGI, 2021), SIGED (SEP, 2021) y CLUES (DGIS, 2021).\nDimensión de accesibilidad y aislamiento geográfico: Utiliza el tiempo de viaje centros urbanos según el censo 2020, como parte del estudio de accesibilidad geoespacial (CONAPO/IMT/CentroGeo, 2022).","code":""},{"path":"index.html","id":"estructura-del-índice-de-calidad-del-entorno","chapter":"Introducción","heading":"Estructura del índice de calidad del entorno","text":"Metodología del ICE.La construcción del ICE se realizó en cuatro etapas:Generación y análisis de indicadores simples asociados las dimensiones.Análisis de Componentes Principales (ACP): Reducción de variables componentes que explican la mayor varianza de los datos originales, generando un sistema de ponderación.Regresión de Componentes Principales (RCP): Método predictivo para estimar escenarios extremos y aplicar el método de distancias \\(DP_2\\) para obtener el ICE.Generación del ICE con el método \\(DP_2\\): Obtención de un índice sintético agregando la información de los indicadores.Técnicas Multivariantes ComplementariasEl uso de \\(ACP\\) y \\(DP_{2}\\) ha sido explorado en otras investigaciones. Pena (1977) argumenta que ambas técnicas son consistentes para comparar la posición relativa de las filas y obtener factores comunes de las columnas. Somarriba (2008) resalta que las agrupaciones en componentes condicionan los resultados del indicador sintético, enfocándose en los indicadores relevantes. Investigaciones adicionales que han utilizado estas técnicas incluyen trabajos de Zarzosa y Somarriba.Este resumen proporciona una visión integral del Índice de Calidad del Entorno, destacando su relevancia en la evaluación de los asentamientos humanos y la importancia de la urbanización sostenible en el marco del desarrollo nacional y global.Estrcutura del documentoMetodologíaFuentes de informaciónÍndice de Calidad del Entorno (Nivel Municipal)Índice de Calidad del Entorno (Nivel Localidad)Índice de Calidad del Entorno (Nivel AGEB)Resumen General","code":""},{"path":"metodología.html","id":"metodología","chapter":"Metodología","heading":"Metodología","text":"\n","code":""},{"path":"metodología.html","id":"primera-etapa-construcción-de-indicadores","chapter":"Metodología","heading":"Primera etapa: construcción de indicadores","text":"De acuerdo con los 13 subsistemas de equipamiento, se tomaron en consideración 71 variables que agruparon los sectores propuesto en el Sistema Normativo de Equipamiento (SEDESOL, 2012). Dada las limitaciones en la disponibilidad de datos e información oficial disponible para la conformación de las variables, estas se construyeron como porcentaje de los equipamientos disponibles en las localidades respecto al total del municipio y sector correspondiente:\\[w_{hjk} = \\sum_{h=1}^{N_{h}} \\sum_{j=1}^{n_{h}}\\frac{S_{hjk}}{S_{hk}}; \\text{donde k: 1,2,...,m} \\]\ndonde:\\(w_{hjk}\\): Razón de la característica de interés en la \\(j-ésima\\) localidad del \\(h-ésimo\\) municipio,\\(n_{h}\\): Número de localidades en el \\(h-ésimo\\) municipio,\\(N_{h}\\): Total de localidades en el \\(h-ésimo\\) municipio,\\(S_{hk}\\): Total de la característica de interés del \\(h-ésimo\\) municipio,\\(S_{hk}\\): Total de la característica de interés en la localidad \\(j-ésima\\) del \\(h-ésimo\\) municipio.","code":""},{"path":"metodología.html","id":"segunda-etapa-análisis-de-componentes-principales-pca","chapter":"Metodología","heading":"Segunda etapa: Análisis de Componentes Principales (PCA)","text":"El Análisis de Componentes Principales (PCA, por sus siglas en inglés) es un método estadístico utilizado para reducir la complejidad de un conjunto de datos. El objetivo es transformar las variables originales en un conjunto más pequeño y manejable de nuevas variables llamadas “componentes principales”.Este método se basa en el cálculo de una matriz de covarianzas o correlaciones entre las variables originales, y en la posterior obtención de los vectores y valores propios de esta matriz. Los vectores propios representan las direcciones en las que los datos tienen la mayor variabilidad, y los valores propios indican la cantidad de variabilidad explicada por cada componente principal. Los valores propios se ordenan de mayor menor, de manera que el primer componente principal explica la mayor parte de la variabilidad en los datos, y cada componente subsiguiente explica una proporción menor. Los componentes principales se utilizan para describir los datos y construir modelos estadísticos más sencillos.En resumen, el PCA es un método estadístico que reduce la complejidad de un conjunto de datos al transformar las variables originales en un conjunto más pequeño de nuevas variables que explican la mayor parte de la variabilidad de los datos.","code":""},{"path":"metodología.html","id":"ventajas-y-desventajas-del-pca","chapter":"Metodología","heading":"Ventajas y Desventajas del PCA","text":"Ventajas:Reducción de la dimensionalidad: PCA permite reducir el número de variables utilizadas para describir un conjunto de datos, facilitando su visualización y análisis.Identificación de patrones: Al identificar los componentes principales, el PCA puede ayudar encontrar patrones o relaciones entre las variables que eran evidentes en los datos originales.Eliminación de variables redundantes: PCA puede eliminar variables altamente correlacionadas, mejorando la eficiencia computacional y la interpretación de los resultados.Normalización de los datos: PCA normaliza los datos, eliminando problemas de escala o unidades diferentes entre las variables originales.Desventajas:Interpretación: La interpretación de los componentes principales puede ser difícil, especialmente si se tiene un conocimiento profundo del conjunto de datos.Pérdida de información: PCA puede eliminar información útil si se descartan componentes con baja variabilidad que podrían ser importantes para la descripción de los datos.Sensibilidad los datos atípicos: PCA puede verse afectado por datos atípicos, resultando en componentes que reflejan adecuadamente la variabilidad en los datos.Requisitos computacionales: PCA puede requerir muchos recursos computacionales, especialmente para conjuntos de datos grandes.","code":""},{"path":"metodología.html","id":"aplicación-del-pca","chapter":"Metodología","heading":"Aplicación del PCA","text":"El PCA es una técnica estadística supervisada que permite reducir la complejidad de múltiples dimensiones, conservando la información en unas pocas componentes. Dada una matriz de datos con \\(p \\times p\\) variables y \\(n \\times n\\) observaciones, donde los datos están centrados y escalados con su desviación estándar, se asegura que la nube de datos esté centrada en el origen de las componentes principales, sin verse afectada por las relaciones espaciales entre las variables.El PCA busca transformar el espacio vectorial generado por un vector \\(\\mathrm{X=}\\left(\\mathrm{\\ }X_{n1},\\ {\\ X}_{n2},\\ ...\\ ,\\ X_{np}\\right)\\) en un nuevo conjunto \\(\\mathrm{Z\\ =\\ }\\left(\\mathrm{\\ }Z_1,\\ {\\ Z}_2,\\ ...\\ ,\\ Z_k\\right),\\ \\ k\\le p\\), que sean combinaciones lineales de los indicadores y que expliquen la mayor parte de la variabilidad. Esto se expresa como:\\[Z\\ =\\ XA\\]\ndonde:\\(\\ =\\ \\left(a_{n1},\\ a_{n2},\\ ...,\\ a_{np}\\right)\\) representa las posiciones de cada observación en este nuevo sistema de coordenadas de componentes principales, denominadas loadings, y se calculan como combinaciones lineales de las variables originales y los pesos \\(a_{np}\\).El PCA también permite conocer la proporción de la varianza explicada por cada componente principal, además de la varianza total presente en un conjunto de datos:\\[\\sum_{j=1}^{p}{Var\\left(X_j\\right)\\ =}\\ \\sum_{j=1}^{p}\\frac{1}{n}\\sum_{=1}^{n}x_{ij}^2\\]\nLa varianza explicada por el \\(k-ésima\\) componente principal se define como:\\[\\frac{1}{n}\\sum_{1=1}^{n}z_{ik}^2=\\frac{1}{n}\\sum_{1=1}^{n}\\left(\\sum_{j=1}^{p}{a_{nj}x_{ij}}\\right)^2\\ \\]Por lo tanto, la proporción de la varianza explicada del \\(k-ésimo\\) componente principal está dada por:\\[\\frac{\\sum_{=1}^{n}\\left(\\sum_{j=1}^{p}{a_{nj}x_{ij}}\\right)^2}{\\sum_{j=1}^{p}\\frac{1}{n}\\sum_{=1}^{n}x_{ij}^2}\\]En total, hay \\(min(n\\ -\\ 1,\\ \\ p))\\) componentes principales, y la suma de la proporción de la varianza explicada es uno.","code":""},{"path":"metodología.html","id":"validación-del-pca","chapter":"Metodología","heading":"Validación del PCA","text":"Para validar el PCA, se considera la calidad de la representación de las variables en la construcción del modelo, lo que permite evaluar la estabilidad de las variables en los componentes. También se identifican los valores atípicos y se determina en qué medida influyen en la construcción de los indicadores.","code":""},{"path":"metodología.html","id":"descomposición-de-componentes-principales","chapter":"Metodología","heading":"Descomposición de componentes principales","text":"En el análisis de componentes principales, se puede descomponer la matriz de varianzas y covarianzas de dos maneras diferentes:Descomposición en valores propios (eigendecomposition): Esta descomposición se utiliza cuando la matriz de varianzas y covarianzas es simétrica y definida positiva. En este caso, la matriz se descompone en una matriz de autovectores y una matriz diagonal de valores propios. Los autovectores forman una base ortogonal que describe las direcciones principales de la varianza en los datos, mientras que los valores propios indican la importancia relativa de cada dirección.Descomposición en valores singulares (singular value decomposition, SVD): Esta descomposición se utiliza cuando la matriz de varianzas y covarianzas es simétrica o es definida positiva. En este caso, la matriz se descompone en tres matrices: una matriz de autovectores izquierdos, una matriz de autovectores derechos y una matriz diagonal de valores singulares. Los autovectores izquierdos y derechos forman una base ortogonal que describe las direcciones principales de la varianza en los datos, mientras que los valores singulares indican la importancia relativa de cada dirección.En ambas descomposiciones, se pueden seleccionar las componentes principales más importantes para reducir la dimensionalidad de los datos y simplificar su análisis.\n\n","code":""},{"path":"metodología.html","id":"identificación-de-datos-atípicos","chapter":"Metodología","heading":"Identificación de datos atípicos","text":"Los datos atípicos (también conocidos como valores extremos o outliers) pueden tener un impacto significativo en los resultados del método de componentes principales (PCA). Si los datos atípicos se manejan adecuadamente, pueden llevar resultados sesgados o incorrectos. Por lo tanto, es importante identificarlos y considerar cuidadosamente cómo manejarlos antes de realizar el análisis de PCA.Existen algunas estrategias para manejar los datos atípicos dentro del análisis de PCA:Identificación de los datos atípicos: Es importante identificar los datos atípicos antes de realizar el análisis de PCA. Esto se puede hacer mediante la visualización de los datos o mediante pruebas estadísticas.Identificación de los datos atípicos: Es importante identificar los datos atípicos antes de realizar el análisis de PCA. Esto se puede hacer mediante la visualización de los datos o mediante pruebas estadísticas.Exclusión de los datos atípicos: Una estrategia común para manejar los datos atípicos es excluirlos del análisis. Sin embargo, esto debe hacerse con cuidado, ya que la exclusión de los datos atípicos puede resultar en una pérdida de información importante.Exclusión de los datos atípicos: Una estrategia común para manejar los datos atípicos es excluirlos del análisis. Sin embargo, esto debe hacerse con cuidado, ya que la exclusión de los datos atípicos puede resultar en una pérdida de información importante.Transformación de los datos: Otra estrategia es transformar los datos antes de realizar el análisis de PCA. Las transformaciones comunes incluyen la transformación logarítmica o la normalización de los datos. Estas transformaciones pueden reducir la influencia de los datos atípicos y mejorar los resultados de PCA.Transformación de los datos: Otra estrategia es transformar los datos antes de realizar el análisis de PCA. Las transformaciones comunes incluyen la transformación logarítmica o la normalización de los datos. Estas transformaciones pueden reducir la influencia de los datos atípicos y mejorar los resultados de PCA.Uso de métodos robustos: Existen métodos robustos que pueden manejar los datos atípicos de manera efectiva en PCA, como el método de componentes principales robustos (RPCA, por sus siglas en inglés). Estos métodos son menos sensibles los datos atípicos y pueden proporcionar resultados más precisos.Uso de métodos robustos: Existen métodos robustos que pueden manejar los datos atípicos de manera efectiva en PCA, como el método de componentes principales robustos (RPCA, por sus siglas en inglés). Estos métodos son menos sensibles los datos atípicos y pueden proporcionar resultados más precisos.","code":""},{"path":"metodología.html","id":"método-de-componentes-principales-robustos-rpca","chapter":"Metodología","heading":"Método de Componentes Principales Robustos RPCA","text":"El método de componentes principales robustos (RPCA, por sus siglas en inglés) se utiliza cuando se sospecha que los datos contienen valores atípicos o errores que pueden afectar los resultados del análisis de componentes principales (PCA).El RPCA es una versión modificada del método de componentes principales tradicional que es menos sensible los valores atípicos y los errores en los datos. En lugar de minimizar la varianza total de los datos como en PCA, RPCA minimiza la varianza total de los datos después de excluir los valores atípicos o errores. Ete tipo de análisis puede ser útil en una variedad de situaciones, como en el análisis de datos biomédicos, análisis financiero, análisis de datos climáticos, entre otros.En general, se recomienda utilizar RPCA cuando:Los datos pueden contener valores atípicos o errores.Los datos pueden contener valores atípicos o errores.Los datos tienen una distribución normal.Los datos tienen una distribución normal.Las variables tienen diferentes escalas.Las variables tienen diferentes escalas.El tamaño de la muestra es pequeño en comparación con la dimensión de los datos.El tamaño de la muestra es pequeño en comparación con la dimensión de los datos.Se necesita una mayor precisión en los resultados del análisis.Se necesita una mayor precisión en los resultados del análisis.Observaciones del método RPCAEs importante tener en cuenta que RPCA siempre es necesario y puede ser computacionalmente más costoso que el método de componentes principales tradicional. Por lo tanto, es importante evaluar cuidadosamente si RPCA es apropiado para los datos que se estan tratando y los objetivos de análisis antes de utilizarlo.Aunque el método de componentes principales robustos (RPCA), es útil para manejar valores atípicos y errores en los datos, también presenta algunas desventajas que deben tenerse en cuenta:Mayor complejidad computacional: El método RPCA puede ser más costoso computacionalmente que el método de componentes principales tradicional debido la necesidad de excluir los valores atípicos o errores en los datos.Mayor complejidad computacional: El método RPCA puede ser más costoso computacionalmente que el método de componentes principales tradicional debido la necesidad de excluir los valores atípicos o errores en los datos.Pérdida de información: Al excluir los valores atípicos o errores en los datos, puede perderse información importante, lo que puede afectar la precisión de los resultados del análisis.Pérdida de información: Al excluir los valores atípicos o errores en los datos, puede perderse información importante, lo que puede afectar la precisión de los resultados del análisis.Dependencia del modelo: El método RPCA se basa en un modelo específico de distribución de datos, por lo que si los datos se ajustan este modelo, los resultados pueden ser incorrectos o inexactos.Dependencia del modelo: El método RPCA se basa en un modelo específico de distribución de datos, por lo que si los datos se ajustan este modelo, los resultados pueden ser incorrectos o inexactos.Selección de parámetros: El método RPCA requiere la selección de parámetros para determinar qué valores se consideran atípicos o errores, lo que puede ser subjetivo y afectar los resultados del análisis.Selección de parámetros: El método RPCA requiere la selección de parámetros para determinar qué valores se consideran atípicos o errores, lo que puede ser subjetivo y afectar los resultados del análisis.","code":""},{"path":"metodología.html","id":"tercera-etapa-regresión-de-componentes-principales-pcr","chapter":"Metodología","heading":"Tercera etapa: Regresión de Componentes Principales (PCR)","text":"El modelo de PCR es un método utilizado para reducir la dimensionalidad de los datos y evitar problemas de multicolinealidad en un modelo de regresión lineal múltiple. Este modelo se basa en la descomposición en valores singulares (SVD) de la matriz de datos originales, lo que permite identificar las componentes principales que explican la mayor parte de la varianza en los datos.partir de las componentes principales seleccionadas, se construye un modelo de regresión lineal múltiple utilizando estas componentes como variables predictoras. El número de componentes principales seleccionadas se determina de acuerdo con un criterio predefinido, como la cantidad de varianza explicada o un límite para el número de componentes.El modelo de PCR puede ser una alternativa útil la selección tradicional de variables predictoras en un modelo de regresión lineal, ya que permite reducir la dimensionalidad de los datos y evitar problemas de multicolinealidad. Sin embargo, es importante tener en cuenta que el modelo de PCR también tiene algunas limitaciones, como la interpretación de los coeficientes de regresión y la posible pérdida de información importante en los datos. Por lo tanto, se recomienda utilizar el modelo de PCR en combinación con otras técnicas de análisis de datos para obtener una comprensión completa del problema.Singular value descomposiciónEn el modelo de Regresión de Componentes Principales (PCR, por sus siglas en inglés), se utiliza la descomposición en valores singulares (SVD) para encontrar las componentes principales de los datos y reducir su dimensionalidad.La idea detrás del PCR es utilizar las componentes principales de los datos (obtenidas través de la SVD) como variables predictoras en un modelo de regresión lineal múltiple. De esta manera, se puede reducir el número de variables predictoras y evitar problemas de multicolinealidad, lo que puede mejorar la precisión del modelo y hacerlo más interpretable.En resumen, para implementar el modelo de PCR se utilizan los resultados de la descomposición en valores singulares (SVD) para seleccionar las componentes principales de los datos y construir un modelo de regresión lineal múltiple. Por lo tanto, se utiliza la descomposición en eigenvectores y eigenvalores.","code":""},{"path":"metodología.html","id":"método-de-distancias-ponderadas-al-cuadrado-dp_2","chapter":"Metodología","heading":"Método de distancias ponderadas al cuadrado \\(DP_2\\)","text":"El método de distancias ponderadas al cuadrado (\\(DP_2\\)) de José Bernardo Peña Trapero es una técnica estadística utilizada para medir la similitud entre diferentes objetos o casos. Este método se basa en una medida de distancia que se calcula sumando las diferencias al cuadrado ponderadas entre las características de dos objetos y tomando la raíz cuadrada del resultado. La ponderación de las características permite que las más importantes tengan un mayor impacto en el resultado final mientras que las menos importantes tienen un menor impacto.El método DP2 de Peña Trapero se utiliza en una variedad de aplicaciones, como la clasificación de imágenes y la evaluación de la similitud entre diferentes textos. Una de las ventajas del método \\(DP_2\\) es que puede manejar datos de diferentes tipos y escalas, lo que lo hace útil en situaciones donde los datos son heterogéneos.Sin embargo, también hay algunas desventajas en el uso del método DP2, como la selección subjetiva de la función de ponderación de características y el costo computacional en grandes conjuntos de datos. Por lo tanto, se deben evaluar cuidadosamente los datos y los objetivos de análisis antes de aplicar este método.En resumen, el método DP2 de Peña Trapero es una técnica útil para medir la similitud entre diferentes objetos o casos, pero se debe aplicar con cuidado y evaluar cuidadosamente en función de los datos y objetivos de análisis.","code":""},{"path":"fuentes-de-información.html","id":"fuentes-de-información","chapter":"Fuentes de información","heading":"Fuentes de información","text":"Primeramente, las fuentes de información que se utilizaron para la realización del índice de calidad del entorno se enumeran continuación:","code":""},{"path":"fuentes-de-información.html","id":"indicadores-sociodemográficos","chapter":"Fuentes de información","heading":"Indicadores sociodemográficos","text":"El Censo de Población y Vivienda 2020 (CPV2020) del INEGI (Instituto Nacional de Estadística y Geografía) el objetivo fue recopilar información detallada y actualizada sobre la población y las viviendas de México para ser utilizada en la toma de decisiones y la planificación de políticas públicas y privadas en el país. Esto incluye datos sobre la cantidad y características de las personas que viven en el país, como su edad, sexo, educación, ocupación, entre otros aspectos, así como información sobre la estructura y características de las viviendas en las que habitan. El cúal este tpo de informción es importante para la planificación y la toma de decisiones en áreas como la política pública, la inversión en infraestructura, la distribución de recursos y servicios, la investigación demográfica y social, y muchas otras. Además, también es utilizado por empresas y organizaciones para el análisis de mercado y la toma de decisiones estratégicas.","code":""},{"path":"fuentes-de-información.html","id":"equipamiento","chapter":"Fuentes de información","heading":"Equipamiento","text":"\n","code":""},{"path":"fuentes-de-información.html","id":"denue","chapter":"Fuentes de información","heading":"DENUE","text":"El Directorio Estadístico Nacional de Unidades Económicas (DENUE) es la infraestructura mínima del Subsistema Nacional de Información Económica (SNIE), cuyo propósito es proveer los usuarios tanto especializados como especializados de los datos de identificación, ubicación y contacto de las unidades económicas activas en el territorio nacional para el desarrollo y evaluación, tanto de políticas públicas como de programas de fomento económico en los tres niveles de gobierno; así como apoyo en el proceso de toma de decisiones para direccionar la inversión y optimizar recursos tanto en el ámbito público como en el privado.El Directorio Estadístico Nacional de Unidades Económicas (DENUE) del INEGI cuyo objetivo es proporcionar una base de datos actualizada y completa de las unidades económicas en México. Esto incluye empresas, establecimientos, instituciones gubernamentales, organizaciones sin fines de lucro, entre otras entidades que realizan actividades económicas en el país. Este tipo de insumo sirve como base para la planificación económica, la investigación y la toma de decisiones en áreas como la inversión, el análisis de mercado, el diseño de políticas públicas, la identificación de oportunidades comerciales, entre otras. Además, también es utilizado por el sector empresarial para el análisis de la competencia, la segmentación de mercado, la identificación de clientes potenciales, entre otros fines.[Sistema de Clasificación Industrial de América del Norte, 2018 (SCIAN)]El objetivo del SCIAN México es proporcionar un marco único, consistente y actualizado para la recopilación, análisis y presentación de estadísticas de tipo económico, que refleje la estructura de la economía mexicana. El SCIAN México es la base para la generación, presentación y difusión de todas las estadísticas económicas del INEGI. Su adopción por parte de las Unidades del Estado, permitirá homologar la información económica que se produce en el país, y con ello contribuir la de la región de América del Norte.UNIDAD DE ANÁLISISLas unidades económicas las que está referida la información del DENUE son dos: El establecimiento y la empresa.El establecimiento: unidad económica que, en una sola ubicación física, asentada en un lugar de manera permanente y delimitada por construcciones e instalaciones fijas, combina acciones y recursos bajo el control de una sola entidad propietaria o controladora para realizar alguna actividad económica sea con fines de lucro o .\nIncluye las viviendas en las que se realizan actividades económicas y excluye las viviendas en las que se llevan cabo actividades económicas con fines de autoconsumo, así como los servicios que se realizan en otros sitios.El establecimiento: unidad económica que, en una sola ubicación física, asentada en un lugar de manera permanente y delimitada por construcciones e instalaciones fijas, combina acciones y recursos bajo el control de una sola entidad propietaria o controladora para realizar alguna actividad económica sea con fines de lucro o .Incluye las viviendas en las que se realizan actividades económicas y excluye las viviendas en las que se llevan cabo actividades económicas con fines de autoconsumo, así como los servicios que se realizan en otros sitios.La empresa: organización, propiedad de una sola entidad jurídica, que realiza una o más actividades económicas, con autonomía en la toma de decisiones de mercadeo, financiamiento e inversión, al contar con la autoridad y responsabilidad de distribuir recursos de acuerdo con un plan o estrategia de producción de bienes y servicios, pudiendo estar ubicada u operar en varios domicilios.La empresa: organización, propiedad de una sola entidad jurídica, que realiza una o más actividades económicas, con autonomía en la toma de decisiones de mercadeo, financiamiento e inversión, al contar con la autoridad y responsabilidad de distribuir recursos de acuerdo con un plan o estrategia de producción de bienes y servicios, pudiendo estar ubicada u operar en varios domicilios.Se excluye las unidades económicas que llevan cabo actividades de manera ambulante o aquellas en las que los locales en los que se efectúa la actividad económica son desmontables y se remueven diariamente.Se excluye las unidades económicas que llevan cabo actividades de manera ambulante o aquellas en las que los locales en los que se efectúa la actividad económica son desmontables y se remueven diariamente.Se consideran 13 subsistemas económicos de los cuales se clasificaron 52 elementos económicos que pertenecen los subistemas.Se cargan todas las bases del DENUE 2021 que se van usar, el cúal después se van seleccionar los subramos económicos.Descarga masiva\nEn esta sección podrás descargar los archivos del DENUE, el Banco de Indicadores, el Inventario Nacional de Viviendas, Microdatos y la Sala de prensa por área geográfica, proyectos, años de la información, temas y formatos para poder utilizar la información en forma local en tu equipo.\nTitle: Directorio Estadístico Nacional de Unidades Económicas (DENUE) 05_2021Se muestra el algoritmo para integrar el DENUESe integran las claves geoestadísticas para la elaboración de los indicadores simples","code":"\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\ntablas <- c(\"43\", \"46111\", \"46112-46311\",\"46321-46531\", \"46591-46911\", \"48-49\", \"51\", \"52\", \"56\", \"61\", \"62\", \"71\",  \"72_1\", \"72_2\", \"81_1\", \"81_2\")\n\n# Enlaces de las bases de datos (Descargas masivas | INEGI | DENUE)\n#https://www.inegi.org.mx/app/descarga/default.html\nurl <- read.table(file = \"Bases/DENUE/Enlaces_DENUE_0521.txt\", sep = \",\")\n\nfor(i in 1:16){\n  if(!file.exists(paste0(here::here(), \"/Bases/DENUE/denue_00_\", tablas[i], \"_0521_csv.zip\"))){\n  download.file(url[i,], paste0(here::here(), \"/Bases/DENUE/denue_00_\", tablas[i], \"_0521_csv.zip\"), mode = \"wb\")\n  }\n}\n\n# Se agrupan 16 bases de datos en formato CVS en un solo data.frame \nfor(i in tablas){\n  assign(paste0(\"df_\",i), read.csv(paste0(here::here(), \"/DENUE/CSV/CSV/conjunto_de_datos/denue_inegi_\",i,\"_.csv\"), fileEncoding = \"latin1\"))\n}\n\n# Se agrupan todas las tablas en una sola\nlista <- ls(pattern =  \"df_\")\ndenue_2021 <- do.call(rbind.data.frame, mget(lista))\n\ndenue_2021 <- denue_2021 %>%\n               select(codigo_act, nombre_act, cve_ent, entidad, cve_mun, municipio, cve_loc, localidad, ageb, manzana) %>% \n                 mutate(cve_ent = stringr::str_pad(.$cve_ent, 2, \"left\", pad = \"0\"), \n                        cve_mun = stringr::str_pad(.$cve_mun, 3, \"left\", pad = \"0\"),\n                        cve_loc = stringr::str_pad(.$cve_loc, 4, \"left\", pad = \"0\"),\n                        ageb = stringr::str_pad(.$ageb, 4, \"left\", pad = \"0\"),\n                        manzana = stringr::str_pad(.$manzana, 3, \"left\", pad = \"0\")) %>%\n                   mutate(CVE_MUN = paste0(.$cve_ent, .$cve_mun),\n                          CVE_LOC = paste0(.$cve_ent, .$cve_mun, .$cve_loc),\n                          CVE_AGEB = paste0(.$cve_ent, .$cve_mun, .$cve_loc, .$ageb), \n                          CVE_MZA =  paste0(.$cve_ent, .$cve_mun, .$cve_loc, .$ageb, .$manzana)) %>%\n# Se anexa la base de Claves\n                    left_join(., SCIAN, \n                               by = c(\"codigo_act\" = \"CODIGO\")) %>%\n                      mutate(CVE_ELE = as.character(.$CVE_ELE))\n\n# Se guarda la base de datos donde se integran 16 bases de datos\nsave(denue2021, file = paste0(here::here(), \"/Bases/DENUE/denue2021.RData\"))\n# Estructura integrada del DENUE\nload(paste0(here::here(), \"/Bases/denue_integrado.RData\"))\ncodigo <- unique(SCIAN$CODIGO)"},{"path":"fuentes-de-información.html","id":"municipio","chapter":"Fuentes de información","heading":"Municipio","text":"","code":"\ndenue_mun <- denue_2021 %>%\n              filter(.$codigo_act %in% codigo) %>%\n               select(ELEMENTO, CVE_MUN) %>%\n                melt(., id = c(\"CVE_MUN\"))  %>%\n                 mutate(value = as.character(.$value)) %>%\n                  acast(., CVE_MUN ~ value, drop = FALSE) %>% \n                   as.data.frame() %>% \n                    tibble::rownames_to_column(., \"CVE_MUN\") %>%\n                     mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%\n                      relocate(CVE_ENT, .before = \"CVE_MUN\") %>%\n                       group_by(CVE_ENT) %>%\n                        mutate_at(vars(c(-CVE_ENT, -CVE_MUN)), funs(./sum(.)*100))%>%\n                         replace(., is.na(.), 0)\n\nsave(denue_mun, file = paste0(here::here(), \"/Bases/Municipio/Indicadores_DENUE.RData\"))"},{"path":"fuentes-de-información.html","id":"localidad","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\ndenue_loc <- denue_2021 %>%\n              filter(.$codigo_act %in% codigo) %>%\n               select(ELEMENTO, CVE_LOC) %>%\n                melt(., id = c(\"CVE_LOC\"))  %>%\n                 mutate(value = as.character(.$value)) %>%\n                  acast(., CVE_LOC ~ value, drop = FALSE) %>% \n                   as.data.frame() %>% \n                    tibble::rownames_to_column(., \"CVE_LOC\") %>%\n                     mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%\n                      relocate(CVE_MUN, .before = \"CVE_LOC\") %>%\n                       group_by(CVE_MUN) %>%\n                        mutate_at(vars(c(-CVE_MUN, -CVE_LOC)), funs(./sum(.)*100))%>%\n                         replace(., is.na(.), 0)\n\nsave(denue_loc, file = paste0(here::here(), \"/Bases/Localidad/Indicadores_DENUE.RData\"))"},{"path":"fuentes-de-información.html","id":"ageb","chapter":"Fuentes de información","heading":"AGEB","text":"","code":"\ndenue_ageb <- denue_2021 %>%\n               filter(.$codigo_act %in% codigo) %>%\n                select(ELEMENTO, CVE_AGEB) %>%\n                 melt(., id = c(\"CVE_AGEB\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_AGEB ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_AGEB\")  %>%\n                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%\n                       relocate(CVE_LOC, .before = \"CVE_AGEB\") %>%\n                        group_by(CVE_LOC) %>%\n                         mutate_at(vars(c(-CVE_LOC, -CVE_AGEB)), funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(denue_ageb, file = paste0(here::here(), \"/Bases/AGEB/Indicadores_DENUE.RData\"))"},{"path":"fuentes-de-información.html","id":"sep","chapter":"Fuentes de información","heading":"SEP","text":"","code":"\nload(paste0(here::here(), \"/Bases/SEP_Estructura.RData\"))"},{"path":"fuentes-de-información.html","id":"municipio-1","chapter":"Fuentes de información","heading":"Municipio","text":"Se utiliza la base de datos nivel municipio, ya que esta presenta todo el universo de escuelas en el país.","code":"\nsep_mun <- SEP %>%\n            select(CVE_MUN, `Nivel educativo`) %>%\n             reshape2::melt(., id = c(\"CVE_MUN\")) %>%\n              acast(., CVE_MUN ~ value, drop = FALSE) %>%\n               as.data.frame() %>% \n                tibble::rownames_to_column(., \"CVE_MUN\") %>%\n                 mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%\n                  relocate(CVE_ENT, .before = \"CVE_MUN\") %>%\n                   group_by(CVE_ENT) %>%\n                    mutate_at(vars(c(-CVE_MUN, -CVE_ENT)), funs(./sum(.)*100))%>%\n                     replace(., is.na(.), 0)\nsave(sep_mun, file = paste0(here::here(), \"/Bases/Municipio/Indicadores_Escuelas_SEP.RData\"))"},{"path":"fuentes-de-información.html","id":"localidad-1","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\nsep_loc <- SEP %>%\n                select(CVE_LOC, `Nivel educativo`) %>%\n                 reshape2::melt(., id = c(\"CVE_LOC\")) %>%\n                   acast(., CVE_LOC ~ value, drop = FALSE) %>%\n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_LOC\") %>%\n                      mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%\n                        relocate(CVE_MUN, .before = \"CVE_LOC\") %>%\n                         group_by(CVE_MUN) %>%\n                          mutate_at(vars(c(-CVE_LOC, -CVE_MUN)), funs(./sum(.)*100))%>%\n                           replace(., is.na(.), 0)\n\nsave(sep_loc, file = paste0(here::here(), \"/Bases/Localidad/Indicadores_Escuelas_SEP.RData\"))"},{"path":"fuentes-de-información.html","id":"ageb-1","chapter":"Fuentes de información","heading":"AGEB","text":"","code":"\nload(\"Bases/SEP_Estructura_AGEB.RData\")\nsep_ageb <- sep_ageb %>%\n                select(CVE_AGEB, `Nivel educativo`) %>%\n                 reshape2::melt(., id = c(\"CVE_AGEB\")) %>%\n                   acast(., CVE_AGEB ~ value, drop = TRUE) %>% # drop = FALSE\n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_AGEB\") %>%\n                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%\n                        relocate(CVE_LOC, .before = \"CVE_AGEB\") %>%\n                         group_by(CVE_LOC) %>%\n                          mutate_at(vars(c(-CVE_AGEB, -CVE_LOC)), funs(./sum(.)*100))%>%\n                           replace(., is.na(.), 0)\n\nsave(sep_ageb, file = paste0(here::here(), \"/Bases/AGEB/Indicadores_Escuelas_SEP.RData\"))"},{"path":"fuentes-de-información.html","id":"clues","chapter":"Fuentes de información","heading":"CLUES","text":"","code":"\nload(\"Bases/CLUES_Estructura.RData\")"},{"path":"fuentes-de-información.html","id":"municipio-2","chapter":"Fuentes de información","heading":"Municipio","text":"","code":"\nclues_mun <- CLUES %>%\n                select(`Nivel de atención`, CVE_MUN) %>%\n                 melt(., id = c(\"CVE_MUN\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_MUN ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_MUN\") %>%\n                      mutate(CVE_ENT = substr(.$CVE_MUN, 1, 2)) %>%\n                       relocate(CVE_ENT, .before = \"CVE_MUN\") %>%\n                        group_by(CVE_ENT) %>%\n                         mutate_at(vars(c(-CVE_ENT, -CVE_MUN)),funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(clues_mun, file = paste0(here::here(), \"/Bases/Municipio/Indicadores_CLUES.RData\"))"},{"path":"fuentes-de-información.html","id":"localidad-2","chapter":"Fuentes de información","heading":"Localidad","text":"","code":"\nclues_loc <- CLUES %>%\n                select(`Nivel de atención`, CVE_LOC) %>%\n                 melt(., id = c(\"CVE_LOC\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_LOC ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_LOC\") %>%\n                      mutate(CVE_MUN = substr(.$CVE_LOC, 1, 5)) %>%\n                       relocate(CVE_MUN, .before = \"CVE_LOC\") %>%\n                        group_by(CVE_MUN) %>%\n                         mutate_at(vars(c(-CVE_MUN, -CVE_LOC)),funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(clues_loc, file = paste0(here::here(), \"/Bases/Localidad/Indicadores_CLUES.RData\"))"},{"path":"fuentes-de-información.html","id":"ageb-2","chapter":"Fuentes de información","heading":"AGEB","text":"","code":"\nload(paste0(here::here(), \"/Bases/CLUES_Estructura_AGEB.RData\"))\nclues_ageb <- CLUES_AGEB %>%\n                select(`Nivel de atención`, CVE_AGEB) %>%\n                 melt(., id = c(\"CVE_AGEB\"))  %>%\n                  mutate(value = as.character(.$value)) %>%\n                   acast(., CVE_AGEB ~ value, drop = FALSE) %>% \n                    as.data.frame() %>% \n                     tibble::rownames_to_column(., \"CVE_AGEB\") %>%\n                      mutate(CVE_LOC = substr(.$CVE_AGEB, 1, 9)) %>%\n                       relocate(CVE_LOC, .before = \"CVE_AGEB\") %>%\n                        group_by(CVE_LOC) %>%\n                         mutate_at(vars(c(-CVE_LOC, -CVE_AGEB)),funs(./sum(.)*100))%>%\n                          replace(., is.na(.), 0)\n\nsave(clues_ageb, file = paste0(here::here(), \"/Bases/AGEB/Indicadores_CLUES.RData\"))"},{"path":"fuentes-de-información.html","id":"índice-de-accesibilidad-ia","chapter":"Fuentes de información","heading":"Índice de accesibilidad (IA)","text":"","code":""},{"path":"fuentes-de-información.html","id":"municipio-3","chapter":"Fuentes de información","heading":"Municipio","text":"\n","code":"\nload(paste0(here::here(), \"/Bases/Municipio/IA_municipio.Rdata\"))"},{"path":"fuentes-de-información.html","id":"localidad-3","chapter":"Fuentes de información","heading":"Localidad","text":"\n","code":"\nload(paste0(here::here(), \"/Bases/Localidad/IA_localidad.Rdata\"))"},{"path":"fuentes-de-información.html","id":"entorno-urbano","chapter":"Fuentes de información","heading":"Entorno Urbano","text":"Dada la importancia de los proyectos sobre el entorno urbano, destacada por informes como el que presentó ONU-Hábitat sobre el Estado de las ciudades en América Latina y el Caribe 2012 o el de CEPAL-CELADE en el cual se afirma que debe adoptarse como acuerdo de trabajo que los temas de entorno, equipamiento y medio ambiente se incorporen los censos para definir la calidad y adecuación de la vivienda, en particular la urbana.Algortinmo de integración del Entorno UrbanoNo enfocamos en los indicadores númericos.","code":"\ntablas <- c(paste0(\"0\", seq(1, 9, 1)), seq(10, 32, 1))\n\nfor(i in tablas){\n assign(paste0(\"TI_\", i), read_sav(paste0(here::here(), \"/TI_MANZANA/TI_MANZANA_EU_\",i,\".SAV\")))\n}\n\n# Se agrupan todas las tablas en una sola\nlista <- ls(pattern = \"TI_\")\nMANZANA_EU_2020 <- do.call(rbind.data.frame, mget(lista))\n\nMANZANA_EU_2020 <- MANZANA_EU_2020 %>% \n                    select(\"ENT\", \"CVE_MUN\",\"CVE_LOC\",\"CVE_AGEB\",\"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n                     mutate(PAVIM_ADOQ_N = .$PAVIM_N + .$ADOQ_N) %>%\n                      select(\"ENT\", \"CVE_MUN\",\"CVE_LOC\",\"CVE_AGEB\",\"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N,\n                             C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N,\n                             C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)\n\n# Se guarda la base de datos donde se integran 16 bases de datos\nsave(MANZANA_EU_2020, file = paste0(here::here(), \"/Bases/MANZANA_EU_2020.RData\"))\nload(paste0(here::here(), \"/Bases/MANZANA_EU_2020.RData\"))"},{"path":"fuentes-de-información.html","id":"caso-particular","chapter":"Fuentes de información","heading":"Caso particular","text":"Caso particular\nMunicpio de Ocampo / Localidad Melchor Ocampo\nDebido la falta de información de este municipio, se toma como referencia los municipios vecinos.08009 Bocoyna08031 Guerrero08041 Maguarichi08047 Boris08063 Temósachic08066 UruachiFuente: Espacio y datos de México (INEGI)","code":"\nEU_mun <- MANZANA_EU_2020 %>%\n           select(\"ENT\", \"CVE_MUN\", \"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n             filter(CVE_MUN %in% c(\"08009\", \"08031\", \"08041\", \"08047\", \"08063\", \"08066\")) %>%\n              select(-CVE_MUN) %>%\n                group_by(ENT) %>% \n                  summarise(across(where(is.numeric), sum)) %>%\n                   ungroup() %>%\n                    mutate_at(vars(c(-ENT, -PERSONAS,-VIVPARHAB,-TOTLADO)),funs((./TOTLADO)*100))\n\nsave(EU_mun, file = paste0(here::here(), \"/Bases/Municipio/EU_mun.RData\"))"},{"path":"fuentes-de-información.html","id":"nivel-localidad","chapter":"Fuentes de información","heading":"Nivel Localidad","text":"","code":"\nEU_loc <- MANZANA_EU_2020 %>%\n             select(\"CVE_LOC\", \"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n              group_by(CVE_LOC) %>% \n               summarise(across(where(is.numeric), sum)) %>%\n                ungroup() %>%\n                 mutate_at(vars(c(-CVE_LOC, -PERSONAS,-VIVPARHAB,-TOTLADO)), funs((./TOTLADO)*100))\n\nsave(EU_loc, file = paste0(here::here(), \"/Bases/Localidad/EU_loc.RData\"))"},{"path":"fuentes-de-información.html","id":"nivel-ageb","chapter":"Fuentes de información","heading":"Nivel AGEB","text":"","code":"\nEU_ageb <- MANZANA_EU_2020 %>%\n            select(\"CVE_AGEB\", \"PERSONAS\", \"VIVPARHAB\", \"TOTLADO\", \"TOTVIAL\", \"TOTRASGO\", contains(\"_N\")) %>%\n              group_by(CVE_AGEB) %>% \n               summarise(across(where(is.numeric), sum)) %>%\n                ungroup() %>%\n                 mutate_at(vars(c(-CVE_AGEB, -PERSONAS,-VIVPARHAB,-TOTLADO)), funs((./TOTLADO)*100))\n\nsave(EU_ageb, file = paste0(here::here(), \"/Bases/AGEB/EU_ageb.RData\"))"},{"path":"municipio-4.html","id":"municipio-4","chapter":"Municipio","heading":"Municipio","text":"Se toma como referencia el marco geoestadístico nacional 2020 Nivel Municipal.","code":"\nload(paste0(here::here(), \"/Bases/Municipio/MGN.Rdata\"))"},{"path":"municipio-4.html","id":"marginación","chapter":"Municipio","heading":"Marginación","text":"Se carga la nueva base del índice de marginación 2020.Para el cálculo de los componentes principales depende de las unidades de medida empleadas en las variables. Por lo que es importante, antes de aplicar PCA, estandarizar los indicadores simples para que tenganmedia 0 y desviación estándar 1, ya que, de lo contrario, las variables con mayor varianza dominarían al resto, aunque en el caso en que las variables estén medidas en las mismas unidades, podemos optar por estandarizarlas. La estandarización se lleva cabo restando cada observación la media y dividiendo entre la desviación estándar de la variable la que pertenece:\\[Z_{}=\\frac{x_{}-\\bar{x}}{\\sigma_{}}\\]Se utiliza la función \\(PCA\\) del parquete FactoMiner, donde se especifica que se estandaricen las vairables con el parámetro scale.unit=TRUEAnálisis de componentes principalesSe utilizan todas las variablesEs importante seleccionar que gráficos se pueden incluir en el análisisSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumuladaPor otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos través de descomposición de valores singulares (SVD) de la matriz de datos.\\[\\mathbf X = \\mathbf U \\mathbf S \\mathbf V^\\top\\] - Segundo, desde el punto de vista PCA que requiere el cálculo de los valores propios y los vectores propios, haciendo la descomposición propia de \\(\\mathbf X \\mathbf X^{T}\\).\\[\\mathbf X \\mathbf V = \\mathbf U \\mathbf S \\mathbf V^\\top \\mathbf V = \\mathbf U \\mathbf S\\]Donde - \\(\\mathbf V\\) son los eigenvectors - \\(\\mathbf U\\) es la matriz unitaria - \\(\\mathbf S\\) es la traza de los eigenvaluesLas columnas de \\(\\mathbf {US}\\) son los pesos de las componentes principalesSe generan los índices de cada uno de los subsistemas Se utilizan los componentes principales que expliquen el máximo de la informaciónSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.ResumenSe tienen todas las observaciones","code":"\nload(paste0(here::here(), \"/Bases/Municipio/IMM.Rdata\"))\nPCA_IMM <- PCA(IMM[, c(2:ncol(IMM))],\n                scale.unit = TRUE, \n                 ncp = ncol(IMM[, c(2:ncol(IMM))]),\n                  graph = FALSE) \n# Componentes seleccionadas\nncp <- 3\n\n# Índices de las componentes principales seleccionados\nPC_IMM <-  IMM %>%\n            select(CVE_MUN) %>%\n             mutate(PC = as.numeric(scale(as.matrix(IMM[, c(2:10)])) %*% \n                                     as.matrix(PCA_IMM[[\"var\"]][[\"coord\"]][, 1:ncp]) %*% \n                                      as.matrix(PCA_IMM[[\"eig\"]][,2][1:ncp]/100))) %>%\n              as.data.frame()\n\nsave(PC_IMM, file = paste0(here::here(), \"/Output/Municipio/PC_IMM.Rdata\"))"},{"path":"municipio-4.html","id":"equipamiento-1","chapter":"Municipio","heading":"Equipamiento","text":"Claves económicas","code":""},{"path":"municipio-4.html","id":"denue-1","chapter":"Municipio","heading":"DENUE","text":"Se anexan los indicadores simples, de acuerdo la clasificación económica del DENUE (01)Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUESubramosSe toman como referencia 13 subsitemas económicos y 64 elementos económicos que lo integranDimensiones de cálculoAnálisis de componentes principales","code":"\nload(paste0(here::here(), \"/Bases/Municipio/Indicadores_DENUE.RData\"))\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\ntablas <- names(Subsitemas)\ntablas\n#>  [1] \"Cultura\"                \"Asistencia_social\"      \"Comercio\"              \n#>  [4] \"Comunicaciones\"         \"Transporte\"             \"Deporte_Recreacion\"    \n#>  [7] \"Administracion_publica\" \"Servicios_urbanos\"      \"Servicios_financieros\" \n#> [10] \"Hoteleria_Restaurantes\" \"Talleres\"\nfor(i in 1:11){\nassign(paste0(\"tabla_\", tablas[i]), denue_mun %>%\n                                     ungroup() %>%\n                                      select(CVE_MUN, Subsitemas[[paste(tablas[i])]]) %>%\n                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%\n                                        mutate(suma = as.numeric(.$suma)) %>%\n                                          filter(.$suma != 0) %>%\n                                           select(-suma))\n}\nncp <- c(1, 1, 1, 1, 3, 1 ,1, 1, 1, 1, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))\n\nPCA_Subsistemas <- NULL\nfor(i in 1:11){\n  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0(\"tabla_\", tablas[i]))[, c(2:ncol(get(paste0(\"tabla_\", tablas[i]))))], \n                                              scale.unit = TRUE, \n                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),\n                                                graph = FALSE) \n}\n# Índices de las componentes principales seleccionados\nPC_DENUE <- NULL\nfor(i in 1:11){\n  PC_DENUE[[i]] <- get(paste0(\"tabla_\", tablas[i]))[1] %>%\n                    select(CVE_MUN) %>%\n                     mutate(PC = scale(as.matrix(get(paste0(\"tabla_\", tablas[i]))[,-1])) %*% \n                      as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"var\"]][[\"coord\"]][,1:ncp[i]]) %*% \n                       as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"eig\"]][,2][1:ncp[i]]/100)) %>% \n                        as.data.frame()\n}\nsave(PC_DENUE, file = paste0(here::here(), \"/Output/Municipio/PC_DENUE.Rdata\"))"},{"path":"municipio-4.html","id":"valores-extremos","chapter":"Municipio","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\", tablas[i]))[-1], ncomp = ncp[i], scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\n## Se guardan los resultados \nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_denue.rds\"))\n\n## Caso máximo\npcr_pred_max <- NULL\nfor(i in 1:11){\n  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)\n  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), \".comp\"))\n}\n\n## Caso mínimos \npcr_pred_min <- NULL\nfor(i in 1:11){\n  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)\n}\n\npcr_extremos <- matrix(NA, nrow = 11, ncol = 3)\nfor(i in 1:11){\n  pcr_extremos[i, 1] <- paste(tablas[i])\n  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]\n  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]\n}\ncolnames(pcr_extremos) <- c(\"Indicadores\", \"Máximo\", \"Mínimo\")\n\nsave(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_DENUE.RData\"))\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_DENUE.txt\", sep = \",\"))"},{"path":"municipio-4.html","id":"validación-cruzada","chapter":"Municipio","heading":"Validación Cruzada","text":"Mean Squared Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}\\]\n- Root Mean Squared Prediction Error RMSE\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}}\\]La función postResample puede utilizarse para estimar el error cuadrático medio (RMSE), el R2 simple y el error absoluto medio (MAE) para resultados numéricos.Mean Absolute Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left|Y_{}- \\hat{Y}_{}\\right|^{2}\\]","code":"\n# Validación Cruzada \n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\n ncomp <- length(get(paste0(\"tabla_\", tablas[i]))[-1]) \npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\", tablas[i]))[-1], ncomp = ncomp, scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_denue_cv.rds\"))\n\nsummary(pcr_model[[1]])\n\n#calculate MSE\nmean((pcr_model[[1]][[\"residuals\"]])^2)\nset.seed(123)\nrequire(caret)\nrequire(pls)\n\ntrControl <- trainControl(method = \"cv\", number = 10, selectionFunction = \"oneSE\") \n\n# Crear listas vacías para almacenar training y testing\ntraining_list <- list()\ntesting_list <- list()\n\ncaret.pcr <- lapply(1:11, function(x){\n                           # Crear el data frame original con la variable respuesta y predictores\n                           df <- data.frame(PC = PC_DENUE[[x]][, 2]) %>% \n                                  cbind(., get(paste0(\"tabla_\", tablas[x]))[-1])\n                          \n                          # Dividir los datos en conjuntos de entrenamiento y prueba\n                          inTraining <- createDataPartition(df$PC, p = .75, list = FALSE)\n                          training <- df[inTraining, ]\n                          testing <- df[-inTraining, ]\n                          \n                          # Almacenar los conjuntos de entrenamiento y prueba en las listas\n                          training_list[[x]] <<- training\n                          testing_list[[x]] <<- testing\n                          \n                          # Entrenar el modelo PCR usando caret\n                          caret_model <- train(PC ~ ., data = training, \n                                         method = \"pcr\",\n                                         preProcess = c(\"center\", \"scale\"),\n                                         trControl = trControl, \n                                         tuneGrid = data.frame(ncomp = 1:(ncol(training) - 1)))\n  \n  return(caret_model)\n                        \n})\n\nsaveRDS(caret.pcr, paste0(here::here(), \"/Output/Municipio/caret_pcr_denue_cv.rds\"))\nsaveRDS(training_list, paste0(here::here(), \"/Output/Municipio/caret_train_denue_cv.rds\"))\nsaveRDS(testing_list, paste0(here::here(), \"/Output/Municipio/caret_test_denue_cv.rds\"))\n#use model to make predictions on a test set\npcr_pred <- predict(caret.pcr[[5]], testing_list[[5]])\n# Calculate MSE \nmean((pcr_pred - testing_list[[5]]$PC)^2)\n# Calculate RMSE \n#sqrt(mean((pcr_pred - testing$PC)^2))\nRMSE = caret::RMSE(pcr_pred, testing_list[[5]]$PC)\n# Summary of accurracy \npostResample(pred = pcr_pred, obs = testing_list[[5]]$PC)"},{"path":"municipio-4.html","id":"educación","chapter":"Municipio","heading":"Educación","text":"Análisis de componentes principales","code":"\nload(\"Bases/Municipio/Indicadores_Escuelas_SEP.RData\")\n\nsep_mun <- sep_mun %>%\n             mutate(suma = rowSums(.[3:11])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_SEP <- PCA(sep_mun[, c(3:11)],\n                scale.unit = TRUE, \n                 ncp = ncol(sep_mun[, c(3:11)]),\n                  graph = FALSE)\n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 2\n# Índices de las componentes principales seleccionados\nPC_SEP <-  sep_mun %>%\n            select(CVE_MUN) %>%\n             mutate(PC = as.numeric(scale(as.matrix(sep_mun[, c(3:11)])) %*% \n              as.matrix(PCA_SEP[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n               as.matrix(PCA_SEP[[\"eig\"]][,2][1:ncp]/100))) %>%\n                as.data.frame()\nsave(PC_SEP,  file = paste0(here::here(), \"/Output/Municipio/PC_SEP.Rdata\"))"},{"path":"municipio-4.html","id":"valores-extremos-1","chapter":"Municipio","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_SEP$PC~., data = sep_mun[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n#saveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_sep.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_mun[,c(3:11)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_mun[,c(3:11)])\npcr_pred_min <- predict(pcr_model, test)\n\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp])\n\nsave(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_SEP.RData\"))\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_SEP.txt\", sep = \",\"))"},{"path":"municipio-4.html","id":"validación-cruzada-1","chapter":"Municipio","heading":"Validación Cruzada","text":"Mean Squared Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}\\]\n- Root Mean Squared Prediction Error RMSE\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}}\\]La función postResample puede utilizarse para estimar el error cuadrático medio (RMSE), el R2 simple y el error absoluto medio (MAE) para resultados numéricos.Mean Absolute Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left|Y_{}- \\hat{Y}_{}\\right|^{2}\\]","code":"\nncomp <- length(sep_mun[, c(3:11)])\n# Validación Cruzada \npcr_model <- pcr(PC_SEP$PC~., data = sep_mun[, c(3:11)], \n                 ncomp = ncomp,  \n                 scale = TRUE, \n                 center = TRUE, \n                 validation = \"LOO\")\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_sep_cv.rds\"))\n\nsummary(pcr_model)\n\n#calculate MSE\nmean((pcr_model[[\"residuals\"]])^2)\nset.seed(123)\nrequire(caret)\nrequire(pls)\n\ntrControl <- trainControl(method = \"cv\", number = 10, selectionFunction = \"oneSE\")\n\n# Base de datos original con los la variable respuesta \ndf <- data.frame(PC = PC_SEP$PC) %>% \n       cbind(., sep_mun %>%\n                 select(3:ncol(sep_mun)))\n\n# Split the data into training and test set\ninTraining <- createDataPartition(df$PC, p = .75, list = FALSE)\ntraining <- df[ inTraining,]\ntesting  <- df[-inTraining,]\n\n# Build the model on training set\ncaret.pcr <- train(PC~., \n                   data = training,\n                   method = \"pcr\",\n                   preProcess = c(\"center\", \"scale\"),\n                   trControl = trControl, \n                   tuneGrid = data.frame(ncomp = 1:ncomp))\n\nsaveRDS(caret.pcr, paste0(here::here(), \"/Output/Municipio/caret_pcr_sep_cv.rds\"))\n#use model to make predictions on a test set\npcr_pred <- predict(caret.pcr, testing)\n# Calculate MSE \nmean((pcr_pred - testing$PC)^2)\n# Calculate RMSE \n#sqrt(mean((pcr_pred - testing$PC)^2))\nRMSE = caret::RMSE(pcr_pred, testing$PC)\n# Summary of accurracy \npostResample(pred = pcr_pred, obs = testing$PC)"},{"path":"municipio-4.html","id":"salud","chapter":"Municipio","heading":"Salud","text":"","code":"\nload(paste0(here::here(), \"/Bases/Municipio/Indicadores_CLUES.RData\"))\n\nclues_mun <- clues_mun %>%\n              mutate(suma = rowSums(.[3:6])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_CLUES <- PCA(clues_mun[, c(3:6)],\n                  scale.unit = TRUE, \n                   ncp = ncol(clues_mun[, c(3:6)]),\n                    graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 1\n\n# Índices de las componentes principales seleccionados\nPC_CLUES <-  clues_mun %>%\n              select(CVE_MUN) %>%\n               mutate(PC = as.numeric(scale(as.matrix(clues_mun[, c(3:6)])) %*% \n                                       as.matrix(PCA_CLUES[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_CLUES[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_CLUES,  file = paste0(here::here(), \"/Output/Municipio/PC_CLUES.Rdata\"))"},{"path":"municipio-4.html","id":"valores-extremos-2","chapter":"Municipio","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_CLUES$PC~., data = clues_mun[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_clues.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_mun[,c(3:6)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_mun[,c(3:6)])\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nsave(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_CLUES.RData\"))\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Municipio/PCR_CLUES.txt\"), sep = \",\")"},{"path":"municipio-4.html","id":"validación-cruzada-2","chapter":"Municipio","heading":"Validación Cruzada","text":"Mean Squared Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}\\]\n- Root Mean Squared Prediction Error RMSE\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}}\\]La función postResample puede utilizarse para estimar el error cuadrático medio (RMSE), el R2 simple y el error absoluto medio (MAE) para resultados numéricos.Mean Absolute Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left|Y_{}- \\hat{Y}_{}\\right|^{2}\\]","code":"\nncomp <- length(clues_mun[, c(3:6)])\n# Validación Cruzada \n\npcr_model <- pcr(PC_CLUES$PC~., data = clues_mun[, c(3:6)], \n                 ncomp = ncomp,  \n                 scale = TRUE, \n                 center = TRUE, \n                 validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Municipio/pcr_model_clues_cv.rds\"))\n\nsummary(pcr_model)\n\n#calculate MSE\nmean((pcr_model[[\"residuals\"]])^2)\nset.seed(123)\nrequire(caret)\nrequire(pls)\n\ntrControl <- trainControl(method = \"cv\", number = 10, selectionFunction = \"oneSE\")\n\n# Base de datos original con los la variable respuesta \ndf <- data.frame(PC = PC_CLUES$PC) %>% \n       cbind(., clues_mun %>%\n                 select(3:ncol(clues_mun)))\n\n# Split the data into training and test set\ninTraining <- createDataPartition(df$PC, p = .75, list = FALSE)\ntraining <- df[ inTraining,]\ntesting  <- df[-inTraining,]\n\n# Build the model on training set\ncaret.pcr <- train(PC~., \n                   data = training,\n                   method = \"pcr\",\n                   preProcess = c(\"center\", \"scale\"),\n                   trControl = trControl, \n                   tuneGrid = data.frame(ncomp = 1:ncomp))\n\nsaveRDS(caret.pcr, paste0(here::here(), \"/Output/Municipio/caret_pcr_clues_cv.rds\"))\n#use model to make predictions on a test set\npcr_pred <- predict(caret.pcr, testing)\n# Calculate MSE \nmean((pcr_pred - testing$PC)^2)\n# Calculate RMSE \n#sqrt(mean((pcr_pred - testing$PC)^2))\nRMSE = caret::RMSE(pcr_pred, testing$PC)\n# Summary of accurracy \npostResample(pred = pcr_pred, obs = testing$PC)#> Data:    X dimension: 1846 4 \n#>  Y dimension: 1846 1\n#> Fit method: svdpc\n#> Number of components considered: 4\n#> TRAINING: % variance explained\n#>           1 comps  2 comps  3 comps  4 comps\n#> X           80.15    92.26     97.7      100\n#> .outcome   100.00   100.00    100.0      100"},{"path":"municipio-4.html","id":"accesibilidad","chapter":"Municipio","heading":"Accesibilidad","text":"Índice de accesibilidadDistribución del índice de accesibilidad nivel municipal\n","code":"\nload(paste0(here::here(), \"/Bases/Municipio/IA_municipio.Rdata\"))"},{"path":"municipio-4.html","id":"calidad-del-entorno","chapter":"Municipio","heading":"Calidad del entorno","text":"MGNDENUESe excluyen los subsistemas de Educación y Salud.SEPCLUES** Índice de accesibilidad nivel municipio**Integración del ICEImputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos que puede obtener cada subsistema, calculados por el método de componentes principales. Siendo estos los valores extremos (falta de equipamiento), este valor se formuló utilizando Principal Component Regresion (PCR) y de esta manera poder obtener el valor predictivo del valor mínimo.","code":"\nload(paste0(here::here(), \"/Bases/Municipio/MGN.RData\"))\nload(paste0(here::here(), \"/Output/Municipio/PC_IMM.Rdata\"))\n\nIMM <- PC_IMM %>%\n        rename(\"IMM\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\nIndicadores <- names(Subsitemas)\n\nload(paste0(here::here(), \"/Output/Municipio/PC_DENUE.Rdata\"))\n\ntabla <- NULL\nfor(i in 1:11){\n  if(i %in% 1){\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_mun %>% select(CVE_MUN), tabla_DENUE, by = c(\"CVE_MUN\"))\n  } else {\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_mun %>% select(CVE_MUN), tabla_DENUE, by = c(\"CVE_MUN\")) %>%\n                 select(.,2)\n  }\n}\n\nDENUE <- do.call(cbind.data.frame, tabla)\ncolnames(DENUE) <- c(\"CVE_MUN\", Indicadores)\nrm(tabla_DENUE)\nload(paste0(here::here(), \"/Output/Municipio/PC_SEP.RData\"))\nSEP <- PC_SEP %>%\n         rename(\"Educacion\" = \"PC\")\nload(paste0(here::here(), \"/Output/Municipio/PC_CLUES.RData\"))\nCLUES <- PC_CLUES %>%\n          rename(\"Salud\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Municipio/IA_municipio.Rdata\"))\nIAL <- accesibilidad_mun %>%\n         select(CVE_MUN, IAL) \nPCR_pred <- read.table(paste0(here::here(), \"/Output/Municipio/PCR_SEP.txt\"), header = TRUE, sep = \",\") %>% \n             rbind(.,read.table(paste0(here::here(), \"/Output/Municipio/PCR_CLUES.txt\"), header = TRUE, sep = \",\")) %>%\n              rbind(., read.table(paste0(here::here(), \"/Output/Municipio/PCR_DENUE.txt\"), header = TRUE, sep = \",\"))\nICE_2020 <- MGN_mun %>%\n             select(CVE_MUN) %>%\n              left_join(., IMM, by = c(\"CVE_MUN\")) %>%\n               left_join(., SEP, by = c(\"CVE_MUN\")) %>%\n                left_join(., CLUES, by = c(\"CVE_MUN\")) %>%\n                 left_join(., DENUE, by = c(\"CVE_MUN\")) %>% \n                  left_join(., IAL, by = c(\"CVE_MUN\")) %>% \n                   mutate_at(vars(2:16), as.numeric) \n\nICE_2020 <- ICE_2020 %>%\n                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),\n                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),\n                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),\n                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),\n                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),\n                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),\n                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),\n                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),\n                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),\n                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),\n                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),\n                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),\n                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)\n                       )"},{"path":"municipio-4.html","id":"método-de-distancias-dp_2","chapter":"Municipio","heading":"Método de Distancias \\(DP_2\\)","text":"José Bernardo Pena Trapero: Problemas de la medición del bienestar y conceptos afines (1977)Primeramente se define como es la entrada de los indicadores simples. Este tipo de método - Índice de marginación (Negativo) (Marginación baja (-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento + CLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de accesibilidad (Negativo) (Accesibilidad alta (cercanos cero) / Accesibilidad baja (Alejados del cero))Base de referenciaNota.- Se toma como base de referencia el valor del mínimo de cada\nindicador simple.Método de Distancia \\(DP_{2}\\)El modelo converge la cuarta iteración","code":"\nrequire(p2distance)\nICE_2020_data <- ICE_2020 %>%\n                   mutate(IMM = -1*.$IMM,\n                          IAL = -1*.$IAL)\nrequire(p2distance)\nminRV <- p2distance::makeReferenceVector(X = ICE_2020_data[-1], \n                                          reference_vector_function = 'min')\n##Calculo del Método de Distancias DP2\nind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), \n                       reference_vector = minRV, \n                        iterations = 50)\n#> [1] \"Iteration 1\"\n#> [1] \"Iteration 2\"\n#> [1] \"Iteration 3\"\nind_ice$iteration\n#> [1] 3\nICE_2020 <- cbind(ICE_2020, ind_ice[[\"p2distance\"]])\n\n# Se cambian los nombres de las columnas \nnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"ICE\")\n# Se identifican los outliers en el índice de calidad del entorno\n#boxplot.stats(DP2_2010$IM_2010)$out\noutliers <- boxplot.stats(ICE_2020$ICE)\n\n## Se crea un índice ficticio quitando los outliers   \nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],\n                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],\n                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) "},{"path":"municipio-4.html","id":"método-de-estratificación","chapter":"Municipio","heading":"Método de estratificación","text":"strata.cumrootf: cumulative root frequency method Dalenius \nHodges (1959)Nclass óptimo del método de Dalenius & Hodgealloc lista que especifica el esquema de asignación. La lista debe\ncontener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de\nasignación general (ver paquete de stratification). El valor\npredeterminado es la asignación de Neyman (q1 = q3 = 0.5 y q2 = 0)","code":"\nstart.time <- Sys.time()\n# Se define el coeficiente de variación a usar\ncoef.var <- 0.05\n\nDH_Municipio <- list()\ni <- 1\n  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)\n  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)\n  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)\n for (n in seq(5, 1000, 1)){\n   DH_Municipio[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)\n   cum <- DH_Municipio[[n]]\n   sd[i,] <-  c(n, cum$stderr, cum$CV)\n   meanh[i,] <- c(n, cum$meanh)\n   varh[i,] <-  c(n, cum$varh)\n   i <- i + 1\n}\n\ncolnames(sd) <- c(\"n\", \"sderr\", \"CV\")\ncolnames(meanh) <- c(\"nclass\", paste0(rep(\"Strata\", 5), 1:5))\ncolnames(varh) <- c(\"nclass\", paste0(rep(\"Strata\", 5), 1:5))\n\nend.time <- Sys.time()\ntime.taken <- round(end.time - start.time, 2)\ntime.taken\n\n#Se guardan los resultados de las iteraciones\nsave(sd, file = paste0(here::here(), \"/Output/Municipio/sd.Rdata\"))\nmin.strata <- sd %>%\n               as.data.frame() %>% \n                slice(which.min(.$CV))\nstrata.ice <- strata.cumrootf(ICE_2020$ICE_out,\n                               CV = 0.05,  ## Revisar que tenga el mismo CV\n                                Ls = 5,\n                                 alloc = c(0.5,0,0.5), \n                                  nclass = min.strata$n)\n\n## Se agrega a la base de datos\nICE_2020 <- ICE_2020 %>%\n              select(-ICE_out) %>%   # Se quita el índice ficticio\n                mutate(G.ICE = strata.ice[[\"stratumID\"]])\n\n\n# Se cambian los nombres de las columnas \ncolnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"G.ICE\")\n\n# Se cambian los levels de D&H\nlevels(ICE_2020$G.ICE) = c(\"Completa\", \"Grave\", \"Moderada\", \"Ligera\", \"No hay\")"},{"path":"municipio-4.html","id":"índice-normalizado","chapter":"Municipio","heading":"Índice normalizado","text":"Indice normalizadoEscenarios del mínimo y máximo valor en el índice DP2Se guarda la bases de Datos del ICE por municipio\nFigure 1: Elaboración propia\n","code":"\n# Desviación estandar de los indicadores\ndesvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%\n                       as.data.frame() %>%\n                        rename(\"desvest\" =\"V1\") %>%\n                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%\n                            mutate(desvest.inversa = 1/(.$sd_muestral))\n\n# Escenario mínimo\nvector_minimo <- as.matrix(minRV)\n\ntabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]\nminimo <- data.frame(Escenario = \"Mínimo\", tabla, DP2 = sum(tabla))\n\n# Escenario mínimo  \nvector_maximo <- p2distance::makeReferenceVector(ICE_2020_data[-1], reference_vector_function = 'max')\n\ntabla <- abs(vector_maximo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])] \n\nmaximo <- data.frame(Escenario = \"Máximo\", tabla, DP2 = sum(tabla))\n\n# Indice normalizado\nmin_DP2 <- minimo$DP2[1]\nmax_DP2 <- maximo$DP2[1]\n\nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2))\n\n# Se guarda el índice de calidad del entorno normalizado\nsave(ICE_2020, file = paste0(here::here(), \"/Bases/Municipio/ICE_2020.RData\"))"},{"path":"localidad-4.html","id":"localidad-4","chapter":"Localidad","heading":"Localidad","text":"Se toma como referencia el marco geoestadístico nacional 2020 nivel localidad. El cúal cuenta con 189 432 localidades para el año 2020.","code":"\nload(paste0(here::here(), \"/Bases/Localidad/MGN.Rdata\"))"},{"path":"localidad-4.html","id":"marginación-1","chapter":"Localidad","heading":"Marginación","text":"Se vuelve reestructurar la base de datos nivel localidad 2020, donde los principales cambios que se hacen:\n- Se agregan esas localidades con el margen de error mayores al 90%.\n- En la base publicada del índice de marginación nivel localidad. Se excluyeron aquellas localidades que presentaban algún cálculo en uno de los indicadores. Pero en este caso se incluyen todas las localidades, para que puedan coincidir con los datos oficiales del INEGI para el Censo de Población y Vivienda 2020.Al final del cálculo se van desplegar las localidades menores 2 viviendas particulares, en las cuales están agrupadas nivel municipal. Finalmente puedan ser usadas en el ICE.Bases de datosSe carga la nueva base del índice de marginación 2020.Para el cálculo de los componentes principales depende de las unidades de medida empleadas en las variables. Por lo que es importante, antes de aplicar PCA, estandarizar los indicadores simples para que tengan media 0 y desviación estándar 1, ya que, de lo contrario, las variables con mayor varianza dominarían al resto, aunque en el caso en que las variables estén medidas en las mismas unidades, podemos optar por estandarizarlas. La estandarización se lleva cabo restando cada observación la media y dividiendo entre la desviación estándar de la variable la que pertenece:\\[Z_{}=\\frac{x_{}-\\bar{x}}{\\sigma_{}}\\]Se utiliza la función \\(PCA\\) del parquete FactoMiner, donde se\nespecifica que se estandaricen las vairables con el parámetro\nscale.unit=TRUEAnálisis de componentes principalesSe utilizan todas las variablesEs importante seleccionar que gráficos se pueden incluir en el análisisSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumuladaPor otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos través de descomposición de valores singulares (SVD) de la matriz de datos.\\[\\mathbf X = \\mathbf U \\mathbf S \\mathbf V^\\top\\] - Segundo, desde el punto de vista PCA que requiere el cálculo de los valores propios y\nlos vectores propios, haciendo la descomposición propia de \\(\\mathbf X \\mathbf X^{T}\\).\\[\\mathbf X \\mathbf V = \\mathbf U \\mathbf S \\mathbf V^\\top \\mathbf V = \\mathbf U \\mathbf S\\]Donde - \\(\\mathbf V\\) son los eigenvectors - \\(\\mathbf U\\) es la matriz unitaria - \\(\\mathbf S\\) es la traza de los eigenvaluesLas columnas de \\(\\mathbf {US}\\) son los pesos de las componentes principalesSe generan los índices de cada uno de los subsistemas Se utilizan\nlos componentes principales que expliquen el máximo de la informaciónSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.Resumen","code":"\nload(paste0(here::here(), \"/Bases/Localidad/IML.Rdata\"))\nPCA_IML <- PCA(IML[, c(2:ncol(IML))],\n                 scale.unit = TRUE, \n                  ncp = ncol(IML[, c(2:ncol(IML))]),\n                   graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 4\n\n# Índices de las componentes principales seleccionados\nPC_IML <-  IML %>%\n            select(CVE_LOC) %>%\n             mutate(PC = as.numeric(scale(as.matrix(IML[,c(2:ncol(IML))])) %*% \n                                     as.matrix(PCA_IML[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                      as.matrix(PCA_IML[[\"eig\"]][,2][1:ncp]/100))) %>%\n              as.data.frame()\nsave(PC_IML, file = paste0(here::here(), \"/Output/Localidad/PC_IML.Rdata\"))"},{"path":"localidad-4.html","id":"equipamiento-2","chapter":"Localidad","heading":"Equipamiento","text":"Claves económicas","code":""},{"path":"localidad-4.html","id":"denue-2","chapter":"Localidad","heading":"DENUE","text":"Se anexan los indicadores simples, de acuerdo la clasificación económica del DENUE (01)Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUESubramosSe toman como referencia 13 subsitemas económicos y 64 elementos\neconómicos que lo integranIntegrarlo en una base de datos para saturar la página webDimensiones de cálculoAnálisis de componentes principales","code":"\nload(paste0(here::here(), \"/Bases/Localidad/Indicadores_DENUE.RData\"))\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\ntablas <- names(Subsitemas)\nfor(i in 1:11){\nassign(paste0(\"tabla_\",tablas[i]), denue_loc %>%\n                                     ungroup() %>%\n                                      select(CVE_LOC, Subsitemas[[paste(tablas[i])]]) %>%\n                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%\n                                        mutate(suma = as.numeric(.$suma)) %>%\n                                          filter(.$suma != 0) %>%\n                                           select(-suma))\n}\nncp <- c(2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))\n\nPCA_Subsistemas <- NULL\nfor(i in 1:11){\n  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0(\"tabla_\", tablas[i]))[, c(2:ncol(get(paste0(\"tabla_\", tablas[i]))))], \n                                              scale.unit = TRUE, \n                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),\n                                                graph = FALSE) \n}\n# Índices de las componentes principales seleccionados\nPC_DENUE <- NULL\nfor(i in 1:11){\n  PC_DENUE[[i]] <- get(paste0(\"tabla_\", tablas[i]))[1] %>%\n                    select(CVE_LOC) %>%\n                     mutate(PC = scale(as.matrix(get(paste0(\"tabla_\", tablas[i]))[,-1])) %*% \n                                  as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"var\"]][[\"coord\"]][,1:ncp[i]]) %*% \n                                   as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"eig\"]][,2][1:ncp[i]]/100)) %>% \n                      as.data.frame()\n}\nsave(PC_DENUE, file = paste0(here::here(), \"/Output/Localidad/PC_DENUE.Rdata\"))"},{"path":"localidad-4.html","id":"valores-extremos-3","chapter":"Localidad","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\n## Se guardan los resultados \nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_denue.rds\"))\n\n## Caso máximo\npcr_pred_max <- NULL\nfor(i in 1:11){\n  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)\n  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), \".comp\"))\n}\n\n## Caso mínimos \npcr_pred_min <- NULL\nfor(i in 1:11){\n  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)\n}\n\n\npcr_extremos <- matrix(NA, nrow = 11, ncol = 3)\nfor(i in 1:11){\n  pcr_extremos[i, 1] <- paste(tablas[i])\n  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]\n  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]\n}\ncolnames(pcr_extremos) <- c(\"Indicadores\", \"Máximo\", \"Mínimo\")\n\nsave(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_DENUE.RData\"))\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_DENUE.txt\"), sep = \",\")"},{"path":"localidad-4.html","id":"validación-cruzada-3","chapter":"Localidad","heading":"Validación Cruzada","text":"Mean Squared Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}\\]\n- Root Mean Squared Prediction Error RMSE\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}}\\]La función postResample puede utilizarse para estimar el error cuadrático medio (RMSE), el R2 simple y el error absoluto medio (MAE) para resultados numéricos.Mean Absolute Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left|Y_{}- \\hat{Y}_{}\\right|^{2}\\]","code":"\n# Validación Cruzada \n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\nncomp <- length(get(paste0(\"tabla_\", tablas[i]))[-1]) \npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\", tablas[i]))[-1], ncomp = ncomp, scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_denue_cv.rds\"))\n\nsummary(pcr_model[[1]])\n\n#calculate MSE\nmean((pcr_model[[1]][[\"residuals\"]])^2)\nset.seed(123)\nrequire(caret)\nrequire(pls)\n\ntrControl <- trainControl(method = \"cv\", number = 10, selectionFunction = \"oneSE\") \n\n# Crear listas vacías para almacenar training y testing\ntraining_list <- list()\ntesting_list <- list()\n\ncaret.pcr <- lapply(1:11, function(x){\n                           # Crear el data frame original con la variable respuesta y predictores\n                           df <- data.frame(PC = PC_DENUE[[x]][, 2]) %>% \n                                  cbind(., get(paste0(\"tabla_\", tablas[x]))[-1])\n                          \n                          # Dividir los datos en conjuntos de entrenamiento y prueba\n                          inTraining <- createDataPartition(df$PC, p = .75, list = FALSE)\n                          training <- df[inTraining, ]\n                          testing <- df[-inTraining, ]\n                          \n                          # Almacenar los conjuntos de entrenamiento y prueba en las listas\n                          training_list[[x]] <<- training\n                          testing_list[[x]] <<- testing\n                          \n                          # Entrenar el modelo PCR usando caret\n                          caret_model <- train(PC ~ ., data = training, \n                                         method = \"pcr\",\n                                         preProcess = c(\"center\", \"scale\"),\n                                         trControl = trControl, \n                                         tuneGrid = data.frame(ncomp = 1:(ncol(training) - 1)))\n  \n  return(caret_model)\n                        \n})\n\nsaveRDS(caret.pcr, paste0(here::here(), \"/Output/Localidad/caret_pcr_denue_cv.rds\"))\nsaveRDS(training_list, paste0(here::here(), \"/Output/Localidad/caret_train_denue_cv.rds\"))\nsaveRDS(testing_list, paste0(here::here(), \"/Output/Localidad/caret_test_denue_cv.rds\"))\n#use model to make predictions on a test set\npcr_pred <- predict(caret.pcr[[5]], testing_list[[5]])\n# Calculate MSE \nmean((pcr_pred - testing_list[[5]]$PC)^2)\n# Calculate RMSE \n#sqrt(mean((pcr_pred - testing$PC)^2))\nRMSE = caret::RMSE(pcr_pred, testing_list[[5]]$PC)\n# Summary of accurracy \npostResample(pred = pcr_pred, obs = testing_list[[5]]$PC)"},{"path":"localidad-4.html","id":"educación-1","chapter":"Localidad","heading":"Educación","text":"Análisis de componentes principales","code":"\nload(paste0(here::here(), \"/Bases/Localidad/Indicadores_Escuelas_SEP.RData\"))\n\nsep_loc <- sep_loc %>%\n             mutate(suma = rowSums(.[3:11])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_SEP <- PCA(sep_loc[, c(3:11)],\n                scale.unit = TRUE, \n                 ncp = ncol(sep_loc[, c(3:11)]),\n                  graph = FALSE)\n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 4\n\n# Índices de las componentes principales seleccionados\nPC_SEP <-  sep_loc %>%\n            select(CVE_LOC) %>%\n             mutate(PC = as.numeric(scale(as.matrix(sep_loc[, c(3:11)])) %*% \n                     as.matrix(PCA_SEP[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                      as.matrix(PCA_SEP[[\"eig\"]][,2][1:ncp]/100))) %>%\n              as.data.frame()\n\nsave(PC_SEP,  file = paste0(here::here(), \"/Output/Localidad/PC_SEP.Rdata\"))"},{"path":"localidad-4.html","id":"valores-extremos-4","chapter":"Localidad","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_SEP$PC~., data = sep_loc[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"CV\", segments = 1000)\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_sep.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_loc[,c(3:11)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_loc[,c(3:11)])\npcr_pred_min <- predict(pcr_model, test)\n\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nsave(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_SEP.RData\"))\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_SEP.txt\"), sep = \",\")"},{"path":"localidad-4.html","id":"validación-cruzada-4","chapter":"Localidad","heading":"Validación Cruzada","text":"Mean Squared Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}\\]\n- Root Mean Squared Prediction Error RMSE\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}}\\]La función postResample puede utilizarse para estimar el error cuadrático medio (RMSE), el R2 simple y el error absoluto medio (MAE) para resultados numéricos.Mean Absolute Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left|Y_{}- \\hat{Y}_{}\\right|^{2}\\]","code":"\nncomp <- length(sep_loc[, c(3:11)])\n# Validación Cruzada \npcr_model <- pcr(PC_SEP$PC~., data = sep_loc[, c(3:11)], \n                 ncomp = ncomp,  \n                 scale = TRUE, \n                 center = TRUE, \n                 validation = \"CV\", \n                 segments = 1000)\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_sep_cv.rds\"))\n\nsummary(pcr_model)\n\n#calculate MSE\nmean((pcr_model[[\"residuals\"]])^2)\nset.seed(123)\nrequire(caret)\nrequire(pls)\n\ntrControl <- trainControl(method = \"cv\", number = 10, selectionFunction = \"oneSE\")\n\n# Base de datos original con los la variable respuesta \ndf <- data.frame(PC = PC_SEP$PC) %>% \n       cbind(., sep_loc %>%\n                 select(3:ncol(sep_loc)))\n\n# Split the data into training and test set\ninTraining <- createDataPartition(df$PC, p = .75, list = FALSE)\ntraining <- df[ inTraining,]\ntesting  <- df[-inTraining,]\n\n# Build the model on training set\ncaret.pcr <- train(PC~., \n                   data = training,\n                   method = \"pcr\",\n                   preProcess = c(\"center\", \"scale\"),\n                   trControl = trControl, \n                   tuneGrid = data.frame(ncomp = 1:ncomp))\n\nsaveRDS(caret.pcr, paste0(here::here(), \"/Output/Localidad/caret_pcr_sep_cv.rds\"))\n#use model to make predictions on a test set\npcr_pred <- predict(caret.pcr, testing)\n# Calculate MSE \nmean((pcr_pred - testing$PC)^2)\n# Calculate RMSE \n#sqrt(mean((pcr_pred - testing$PC)^2))\nRMSE = caret::RMSE(pcr_pred, testing$PC)\n# Summary of accurracy \npostResample(pred = pcr_pred, obs = testing$PC)"},{"path":"localidad-4.html","id":"salud-1","chapter":"Localidad","heading":"Salud","text":"","code":"\nload(paste0(here::here(), \"/Bases/Localidad/Indicadores_CLUES.RData\"))\n\nclues_loc <- clues_loc %>%\n               mutate(suma = rowSums(.[3:6])) %>%\n                 mutate(suma = as.numeric(.$suma)) %>%\n                  filter(.$suma != 0) %>%\n                    select(-suma)\nPCA_CLUES <- PCA(clues_loc[, c(3:6)],\n                  scale.unit = TRUE, \n                   ncp = ncol(clues_loc[, c(3:6)]),\n                    graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 2\n\n# Índices de las componentes principales seleccionados\nPC_CLUES <-  clues_loc %>%\n              select(CVE_LOC) %>%\n               mutate(PC = as.numeric(scale(as.matrix(clues_loc[, c(3:6)])) %*% \n                                       as.matrix(PCA_CLUES[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_CLUES[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_CLUES,  file = paste0(here::here(), \"/Output/Localidad/PC_CLUES.Rdata\"))"},{"path":"localidad-4.html","id":"caso-extremos","chapter":"Localidad","heading":"Caso extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_CLUES$PC~., data = clues_loc[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"CV\", segments = 1500)\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_clues.rds\"))\n\n## Caso máximo\ntest <- t(rep(100, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_loc[, c(3:6)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_loc[, c(3:6)])\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Salud\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nsave(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_CLUES.RData\"))\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/Localidad/PCR_CLUES.txt\"), sep = \",\")"},{"path":"localidad-4.html","id":"validación-cruzada-5","chapter":"Localidad","heading":"Validación Cruzada","text":"Mean Squared Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}\\]\n- Root Mean Squared Prediction Error RMSE\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{= 1}^{n}\\left(Y_{}- \\hat{Y}_{}\\right)^{2}}\\]La función postResample puede utilizarse para estimar el error cuadrático medio (RMSE), el R2 simple y el error absoluto medio (MAE) para resultados numéricos.Mean Absolute Error (MSE)\\[MSE = \\frac{1}{n}\\sum_{= 1}^{n}\\left|Y_{}- \\hat{Y}_{}\\right|^{2}\\]Índice de accesibilidad","code":"\nncomp <- length(clues_loc[, c(3:6)])\n# Validación Cruzada \n\npcr_model <- pcr(PC_CLUES$PC~., data = clues_loc[, c(3:6)], \n                 ncomp = ncomp,  \n                 scale = TRUE, \n                 center = TRUE, \n                 validation = \"CV\", \n                 segments = 1500)\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/Localidad/pcr_model_clues_cv.rds\"))\n\nsummary(pcr_model)\n\n#calculate MSE\nmean((pcr_model[[\"residuals\"]])^2)\nset.seed(123)\nrequire(caret)\nrequire(pls)\n\ntrControl <- trainControl(method = \"cv\", number = 10, selectionFunction = \"oneSE\")\n\n# Base de datos original con los la variable respuesta \ndf <- data.frame(PC = PC_CLUES$PC) %>% \n       cbind(., clues_loc %>%\n                 select(3:ncol(clues_loc)))\n\n# Split the data into training and test set\ninTraining <- createDataPartition(df$PC, p = .75, list = FALSE)\ntraining <- df[ inTraining,]\ntesting  <- df[-inTraining,]\n\n# Build the model on training set\ncaret.pcr <- train(PC~., \n                   data = training,\n                   method = \"pcr\",\n                   preProcess = c(\"center\", \"scale\"),\n                   trControl = trControl, \n                   tuneGrid = data.frame(ncomp = 1:ncomp))\n\nsaveRDS(caret.pcr, paste0(here::here(), \"/Output/Localidad/caret_pcr_clues_cv.rds\"))\n#use model to make predictions on a test set\npcr_pred <- predict(caret.pcr, testing)\n# Calculate MSE \nmean((pcr_pred - testing$PC)^2)\n# Calculate RMSE \n#sqrt(mean((pcr_pred - testing$PC)^2))\nRMSE = caret::RMSE(pcr_pred, testing$PC)\n# Summary of accurracy \npostResample(pred = pcr_pred, obs = testing$PC)\nload(paste0(here::here(), \"/Bases/Localidad/IA_localidad.Rdata\"))"},{"path":"localidad-4.html","id":"calidad-del-entorno-1","chapter":"Localidad","heading":"Calidad del entorno","text":"MGNMarginaciónLocalidades confidencialesPara la obtención de las localidades confidenciales se requirio agruparlas nivel municipal, lo que permitio poder contemplar el 100 por ciento de las localidades reconocidas en el marco geoestadístico.Se analizan 81 105 localidades confidencialesDENUESe excluyen los subsistemas de Educación y Salud.*SEPCLUESAccesibilidadIntegración del ICEImputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos\nque puede obtener cada subsistema, calculados por el método de\ncomponentes principales. Siendo estos los valores extremos (falta de\nequipamiento), este valor se formuló utilizando Principal Component\nRegresion (PCR) y de esta manera poder obtener el valor predictivo del\nvalor mínimo.Es importante determinar que sucede con las localidades que tienen cálculoJosé Bernardo Pena Trapero: Problemas de la medición del bienestar y conceptos afines (1977)Primeramente se define como es la entrada de los indicadores simples. Este tipo de método\n- Índice de marginación (Negativo) (Marginación baja (-Negativa) / Marginación alta (Positiva))\n- Índice de equipamiento\n+ CLUES (Postivo)\n+ SEP (Postivo)\n+ DENUE (Positivo)\n- Indice de accesibilidad (Negativo)Base de referenciaNota.- Se toma como base de referencia el valor del mínimo de cada\nindicador simple.\nTable 1: Tabla: Base de referencia nivel localidad\nMétodo de Distancia \\(DP_{2}\\)El modelo converge la cuarta iteración","code":"\nload(paste0(here::here(), \"/Bases/Localidad/MGN.RData\")) \nload(paste0(here::here(), \"/Output/Localidad/PC_IML.Rdata\"))\nload(file = paste0(here::here(), \"/Bases/Localidad/Loc_Confidenciales_Claves.Rdata\"))\n\nIML <- PC_IML %>%\n           filter(substr(.$CVE_LOC,6,9) != '9999') %>%\n            rbind(., Loc_Confidenciales %>% select(CVE_LOC, PC)) \n\nIML <- IML %>%\n           rename(\"IML\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\nIndicadores <- names(Subsitemas)\n\nload(paste0(here::here(), \"/Output/Localidad/PC_DENUE.Rdata\"))\n\ntabla <- NULL\nfor(i in 1:11){\n  if(i %in% 1){\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_loc %>% select(CVE_LOC), tabla_DENUE, by = c(\"CVE_LOC\"))\n  } else {\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_loc %>% select(CVE_LOC), tabla_DENUE, by = c(\"CVE_LOC\")) %>%\n                 select(.,2)\n  }\n}\n\nDENUE <- do.call(cbind.data.frame, tabla)\ncolnames(DENUE) <- c(\"CVE_LOC\", Indicadores)\nrm(tabla_DENUE)\nload(paste0(here::here(), \"/Output/Localidad/PC_SEP.RData\"))\n\nSEP <- PC_SEP %>%\n         rename(\"Educacion\" = \"PC\")\nload(paste0(here::here(), \"/Output/Localidad/PC_CLUES.RData\"))\n\nCLUES <- PC_CLUES %>%\n          rename(\"Salud\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Localidad/IA_localidad.Rdata\")) \n\nIAL <- accesibilidad_loc %>%\n         select(CVE_LOC, IAL) \nPCR_pred <- read.table(paste0(here::here(), \"/Output/Localidad/PCR_SEP.txt\"), header = TRUE, sep = \",\") %>% \n             rbind(.,read.table(paste0(here::here(), \"/Output/Localidad/PCR_CLUES.txt\"), header = TRUE, sep = \",\")) %>%\n              rbind(., read.table(paste0(here::here(), \"/Output/Localidad/PCR_DENUE.txt\"), header = TRUE, sep = \",\"))\nICE_2020 <- MGN_loc %>%\n             select(CVE_LOC, Indicadora) %>%\n              left_join(., IML, by = c(\"CVE_LOC\")) %>%\n               left_join(., SEP, by = c(\"CVE_LOC\")) %>%\n                left_join(., CLUES, by = c(\"CVE_LOC\")) %>%\n                 left_join(., DENUE, by = c(\"CVE_LOC\")) %>% \n                  left_join(., IAL, by = c(\"CVE_LOC\")) %>% \n                   mutate_at(vars(3:17), as.numeric)\n\nICE_2020 <- ICE_2020 %>%\n                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),\n                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),\n                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),\n                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),\n                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),\n                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),\n                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),\n                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),\n                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),\n                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),\n                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),\n                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),\n                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,\n                  mutate(IAL = ifelse(is.na(.$IAL) == TRUE, 810, .$IAL)) %>%\n                   mutate(Indicadora = case_when(nchar(.$Indicadora)>0 ~ .$Indicadora,\n                                                 is.na(.$IAL) ~ \"Sin localización en la red\",\n                                                 is.na(.$IML) ~ \"Sin cálculo de marginación\"))\ntable(ICE_2020$Indicadora)\n#> \n#>                              Localidad confindencial \n#>                                                81097 \n#> Localidad confindencial | Sin cálculo de marginación \n#>                                                    8 \n#>                           Sin cálculo de marginación \n#>                                                   32 \n#>                 Sin viviendas particulares habitadas \n#>                                                  148 \n#>      Tiene cálculo | Margén de error alto en IM_2020 \n#>                                                    3\nICE_2020 <- ICE_2020 %>%\n             filter(nchar(.$IML)> 0) %>%\n              select(., c(1, 3:17)) \nICE_2020_data <- ICE_2020 %>%\n                   mutate(IML = -1*.$IML,\n                          IAL = -1*.$IAL)\nminRV <- makeReferenceVector(X = ICE_2020_data[-1], \n                             reference_vector_function = 'min')\n#require(p2distance)\n##Calculo del Método de Distancias DP2\nind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), \n                       reference_vector = minRV, \n                        iterations = 50)\n#> [1] \"Iteration 1\"\n#> [1] \"Iteration 2\"\n#> [1] \"Iteration 3\"\nind_ice$iteration\n#> [1] 3\nICE_2020 <- cbind(ICE_2020, ind_ice[[\"p2distance\"]])\n\n# Se cambian los nombres de las columnas \nnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"ICE\")\n# Se identifican los outliers en el índice de calidad del entorno\n#boxplot.stats(DP2_2010$IM_2010)$out\noutliers <- boxplot.stats(ICE_2020$ICE)\n\n## Se crea un índice ficticio quitando los outliers   \nICE_2020 <- ICE_2020 %>%\n             mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],\n                                        .$ICE > outliers$stats[5] ~ outliers$stats[5],\n                                        .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) "},{"path":"localidad-4.html","id":"método-de-estratificación-1","chapter":"Localidad","heading":"Método de estratificación","text":"strata.cumrootf: cumulative root frequency method Dalenius Hodges (1959)Nclass óptimo del método de Dalenius & Hodgealloc lista que especifica el esquema de asignación. La lista debe\ncontener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de\nasignación general (ver paquete de stratification). El valor\npredeterminado es la asignación de Neyman (q1 = q3 = 0.5 y q2 = 0)","code":"\nstart.time <- Sys.time()\n# Se define el coeficiente de variación a usar\ncoef.var <- 0.05\n\nDH_Localidad <- list()\ni <- 1\n  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)\n  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)\n  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)\n for (n in seq(5, 1000, 1)){\n   DH_Localidad[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)\n   cum <- DH_Localidad[[n]]\n   sd[i,] <-  c(n, cum$stderr, cum$CV)\n   meanh[i,] <- c(n, cum$meanh)\n   varh[i,] <-  c(n, cum$varh)\n   i <- i + 1\n}\n\ncolnames(sd) <- c(\"n\",\"sderr\",\"CV\")\ncolnames(meanh) <- c(\"nclass\", paste0(rep(\"Strata\",5),1:5))\ncolnames(varh) <- c(\"nclass\",paste0(rep(\"Strata\",5),1:5))\n\nend.time <- Sys.time()\ntime.taken <- round(end.time - start.time, 2)\ntime.taken\n\n#Se guardan los resultados de las iteraciones\nsave(sd, file = paste0(here::here(), \"/Output/Localidad/sd.Rdata\"))\nmin.strata <- sd %>%\n               as.data.frame() %>% \n                slice(which.min(.$CV))\nstrata.ice <- strata.cumrootf(ICE_2020$ICE_out,\n                               CV = 0.05, \n                                Ls = 5,\n                                 alloc = c(0.5,0,0.5), \n                                  nclass = min.strata$n)\n\n## Se agrega a la base de datos\nICE_2020 <- ICE_2020 %>%\n              select(-ICE_out) %>%   # Se quita el índice ficticio\n                mutate(G.ICE = strata.ice[[\"stratumID\"]])\n\n\n# Se cambian los nombres de las columnas \ncolnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"G.ICE\")\n\n# Se cambian los levels de D&H\nlevels(ICE_2020$G.ICE) = c(\"Completa\", \"Grave\", \"Moderada\", \"Ligera\", \"No hay\")"},{"path":"localidad-4.html","id":"índice-normalizado-1","chapter":"Localidad","heading":"Índice normalizado","text":"Indice normalizadoEscenarios del mínimo y máximo valor en el índice DP2Se guarda la bases de Datos del ICE por Localidad\nFigure 2: Elaboración propia\n","code":"\n# Desviación estandar de los indicadores\ndesvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%\n                       as.data.frame() %>%\n                        rename(\"desvest\" =\"V1\") %>%\n                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%\n                            mutate(desvest.inversa = 1/(.$sd_muestral))\n\n# Escenario mínimo\nvector_minimo <- as.matrix(minRV)\n\ntabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]\nminimo <- data.frame(Escenario = \"Mínimo\", tabla, DP2 = sum(tabla))\n\n# Escenario mínimo  \nvector_maximo <- p2distance::makeReferenceVector(ICE_2020_data[-1], reference_vector_function = 'max')\n\ntabla <- abs(vector_maximo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])] \n\nmaximo <- data.frame(Escenario = \"Máximo\", tabla, DP2 = sum(tabla))\n\n# Indice normalizado\nmin_DP2 <- minimo$DP2[1]\nmax_DP2 <- maximo$DP2[1]\n\nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%\n               arrange(ICE_Norm)\n\n# Se guarda el índice de calidad del entorno normalizado\nsave(ICE_2020, file = paste0(here::here(), \"/Bases/Localidad/ICE_2020.RData\"))"},{"path":"ageb-3.html","id":"ageb-3","chapter":"AGEB","heading":"AGEB","text":"Se toma como referencia el marco geoestadístico nacional 2020 nivel localidad. El cúal cuenta con 61 439 AGEB’s para el año 2020.","code":"\nload(paste0(here::here(), \"/Bases/AGEB/MGN_ageb.Rdata\"))"},{"path":"ageb-3.html","id":"marginación-2","chapter":"AGEB","heading":"Marginación","text":"Se vuelve reestructurar la base de datos nivel AGEB 2020, donde los principales cambios que se hacen:\n- Se agregan esas AGEB con el margen de error mayores al 90%.\n- En la base publicada del índice de marginación nivel AGEB, Se excluyeron aquellas AGEB que presentaban algún cálculo en uno de los indicadores.\n- También se quita el filtro de 20 viviendas totales y se contempla el total de viviendas.Bases de datosSe carga la nueva base del índice de marginación 2020.Para el cálculo de los componentes principales depende de las unidades de medida empleadas en las variables. Por lo que es importante, antes de aplicar PCA, estandarizar los indicadores simples para que tengan media 0 y desviación estándar 1, ya que, de lo contrario, las variables con mayor varianza dominarían al resto, aunque en el caso en que las variables estén medidas en las mismas unidades, podemos optar por estandarizarlas. La estandarización se lleva cabo restando cada observación la media y dividiendo entre la desviación estándar de la variable la que pertenece:\\[Z_{}=\\frac{x_{}-\\bar{x}}{\\sigma_{}}\\]Se utiliza la función \\(PCA\\) del parquete FactoMiner, donde se especifica que se estandaricen las vairables con el parámetro scale.unit=TRUEAnálisis de componentes principalesSe utilizan todas las variablesEs importante seleccionar que gráficos se pueden incluir en el análisisSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumuladaPor otro lado se generan dos índices, de los cuales: - Uno se estandariza para explicarlos través de descomposición de valores singulares (SVD) de la matriz de datos.\\[\\mathbf X = \\mathbf U \\mathbf S \\mathbf V^\\top\\] - Segundo, desde el punto de vista PCA que requiere el cálculo de los valores propios y\nlos vectores propios, haciendo la descomposición propia de \\(\\mathbf X \\mathbf X^{T}\\).\\[\\mathbf X \\mathbf V = \\mathbf U \\mathbf S \\mathbf V^\\top \\mathbf V = \\mathbf U \\mathbf S\\]Donde - \\(\\mathbf V\\) son los eigenvectors - \\(\\mathbf U\\) es la matriz unitaria - \\(\\mathbf S\\) es la traza de los eigenvaluesLas columnas de \\(\\mathbf {US}\\) son los pesos de las componentes principalesSe generan los índices de cada uno de los subsistemas Se utilizan los componentes principales que expliquen el máximo de la informaciónSe utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.Resumen\nTable 2: Tabla: Resumen de los indicadores de marginación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/IMU.Rdata\"))#>  [1] \"CVE_AGEB\" \"P6A14NAE\" \"PSBASC\"   \"PSDSS\"    \"OVSDE\"    \"OVSEE\"   \n#>  [7] \"OVSAE\"    \"OVPT\"     \"OVSREF\"   \"OVSINT\"   \"OVSCEL\"   \"OVHAC\"\nPCA_IMU <- PCA(IMU[, c(2:ncol(IMU))],\n               scale.unit = TRUE, \n                ncp = ncol(IMU[, c(2:ncol(IMU))]),\n                 graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 6\n\n# Índices de las componentes principales seleccionados\nPC_IMU <-  IMU %>%\n              select(CVE_AGEB) %>%\n               mutate(PC = as.numeric(scale(as.matrix(IMU[,c(2:ncol(IMU))])) %*% \n                                       as.matrix(PCA_IMU[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_IMU[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\nsave(PC_IMU, file = paste0(here::here(), \"/Output/AGEB/PC_IMU.Rdata\"))"},{"path":"ageb-3.html","id":"equipamiento-3","chapter":"AGEB","heading":"Equipamiento","text":"Claves económicas","code":""},{"path":"ageb-3.html","id":"denue-3","chapter":"AGEB","heading":"DENUE","text":"Se anexan los indicadores simples, de acuerdo la clasificación económica del DENUE (01)Se utiliza la nueva reclasificación de los subsitemas, de los cuales fueron obtenidos del DENUESubramosSe dividen los indicadores simples de acuerdo los 13 subsitemas económicosDimensiones de cálculo\nTable 3: Tabla: Dimensiones de cálculo\nAnálisis de componentes principales\nTable 4: Tabla: Resumen de los indicadores de asistencia social\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/Indicadores_DENUE.RData\"))\nload(paste0(here::here(), \"/Bases/Claves_subsistema_SCIAN2018.RData\"))\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\ntablas <- names(Subsitemas)\n\nfor(i in 1:11){\nassign(paste0(\"tabla_\",tablas[i]), denue_ageb %>%\n                                     ungroup() %>%\n                                      select(CVE_AGEB, Subsitemas[[paste(tablas[i])]]) %>%\n                                       mutate(suma = rowSums(.[2:length(Subsitemas[[paste(tablas[i])]])])) %>%\n                                        mutate(suma = as.numeric(.$suma)) %>%\n                                          filter(.$suma != 0) %>%\n                                           select(-suma))\n}\nncp <- c(2, 4, 2, 4, 4, 5, 2, 3, 5, 4, 1) %>% as.matrix() %>% `rownames<-`(.,paste(tablas))\n\nPCA_Subsistemas <- NULL\nfor(i in 1:11){\n  PCA_Subsistemas[[paste(tablas[i])]] <- PCA(get(paste0(\"tabla_\", tablas[i]))[, c(2:ncol(get(paste0(\"tabla_\", tablas[i]))))], \n                                              scale.unit = TRUE, \n                                               ncp =  length(Subsitemas[[paste(tablas[i])]]),\n                                                graph = FALSE) \n}\n# Índices de las componentes principales seleccionados\nPC_DENUE <- NULL\nfor(i in 1:11){\n  PC_DENUE[[i]] <- get(paste0(\"tabla_\", tablas[i]))[1] %>%\n                     select(CVE_AGEB) %>%\n                       mutate(PC = as.numeric(scale(as.matrix(get(paste0(\"tabla_\", tablas[i]))[,-1])) %*% \n                                               as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"var\"]][[\"coord\"]][,1:ncp[i]]) %*% \n                                                as.matrix(PCA_Subsistemas[[paste0(tablas[i])]][[\"eig\"]][,2][1:ncp[i]]/100))) %>%\n                        as.data.frame()\n}   \n\nsave(PC_DENUE, file = paste0(here::here(), \"/Output/AGEB/PC_DENUE.Rdata\"))"},{"path":"ageb-3.html","id":"valores-extremos-5","chapter":"AGEB","heading":"Valores extremos","text":"","code":"\nrequire(pls)\n## Principal Components Regression (PCR)\npcr_model <- NULL\nfor(i in 1:11){\npcr_model[[i]] <- pcr(PC_DENUE[[i]][,2]~., data = get(paste0(\"tabla_\",tablas[i]))[-1], ncomp = ncp[i],  scale = TRUE, center = TRUE, validation = \"LOO\")\n}\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/AGEB/pcr_model_denue.rds\"))\n## Caso máximo\npcr_pred_max <- NULL\nfor(i in 1:11){\n  test <- t(rep(100, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_max[[i]] <- predict(pcr_model[[i]], test)\n  names(pcr_pred_max[[i]]) <- c(paste0(seq(1, ncp[i]), \".comp\"))\n}\n\n## Caso mínimos \npcr_pred_min <- NULL\nfor(i in 1:11){\n  test <- t(rep(0, length(Subsitemas[[paste(tablas[i])]]))) %>% as.data.frame() \n  colnames(test) <- Subsitemas[[paste(tablas[i])]]\n  pcr_pred_min[[i]] <- predict(pcr_model[[i]], test)\n}\n\n\npcr_extremos <- matrix(NA, nrow = 11, ncol = 3)\nfor(i in 1:11){\n  pcr_extremos[i, 1] <- paste(tablas[i])\n  pcr_extremos[i, 2] <- pcr_pred_max[[i]][,1,][ncp[i]]\n  pcr_extremos[i, 3] <- pcr_pred_min[[i]][,1,][ncp[i]]\n}\ncolnames(pcr_extremos) <- c(\"Indicadores\", \"Máximo\", \"Mínimo\")\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_DENUE.txt\"), sep = \",\")"},{"path":"ageb-3.html","id":"educación-2","chapter":"AGEB","heading":"Educación","text":"Análisis de componentes principales\nTable 5: Tabla: Resumen de los indicadores de educación utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/Indicadores_Escuelas_SEP.RData\"))\n\nsep_ageb <- sep_ageb %>%\n             mutate(suma = rowSums(.[3:11])) %>%\n               mutate(suma = as.numeric(.$suma)) %>%\n                filter(.$suma != 0) %>%\n                  select(-suma)\nPCA_SEP <- PCA(sep_ageb[, c(3:11)],\n                scale.unit = TRUE, \n                 ncp = ncol(sep_ageb[, c(3:11)]),\n                  graph = FALSE)\n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 5\n\n# Índices de las componentes principales seleccionados\nPC_SEP <-  sep_ageb %>%\n              select(CVE_AGEB)  %>%\n               mutate(PC = as.numeric(scale(as.matrix(sep_ageb[, c(3:11)])) %*% \n                              as.matrix(PCA_SEP[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_SEP[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_SEP,  file = paste0(here::here(), \"/Output/AGEB/PC_SEP.Rdata\"))"},{"path":"ageb-3.html","id":"valores-extremos-6","chapter":"AGEB","heading":"Valores extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_SEP$PC~., data = sep_ageb[, c(3:11)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/AGEB/pcr_model_sep.rds\"))\n## Caso máximo\ntest <- t(rep(100, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_ageb[,c(3:11)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 9)) %>% as.data.frame() \ncolnames(test) <- names(sep_ageb[,c(3:11)])\npcr_pred_min <- predict(pcr_model, test)\n\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Educación\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_SEP.txt\"), sep = \",\")"},{"path":"ageb-3.html","id":"salud-2","chapter":"AGEB","heading":"Salud","text":"\nTable 6: Tabla: Resumen de los indicadores de salud utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/Indicadores_CLUES.RData\"))\n\nclues_ageb <- clues_ageb %>%\n               mutate(suma = rowSums(.[3:6])) %>%\n                 mutate(suma = as.numeric(.$suma)) %>%\n                  filter(.$suma != 0) %>%\n                    select(-suma)\nPCA_CLUES <- PCA(clues_ageb[, c(3:6)],\n                  scale.unit = TRUE, \n                   ncp = ncol(clues_ageb[, c(3:6)]),\n                    graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 3\n\n# Índices de las componentes principales seleccionados\nPC_CLUES <-  clues_ageb %>%\n              select(CVE_AGEB) %>%\n               mutate(PC = as.numeric(scale(as.matrix(clues_ageb[, c(3:6)])) %*% \n                                       as.matrix(PCA_CLUES[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_CLUES[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\n\nsave(PC_CLUES,  file = paste0(here::here(), \"/Output/AGEB/PC_CLUES.Rdata\"))"},{"path":"ageb-3.html","id":"caso-extremos-1","chapter":"AGEB","heading":"Caso extremos","text":"","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_CLUES$PC~., data = clues_ageb[, c(3:6)], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"LOO\")\n\nsaveRDS(pcr_model, paste0(here::here(), \"/Output/AGEB/pcr_model_clues.rds\"))\n## Caso máximo\ntest <- t(rep(100, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_ageb[, c(3:6)])\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0, 4)) %>% as.data.frame() \ncolnames(test) <- names(clues_ageb[, c(3:6)])\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Salud\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_CLUES.txt\"), sep = \",\")"},{"path":"ageb-3.html","id":"entorno-urbano-1","chapter":"AGEB","heading":"Entorno urbano","text":"Son 2852 casos que cuentan con alguna viviendas particulares habitadasSon 2760 casos que cuentan con población.Son 2852 casos que cuentan con alguna viviendas particulares habitadasSon 2760 casos que cuentan con población.Análisis de componentes principales\nTable 7: Tabla: Resumen de los indicadores de salud utilizando PCA\n","code":"\nload(paste0(here::here(), \"/Bases/AGEB/EU_ageb.RData\"))\n\nEU_ageb <- EU_ageb %>%\n            select(CVE_AGEB, PAVIM_ADOQ_N, S_RPEAT_N, S_RAUTO_N, C_PASOPEAT_N, C_DRENAJEP_N, C_TRANSCOL_N, C_CICLOVIA_N, C_CICLOCARRIL_N, C_LETRERO_N, C_RAMPA_N, C_SEMAFOROPEAT_N, C_SEMAFOROAUDI_N, C_PARADATRANS_N, C_ESTACIONBICI_N, C_ALUM_N, C_PSEMI_N, S_PAMBU_N, C_BANQ_N, C_GUAR_N)\nPCA_EU <- PCA(EU_ageb[, c(2:ncol(EU_ageb))],\n               scale.unit = TRUE, \n                  ncp = ncol(EU_ageb[,c(2:ncol(EU_ageb))]),\n                   graph = FALSE) \n# Índice estandarizado (SVD)\n# Componentes seleccionadas\nncp <- 7\n\n# Índices de las componentes principales seleccionados\nPC_EU <-  EU_ageb %>%\n              select(CVE_AGEB) %>%\n               mutate(PC = as.numeric(scale(as.matrix(EU_ageb[, c(2:ncol(EU_ageb))])) %*% \n                                       as.matrix(PCA_EU[[\"var\"]][[\"coord\"]][,1:ncp]) %*% \n                                        as.matrix(PCA_EU[[\"eig\"]][,2][1:ncp]/100))) %>%\n                 as.data.frame()\nsave(PC_EU,  file = paste0(here::here(), \"/Output/AGEB/PC_EU.Rdata\"))"},{"path":"ageb-3.html","id":"caso-extremos-2","chapter":"AGEB","heading":"Caso extremos","text":"Son 387 AGEB Urbanas que contienen cálculo de entorono urbano.\nSe anexan los indicadores sin cálculo de entorno urbano, el cual se les imputaron los valores nivel localidad y tres de ellos nivel municipal.Modelo predictivo\nSe une los datos imputados y los datos de entorno urbano por AGEB Urbana","code":"\n## Principal Components Regression (PCR)\npcr_model <- pcr(PC_EU$PC~., data = EU_ageb[, c(2:ncol(EU_ageb))], ncomp = ncp,  scale = TRUE, center = TRUE, validation = \"CV\", segments = 1000)\n\nsaveRDS(pcr_model, file = paste0(here::here(), \"/Output/AGEB/pcr_model_eu.rds\"))\n\n## Caso máximo\ntest <- t(rep(100,19)) %>% as.data.frame() \ncolnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])\n\npcr_pred_max <- predict(pcr_model, test)\n\n## Caso mínimos \ntest <- t(rep(0,19)) %>% as.data.frame() \ncolnames(test) <- names(EU_ageb[, c(2:ncol(EU_ageb))])\n\npcr_pred_min <- predict(pcr_model, test)\n\npcr_extremos <- data.frame(\"Indicadores\" = c(\"Entorno Urbano\"),\n                           \"Máximo\" = pcr_pred_max[,1,][ncp],\n                           \"Mínimo\" = pcr_pred_min[,1,][ncp]) \n\nwrite.table(pcr_extremos, file = paste0(here::here(), \"/Output/AGEB/PCR_EU.txt\"), sep = \",\")\nload(paste0(here::here(), \"/Output/AGEB/EU_imputacion.Rdata\"))\n# Modelo predictivo de los datos imputados\npcr_pred <- predict(pcr_model, EU_imputacion[-1]) \npcr_pred <- data.frame(CVE_AGEB = EU_imputacion$CVE_AGEB, PC = pcr_pred) %>%\n              select(., c(1, ncp + 1)) %>% \n               mutate(Indicadora = \"Datos imputados_Entorno Urbano\")\ncolnames(pcr_pred) <- c(\"CVE_AGEB\", \"PC\", \"Indicadora\")\n\nPC_EU <- PC_EU %>%\n          mutate(Indicadora = \"\") %>%\n           rbind(pcr_pred)\n\nsave(PC_EU, file = paste0(here::here(), \"/Output/AGEB/PC_EU.Rdata\"))           "},{"path":"ageb-3.html","id":"calidad-del-entorno-2","chapter":"AGEB","heading":"Calidad del entorno","text":"Marco Geoestadístico NacionalMarginaciónDENUESe excluyen los subsistemas de Educación y Salud.SEPCLUESEntorno UrbanoIntegración del ICEImputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos\nque puede obtener cada subsistema, calculados por el método de\ncomponentes principales. Siendo estos los valores extremos (falta de\nequipamiento), este valor se formuló utilizando Principal Component\nRegresion (PCR) y de esta manera poder obtener el valor predictivo del\nvalor mínimo.Integración del ICE Imputación de valores faltantesA los valores faltantes de equipamiento se les imputa el valor mínimos que puede obtener cada subsistema, calculados por el método de componentes principales. Siendo estos los valores extremos (falta de equipamiento), este valor se formuló utilizando Principal Component Regresion (PCR) y de esta manera poder obtener el valor predictivo del valor mínimo.Se anexan los datos la base MGNSon 387 observaciones que tiene cálculo del entorno urbanoEs importante determinar que sucede con las AGEB que tienen cálculo","code":"\nload(paste0(here::here(), \"/Bases/AGEB/MGN_ageb.Rdata\"))\nload(paste0(here::here(), \"/Output/AGEB/PC_IMU.Rdata\"))\n\nIMU <- PC_IMU %>%\n         rename(\"IMU\" = \"PC\")\nload(paste0(here::here(), \"/Bases/Subsistemas_DENUE.Rdata\"))\nIndicadores <- names(Subsitemas)\n\nload(paste0(here::here(), \"/Output/AGEB/PC_DENUE.Rdata\"))\n\ntabla <- NULL\nfor(i in 1:11){\n  if(i %in% 1){\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c(\"CVE_AGEB\"))\n  } else {\n  tabla_DENUE <- PC_DENUE[[i]]\n  tabla[[i]] <- left_join(MGN_ageb %>% select(CVE_AGEB), tabla_DENUE, by = c(\"CVE_AGEB\")) %>%\n                 select(.,2)\n  }\n}\n\nDENUE <- do.call(cbind.data.frame, tabla)\ncolnames(DENUE) <- c(\"CVE_AGEB\", Indicadores)\nrm(tabla_DENUE)\nload(paste0(here::here(), \"/Output/AGEB/PC_SEP.Rdata\"))\nSEP <- PC_SEP %>%\n         rename(\"Educacion\" = \"PC\")\nload(paste0(here::here(), \"/Output/AGEB/PC_CLUES.Rdata\"))\n\nCLUES <- PC_CLUES %>%\n          rename(\"Salud\" = \"PC\")\nload(paste0(here::here(), \"/Output/AGEB/PC_EU.Rdata\"))\n\nEU <- PC_EU %>%\n       rename(\"EU\" = \"PC\")\nPCR_pred <- read.table(paste0(here::here(), \"/Output/AGEB/PCR_SEP.txt\"), header = TRUE, sep = \",\") %>% \n             rbind(.,read.table(paste0(here::here(), \"/Output/AGEB/PCR_CLUES.txt\"), header = TRUE, sep = \",\")) %>%\n              rbind(., read.table(paste0(here::here(), \"/Output/AGEB/PCR_DENUE.txt\"), header = TRUE, sep = \",\"))\nICE_2020 <- MGN_ageb %>%\n             select(CVE_AGEB) %>%\n              left_join(., IMU, by = c(\"CVE_AGEB\")) %>%\n               left_join(., SEP, by = c(\"CVE_AGEB\")) %>%\n                left_join(., CLUES, by = c(\"CVE_AGEB\")) %>%\n                 left_join(., DENUE, by = c(\"CVE_AGEB\")) %>% \n                  left_join(., EU, by = c(\"CVE_AGEB\")) %>% \n                   mutate_at(vars(2:16), as.numeric)\n\nICE_2020 <- ICE_2020 %>%\n                mutate(Educacion = ifelse(is.na(.$Educacion) == TRUE, PCR_pred[1, 3], .$Educacion),\n                       Salud = ifelse(is.na(.$Salud) == TRUE, PCR_pred[2, 3], .$Salud),\n                       Cultura = ifelse(is.na(.$Cultura) == TRUE, PCR_pred[3, 3], .$Cultura),\n                       Asistencia_social = ifelse(is.na(.$Asistencia_social) == TRUE, PCR_pred[4, 3], .$Asistencia_social),\n                       Comercio =  ifelse(is.na(.$Comercio ) == TRUE, PCR_pred[5, 3], .$Comercio ),\n                       Comunicaciones = ifelse(is.na(.$Comunicaciones) == TRUE, PCR_pred[6, 3], .$Comunicaciones),\n                       Transporte = ifelse(is.na(.$Transporte) == TRUE, PCR_pred[7, 3], .$Transporte),\n                       Deporte_Recreacion = ifelse(is.na(.$Deporte_Recreacion) == TRUE, PCR_pred[8, 3], .$Deporte_Recreacion),\n                       Administracion_publica = ifelse(is.na(.$Administracion_publica) == TRUE, PCR_pred[9, 3], .$Administracion_publica),\n                       Servicios_urbanos = ifelse(is.na(.$Servicios_urbanos) == TRUE, PCR_pred[10, 3], .$Servicios_urbanos),\n                       Servicios_financieros = ifelse(is.na(.$Servicios_financieros) == TRUE, PCR_pred[11, 3], .$Servicios_financieros),\n                       Hoteleria_Restaurantes = ifelse(is.na(.$Hoteleria_Restaurantes) == TRUE, PCR_pred[12, 3], .$Hoteleria_Restaurantes),\n                       Talleres = ifelse(is.na(.$Talleres) == TRUE, PCR_pred[13, 3], .$Talleres)) %>%  # Se sustituyen los vacios por ceros,\n                   mutate(Indicadora = case_when(is.na(.$IMU) ~ \"Sin cálculo de marginación\",\n                                                 is.na(.$EU) ~ \"Sin cálculo de entorno urbano\", \n                                                 .$Indicadora == \"Datos imputados_Entorno Urbano\" ~ \"Datos imputados_Entorno Urbano\"))\ntable(ICE_2020$Indicadora)\n#> \n#> Datos imputados_Entorno Urbano     Sin cálculo de marginación \n#>                            385                             31\nICE_2020 <- ICE_2020 %>%\n             filter(is.na(.$Indicadora)  | .$Indicadora == \"Datos imputados_Entorno Urbano\") %>%\n              select(-Indicadora) "},{"path":"ageb-3.html","id":"método-de-distancias-dp_2-1","chapter":"AGEB","heading":"Método de Distancias \\(DP_2\\)","text":"José Bernardo Pena Trapero:\nProblemas de la medición del bienestar y conceptos afines (1977)Primeramente se define como es la entrada de los indicadores simples.\nEste tipo de método - Índice de marginación (Negativo) (Marginación baja\n(-Negativa) / Marginación alta (Positiva)) - Índice de equipamiento +\nCLUES (Postivo) + SEP (Postivo) + DENUE (Positivo) - Indice de\naccesibilidad (Negativo) (Accesibilidad alta (cercanos cero) /\nAccesibilidad baja (Alejados del cero))Base de referenciaNota.- Se toma como base de referencia el valor del mínimo de cada\nindicador simple.\nTable 8: Tabla: Base de referencia nivel AGEB\nMétodo de Distancia \\(DP_{2}\\)El modelo converge la cuarta iteración","code":"\nICE_2020_data <- ICE_2020 %>%\n                   mutate(IMU = -1*.$IMU)\nminRV <- makeReferenceVector(X = ICE_2020_data[2:16], \n                             reference_vector_function = 'min')\nminRV\n#>            IMU  Educacion      Salud    Cultura Asistencia_social   Comercio\n#> [1,] -16.68513 -0.6404264 -0.3372863 -0.3508965        -0.2722898 -0.4698561\n#>      Comunicaciones Transporte Deporte_Recreacion Administracion_publica\n#> [1,]     -0.2825618 -0.4771963         -0.3112705             -0.3907859\n#>      Servicios_urbanos Servicios_financieros Hoteleria_Restaurantes  Talleres\n#> [1,]        -0.4844911            -0.2213161              -0.344338 -0.738592\n#>             EU\n#> [1,] -3.187468\n##Calculo del Método de Distancias DP2\nind_ice <- p2distance(matriz = as.matrix(ICE_2020_data[-1]), \n                       reference_vector = minRV, \n                        iterations = 50)\n#> [1] \"Iteration 1\"\n#> [1] \"Iteration 2\"\n#> [1] \"Iteration 3\"\nind_ice$iteration\n#> [1] 3\nICE_2020 <- cbind(ICE_2020, ind_ice[[\"p2distance\"]])\n\n# Se cambian los nombres de las columnas \nnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"ICE\")\n# Se identifican los outliers en el índice de calidad del entorno\n#boxplot.stats(DP2_2010$IM_2010)$out\noutliers <- boxplot.stats(ICE_2020$ICE)\n\n## Se crea un índice ficticio quitando los outliers   \nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_out = case_when(.$ICE < outliers$stats[1] ~ outliers$stats[1],\n                                         .$ICE > outliers$stats[5] ~ outliers$stats[5],\n                                         .$ICE >= outliers$stats[1] | .$ICE <= outliers$stats[5] ~ .$ICE)) "},{"path":"ageb-3.html","id":"método-de-estratificación-2","chapter":"AGEB","heading":"Método de estratificación","text":"strata.cumrootf: cumulative root frequency method Dalenius Hodges (1959)Nclass óptimo del método de Dalenius & Hodgealloc lista que especifica el esquema de asignación. La lista debe contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de asignación general (ver paquete de stratification). El valor predeterminado es la asignación de Neyman (q1 = q3 = 0.5 y q2 = 0)Indice normalizadoEscenarios del mínimo y máximo valor en el índice DP2Se guarda la bases de Datos del ICE por municipio","code":"\nstart.time <- Sys.time()\n# Se define el coeficiente de variación a usar\ncoef.var <- 0.05\n\nDH_AGEB <- list()\ni <- 1\n  sd <- matrix(NA, nrow = (1000 - 4), ncol = 3)\n  meanh <- matrix(NA, nrow = (1000 - 4), ncol = 6)\n  varh <- matrix(NA, nrow=(1000 - 4), ncol = 6)\n for (n in seq(5, 1000, 1)){\n   DH_AGEB[[n]] <- strata.cumrootf(x = ICE_2020$ICE_out, CV = coef.var , Ls = 5, alloc = c(0.5,0,0.5), nclass = n)\n   cum <- DH_AGEB[[n]]\n   sd[i,] <-  c(n, cum$stderr, cum$CV)\n   meanh[i,] <- c(n, cum$meanh)\n   varh[i,] <-  c(n, cum$varh)\n   i <- i + 1\n}\n\ncolnames(sd) <- c(\"n\",\"sderr\",\"CV\")\ncolnames(meanh) <- c(\"nclass\", paste0(rep(\"Strata\",5),1:5))\ncolnames(varh) <- c(\"nclass\",paste0(rep(\"Strata\",5),1:5))\n\nend.time <- Sys.time()\ntime.taken <- round(end.time - start.time, 2)\ntime.taken\n\n#Se guardan los resultados de las iteraciones\nsave(sd, file = paste0(here::here(), \"/Output/AGEB/sd.Rdata\"))\nmin.strata <- sd %>%\n               as.data.frame() %>% \n                slice(which.min(.$CV))\nstrata.ice <- strata.cumrootf(ICE_2020$ICE_out,\n                               CV = 0.05, \n                                Ls = 5,\n                                 alloc = c(0.5,0,0.5), \n                                  nclass = min.strata$n)\n\n## Se agrega a la base de datos\nICE_2020 <- ICE_2020 %>%\n              select(-ICE_out) %>%   # Se quita el índice ficticio\n                mutate(G.ICE = strata.ice[[\"stratumID\"]])\n\n\n# Se cambian los nombres de las columnas \ncolnames(ICE_2020) = c(colnames(ICE_2020)[1:(ncol(ICE_2020)-1)], \"G.ICE\")\n\n# Se cambian los levels de D&H\nlevels(ICE_2020$G.ICE) = c(\"Completa\", \"Grave\", \"Moderada\", \"Ligera\", \"No hay\")\n# Desviación estandar de los indicadores\ndesvest <- as.matrix(apply(ICE_2020[2:16], MARGIN = 2, sd)) %>%\n                       as.data.frame() %>%\n                        rename(\"desvest\" =\"V1\") %>%\n                          mutate(sd_muestral = .$desvest *(sqrt((dim(ICE_2020[2:16])[1] -1)/dim(ICE_2020[2:16])[1]))) %>%\n                            mutate(desvest.inversa = 1/(.$sd_muestral))\n\n# Escenario mínimo\nvector_minimo <- as.matrix(minRV)\n\ntabla <- abs(vector_minimo - minRV)* desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]\nminimo <- data.frame(Escenario = \"Mínimo\", tabla, DP2 = sum(tabla))\n\n\n# Escenario máximo\nvector_maximo <-  c(apply(ICE_2020_data[2:15], 2, max), \n                      IEU = 80.7211704737366)\n\ntabla <- abs(vector_maximo - minRV)*desvest$desvest.inversa *\n           ind_ice[[\"correction_factors\"]][names(ICE_2020[,c(2:16)])]  %>%\n             as.data.frame() \nmaximo <- data.frame(Escenario = \"Máximo\", tabla, DP2 = sum(tabla))\n\n# Indice normalizado\nmin_DP2 <- minimo$DP2[1]\nmax_DP2 <- maximo$DP2[1]\n\nICE_2020 <- ICE_2020 %>%\n              mutate(ICE_Norm = (max_DP2 - .$ICE) / (max_DP2 - min_DP2)) %>%\n               arrange(ICE_Norm)\n\n# Se guarda el índice de calidad del entorno normalizado\nsave(ICE_2020, file = paste0(here::here(), \"/Bases/AGEB/ICE_2020.RData\"))"},{"path":"criterios-de-validación.html","id":"criterios-de-validación","chapter":"Criterios de validación","heading":"Criterios de validación","text":"En este apartado se desglozaran todos los criterios que se usaron para validar los datos.","code":""},{"path":"criterios-de-validación.html","id":"municipio-5","chapter":"Criterios de validación","heading":"Municipio","text":"Se utilizó como criterio los gráficos de sedimentación y la contriución de la variables en cada uno de los componentes y la varianza acumulada.\nContribución de las variables\n\n","code":""},{"path":"criterios-de-validación.html","id":"localidad-5","chapter":"Criterios de validación","heading":"Localidad","text":"","code":""},{"path":"criterios-de-validación.html","id":"ageb-4","chapter":"Criterios de validación","heading":"AGEB","text":"","code":""},{"path":"discusión.html","id":"discusión","chapter":"Discusión","heading":"Discusión","text":"","code":""},{"path":"anexos-cobamex-cif.html","id":"anexos-cobamex-cif","chapter":"Anexos (COBAMEX-CIF)","heading":"Anexos (COBAMEX-CIF)","text":"En este apartado vamos ir encontrando todas las anotaciones para mi tesis.Trabajo aplicativoÍndice de calidad del entornoPROYECTO de Norma Oficial Mexicana PROY-NOM-039-SSA-2023, en materia de Certificación de la Discapacidad.HistoriaReferenciasTérminosLas personas con discapacidad en México: una visión censal","code":""},{"path":"anexos-cobamex-cif.html","id":"componentes-de-la-clasificación-internacional-del-funcionamiento-de-la-discapacidad-y-de-la-salud.","chapter":"Anexos (COBAMEX-CIF)","heading":"Componentes de la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud.","text":"Componentes que interactúan de acuerdo al enfoque integrador biopsicosocial. Inician con una condición de salud y posteriormente se subdividen en dos partes:Parte 1 se ocupa del funcionamiento y la discapacidad y dentro de ésta están las funciones y estructuras corporales y actividad y participación.Parte 2 se ocupa de los factores contextuales, donde se encuentran los factores ambientales y los factores personales. Para la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud, versión para la infancia y la adolescencia, es el mismo modelo. Para una valoración integral se deben considerar todos los componentes tal como se muestra en la figura.\nFigura 1. Interacción de componentes de la CIF\n","code":""},{"path":"anexos-cobamex-cif.html","id":"generalidades","chapter":"Anexos (COBAMEX-CIF)","heading":"Generalidades","text":"Para fines sanitarios la Secretaría de Salud (SS) es responsable del diseño del certificado de discapacidad, alineado lo establecido en los tratados internacionales de los que México forma parte, entre los que destaca la Convención sobre los Derechos de las Personas con Discapacidad (CDPD) y adoptar la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud (CIF).En este sentido, toda persona que lo solicite y posterior al proceso de valoración se le debe extender un Certificado Electrónico de Discapacidad (CEDis) en términos de lo plasmado en el Capítulo 7 de esta Norma.La Secretaría de Salud (SS), través de la Dirección General de Información en Salud (DGIS), es responsable de elaborar, difundir y vigilar la normatividad para los procesos de diseño, captación, integración, procesamiento y difusión de las estadísticas en salud, entre la que se encuentra la relacionada con discapacidad.Todo personal de la salud o relacionado con la salud que participe en la valoración de la discapacidad, así como el profesional de la medicina o persona autorizada por la autoridad sanitaria para la expedición del Certificado Electrónico de Discapacidad (CEDis), debe estar capacitado en este proceso de acuerdo al enfoque integrador biopsicosocial y en apego la Convención sobre los Derechos de las Personas con Discapacidad (CDPD) y la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud (CIF).Los datos personales y sensibles que se obtengan derivado del proceso de valoración y certificación de la discapacidad en cualquiera de sus apartados deben tratarse de conformidad con las disposiciones aplicables en materia de Transparencia, Acceso la Información y Protección de Datos Personales.Expedición del Certificado Electrónico de Discapacidad","code":""},{"path":"anexos-cobamex-cif.html","id":"concordancia-con-normas-mexicanas-e-internacionales","chapter":"Anexos (COBAMEX-CIF)","heading":"Concordancia con normas mexicanas e internacionales","text":"Esta norma tiene concordancia con los tratados internacionales de los que México forma parte, los cuales son:11.1.1. Convención sobre los Derechos de las Personas con Discapacidad11.1.2 Clasificación Internacional del Funcionamiento, de la Discapacidad y de la SaludCuestionarios para la evaluación17 de agosto de 2022Aprobado en la tercera reunión extraordinaria del CTESS\n","code":""},{"path":"marcos-normativos.html","id":"marcos-normativos","chapter":"Marcos Normativos","heading":"Marcos Normativos","text":"","code":""},{"path":"marcos-normativos.html","id":"proy-nom-039-ssa-2023","chapter":"Marcos Normativos","heading":"PROY-NOM-039-SSA-2023","text":"","code":""},{"path":"marcos-normativos.html","id":"de-diciembre-de-2006","chapter":"Marcos Normativos","heading":"13 de diciembre de 2006","text":"","code":""},{"path":"marcos-normativos.html","id":"la-asamblea-general-de-las-naciones-unidas-aprobó-la-convención-sobre-los-derechos-delas-personas-con-discapacidad.","chapter":"Marcos Normativos","heading":"La Asamblea General de las Naciones Unidas aprobó la Convención sobre los Derechos delas Personas con Discapacidad.","text":"La cual tiene como objetivo principal cambiar el paradigma, al pasar de un modelo en el que las personas con discapacidad son tratadas como objeto de tratamiento médico, caridad y protección social un modelo en el que las personas con discapacidad son reconocidas como titulares de derechos humanos, activas en las decisiones que influyen en su vida y capacitadas para reivindicar sus derechosAsamblea General de las Naciones Unidas. (2006). Convención sobre los Derechos de las Personas con Discapacidad. Naciones Unidas.","code":""},{"path":"marcos-normativos.html","id":"de-marzo-de-2007","chapter":"Marcos Normativos","heading":"30 de marzo de 2007","text":"México firmó la Convención y ratificó su Protocolo Facultativo, misma que fue confirmada por la Cámara de Senadores el 27 de septiembre de 2007 y promulgada en el Diario Oficial de la Federación (DOF) el 2 de mayo de2008, convirtiéndose así en parte de los Estados comprometidos proteger y promover los derechos y la dignidad de las personas con discapacidad, con miras una sociedad mundial inclusiva;Diario Oficial de la Federación. (2008, 2 de mayo). Convención sobre los Derechos de las Personas con Discapacidad. México: Secretaría de Gobernación.","code":""},{"path":"marcos-normativos.html","id":"de-julio-de-2018","chapter":"Marcos Normativos","heading":"12 de julio de 2018,","text":"Se publicó en el DOF el Decreto por el que se reforman y adicionan diversas disposiciones de la Ley General para la Inclusión de las Personas con Discapacidad, de la Ley General de Salud y de la Ley General de Población. En su segundo transitorio establece que el Sector Salud deberá publicar e implementar la Norma Oficial Mexicana en materia de Certificación de la Discapacidad. Esta NOM deberá elaborarse de acuerdo con los tratados internacionales de los que México forma parte y adoptar la Clasificación Internacional del Funcionamiento, la Discapacidad y la Salud;","code":""},{"path":"marcos-normativos.html","id":"reglamento-interior-de-la-secretaría-de-salud","chapter":"Marcos Normativos","heading":"Reglamento Interior de la Secretaría de Salud","text":"El artículo 24, fracciones VI y VII. La Dirección General de Información en Salud (DGIS), coordina el funcionamiento del Centro Mexicano para la Clasificación de Enfermedades (CEMECE) y promueve y vigila el adecuado uso de clasificaciones internacionales de la Organización Mundial de la Salud;Secretaría de Salud. (s.f.). Reglamento Interior de la Secretaría de Salud, artículo 24, fracciones VI y VII.","code":""},{"path":"marcos-normativos.html","id":"ley-de-infraestructura-de-la-calidad","chapter":"Marcos Normativos","heading":"Ley de Infraestructura de la Calidad","text":"Que establece que las Normas Oficiales Mexicanas tienen como fin esencial el fomento de la calidad para el desarrollo económico y la protección de los objetivos legítimos de interés público como la protección y promoción la salud, mediante el establecimiento de reglas, denominación, especificaciones o características aplicables un bien, producto, proceso o servicio, así como aquéllas relativas terminología, marcado o etiquetado y de información;Se requiere contar con un documento de certificación con un enfoque integrador biopsicosocial, por lo cual, es prioritario unificar la metodología de valoración, registro, formatos y presentación de datos para la mejor toma de decisiones en salud pública y cubrir las necesidades de la población.Secretaría de Economía. (2018). Ley de Infraestructura de la Calidad. Diario Oficial de la Federación, 1 de julio de 2018.","code":""},{"path":"marcos-normativos.html","id":"el-comité-consultivo-nacional-de-normalización-de-salud-pública","chapter":"Marcos Normativos","heading":"El Comité Consultivo Nacional de Normalización de Salud Pública","text":"Aprobó en la Primera Sesión Ordinaria de 2023, la publicación del Proyecto de Norma Oficial Mexicana,\nPROY-NOM-039-SSA-2023","code":""},{"path":"marcos-normativos.html","id":"ley-general-de-salud","chapter":"Marcos Normativos","heading":"Ley General de Salud","text":"Artículos 389, fracción Ter, 389 Bis 2 y 389 Bis 3, establece que para fines sanitarios se extenderán, entre otros certificados, el de Discapacidad, el cual será expedido conforme la legislación vigente y acorde con los tratados internacionales de los que México forme parte, por las personas profesionales de la medicina o persona autorizada por la autoridad sanitaria.Secretaría de Salud. (s.f.). Ley General de Salud, Artículos 389, fracción Ter, 389 Bis 2 y 389 Bis 3.","code":""},{"path":"marcos-normativos.html","id":"objetivo-y-campo-de-aplicación","chapter":"Marcos Normativos","heading":"Objetivo y campo de aplicación","text":"Esta Norma tiene por objeto establecer los criterios, procesos y metodología para la certificación de la discapacidad bajo el enfoque integrador biopsicosocial, alineado los tratados internacionales de los que México forma parte en materia de derechos humanos, y la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud, así como el otorgamiento de la impresión del Certificado Electrónico de Discapacidad la persona solicitante.Esta Norma es de observancia obligatoria en todo el territorio nacional para los integrantes del Sistema Nacional de Salud que cuenten con Centros de valoración y expedición de Certificado Electrónico\nde Discapacidad.","code":""},{"path":"marcos-normativos.html","id":"referencias-normativas","chapter":"Marcos Normativos","heading":"Referencias normativas","text":"Para la correcta aplicación de esta Norma, es necesario consultar las siguientes Normas Oficiales Mexicanas o las que las sustituyan:","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-004-ssa3-2012-del-expediente-clínico.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-004-SSA3-2012, Del expediente clínico.","text":"La Norma Oficial Mexicana NOM-004-SSA3-2012 regula la elaboración, integración, uso y conservación del expediente clínico en el Sistema Nacional de Salud. Es de cumplimiento obligatorio para todos los profesionales de la salud y tiene como objetivo principal garantizar la calidad y continuidad de la atención médica. Define los componentes esenciales del expediente clínico, como la historia clínica, notas médicas y de enfermería, y reportes de estudios de laboratorio. Además, establece las responsabilidades de los proveedores de servicios de salud respecto la confidencialidad y protección de la información en los expedientes clínicos.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-005-ssa3-2018-que-establece-los-requisitos-mínimos-de-infraestructura-y-equipamiento-de-establecimientos-para-la-atención-médica-de-pacientes-ambulatorios.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-005-SSA3-2018, Que establece los requisitos mínimos de infraestructura y equipamiento de establecimientos para la atención médica de pacientes ambulatorios.","text":"La Norma Oficial Mexicana NOM-005-SSA3-2018 establece los requisitos mínimos de infraestructura y equipamiento que deben cumplir los establecimientos para la atención médica de pacientes ambulatorios. Esta norma es de carácter obligatorio y tiene como objetivo asegurar que los servicios de salud proporcionados pacientes ambulatorios sean de alta calidad y se realicen en condiciones adecuadas. La norma detalla las especificaciones necesarias para las instalaciones físicas, el equipo médico, y otros recursos necesarios para la operación eficiente y segura de estos establecimientos. Además, busca garantizar la seguridad y bienestar tanto de los pacientes como del personal de salud que labora en dichos centros.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-007-ssa2-2016-para-la-atención-de-la-mujer-durante-el-embarazo-parto-y-puerperio-y-dela-persona-recién-nacida.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-007-SSA2-2016, Para la atención de la mujer durante el embarazo, parto y puerperio, y dela persona recién nacida.","text":"La Norma Oficial Mexicana NOM-007-SSA2-2016 establece los criterios y procedimientos para la atención de la mujer durante el embarazo, parto y puerperio, así como la atención del recién nacido. Su objetivo principal es garantizar la calidad y seguridad en la atención médica proporcionada mujeres embarazadas y recién nacidos. La norma incluye especificaciones sobre el manejo clínico, la infraestructura y el equipamiento necesario en los establecimientos de salud. También aborda la capacitación del personal y la implementación de protocolos para prevenir y manejar complicaciones durante el embarazo y el parto, con el fin de reducir la mortalidad materna y neonatal.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-008-segob-2015-personas-con-discapacidad.---acciones-de-prevención-y-condiciones-de-seguridad-en-materia-de-protección-civil-en-situación-de-emergencia-o-desastre.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-008-SEGOB-2015, Personas con discapacidad. - Acciones de prevención y condiciones de seguridad en materia de protección civil en situación de emergencia o desastre.","text":"La Norma Oficial Mexicana NOM-008-SEGOB-2015 establece acciones de prevención y condiciones de seguridad en materia de protección civil para personas con discapacidad en situaciones de emergencia o desastre. Su objetivo es garantizar la seguridad y bienestar de las personas con discapacidad mediante la implementación de medidas específicas que faciliten su evacuación, rescate y atención en contextos de emergencia. La norma detalla las responsabilidades de las autoridades y los procedimientos que deben seguirse para proteger este grupo vulnerable, asegurando que se tomen en cuenta sus necesidades especiales en planes y operaciones de protección civil.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-015-ssa3-2012-para-la-atención-integral-de-personas-con-discapacidad.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-015-SSA3-2012, Para la atención integral de personas con discapacidad.","text":"La Norma Oficial Mexicana NOM-015-SSA3-2012 se enfoca en la atención integral de personas con discapacidad. Establece los criterios y procedimientos necesarios para garantizar una atención de calidad, segura y adecuada para este grupo poblacional. La norma detalla las responsabilidades de los profesionales de la salud y las especificaciones sobre la infraestructura y equipamiento necesarios para brindar una atención óptima. Además, busca asegurar que se respeten los derechos humanos de las personas con discapacidad, fomentando su inclusión y bienestar en el sistema de salud.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-016-ssa3-2012-que-establece-las-características-mínimas-de-infraestructura-y-equipamiento-de-hospitales-y-consultorios-de-atención-médica-especializada.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-016-SSA3-2012, Que establece las características mínimas de infraestructura y equipamiento de hospitales y consultorios de atención médica especializada.","text":"La Norma Oficial Mexicana NOM-016-SSA3-2012 establece las características mínimas de infraestructura y equipamiento que deben cumplir los hospitales y consultorios de atención médica especializada. Su objetivo es garantizar que estos establecimientos proporcionen servicios de salud de alta calidad y en condiciones adecuadas. La norma especifica los requisitos necesarios para las instalaciones físicas, el equipo médico y otros recursos esenciales para la operación eficiente y segura de estos centros. Además, busca asegurar la seguridad y el bienestar tanto de los pacientes como del personal de salud.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-024-ssa3-2012-sistemas-de-información-de-registro-electrónico-para-la-salud.-intercambio-de-información-en-salud.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-024-SSA3-2012, Sistemas de información de registro electrónico para la salud. Intercambio de información en salud.","text":"La Norma Oficial Mexicana NOM-024-SSA3-2012 establece los criterios y procedimientos para la implementación de sistemas de información de registro electrónico para la salud. Su objetivo principal es garantizar el intercambio eficiente y seguro de información en el sector salud, facilitando la interoperabilidad entre los diferentes sistemas y plataformas utilizados por los proveedores de servicios de salud. La norma define los estándares técnicos y operativos que deben cumplir estos sistemas para asegurar la calidad, confidencialidad y protección de los datos de los pacientes. Además, busca mejorar la continuidad y coordinación de la atención médica, optimizando los procesos administrativos y clínicos.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-025-ssa2-2014-para-la-prestación-de-servicios-de-salud-en-unidades-de-atención-integral-hospitalaria-médico-psiquiátrica.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-025-SSA2-2014, Para la prestación de servicios de salud en unidades de atención integral hospitalaria médico-psiquiátrica.","text":"La Norma Oficial Mexicana NOM-025-SSA2-2014 establece los lineamientos y requisitos para la prestación de servicios de salud en unidades de atención integral hospitalaria médico-psiquiátrica. Su objetivo principal es garantizar la calidad, seguridad y adecuación de los servicios proporcionados pacientes que requieren atención médico-psiquiátrica en un entorno hospitalario. La norma define las especificaciones necesarias para la infraestructura, el equipamiento y el personal especializado en estas unidades, así como los procedimientos clínicos y administrativos que deben seguirse para asegurar una atención integral y efectiva los pacientes con trastornos mentales.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-030-ssa3-2013-que-establece-las-características-arquitectónicas-para-facilitar-el-acceso-tránsito-uso-y-permanencia-de-las-personas-con-discapacidad-en-establecimientos-para-la-atención-médica-ambulatoria-y-hospitalaria-del-sistema-nacional-de-salud.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-030-SSA3-2013, Que establece las características arquitectónicas para facilitar el acceso, tránsito, uso y permanencia de las personas con discapacidad en establecimientos para la atención médica ambulatoria y hospitalaria del Sistema Nacional de Salud.","text":"La Norma Oficial Mexicana NOM-030-SSA3-2013 establece las características arquitectónicas que deben cumplir los establecimientos de atención médica ambulatoria y hospitalaria del Sistema Nacional de Salud para facilitar el acceso, tránsito, uso y permanencia de las personas con discapacidad. Su objetivo es garantizar que los servicios de salud sean accesibles y adecuados para todos los pacientes, independientemente de sus capacidades físicas, promoviendo así la inclusión y equidad en la atención médica.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-034-ssa2-2013-para-la-prevención-y-control-de-los-defectos-al-nacimiento.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-034-SSA2-2013, Para la prevención y control de los defectos al nacimiento.","text":"La Norma Oficial Mexicana NOM-034-SSA2-2013 establece los lineamientos y procedimientos para la prevención y control de los defectos al nacimiento. Su objetivo principal es reducir la incidencia de defectos congénitos través de estrategias de vigilancia epidemiológica, promoción de la salud y atención médica especializada. La norma detalla las medidas preventivas, como la suplementación con ácido fólico, el diagnóstico prenatal y la educación para la salud, así como los protocolos de atención para los recién nacidos con defectos congénitos. Además, busca garantizar la coordinación entre los diferentes niveles del sistema de salud y promover la investigación y capacitación en este ámbito.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-nom-035-ssa3-2012-en-materia-de-información-en-salud.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana NOM-035-SSA3-2012, En materia de información en salud.","text":"La Norma Oficial Mexicana NOM-035-SSA3-2012 establece los criterios y procedimientos relacionados con la información en salud. Su objetivo principal es garantizar la calidad, disponibilidad, y confidencialidad de la información generada y utilizada en el sector salud. Esta norma busca asegurar que los datos de salud sean precisos y accesibles para mejorar la toma de decisiones, la planificación y la prestación de servicios de salud. Además, promueve la estandarización en la recolección y manejo de información para facilitar su intercambio entre diferentes entidades y sistemas dentro del Sistema Nacional de Salud.","code":""},{"path":"marcos-normativos.html","id":"norma-oficial-mexicana-proy-nom-039-ssa-2023-en-materia-de-certificación-de-la-discapacidad.","chapter":"Marcos Normativos","heading":"Norma Oficial Mexicana PROY-NOM-039-SSA-2023, en materia de Certificación de la Discapacidad.","text":"La Norma Oficial Mexicana NOM-039-SSA-2023 establece los criterios, procesos y metodología para la certificación de la discapacidad con un enfoque integrador biopsicosocial. Está alineada los tratados internacionales de derechos humanos y la Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud. Su objetivo es garantizar la emisión del Certificado Electrónico de Discapacidad las personas que lo soliciten. Es de observancia obligatoria en todo el territorio nacional para los integrantes del Sistema Nacional de Salud que cuenten con centros de valoración y expedición del certificado. Además, la norma se basa en diversas Normas Oficiales Mexicanas relacionadas con la atención médica, infraestructura, equipamiento y protección de personas con discapacidad.","code":""},{"path":"marcos-normativos.html","id":"referencias","chapter":"Marcos Normativos","heading":"Referencias","text":"Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-004-SSA3-2012, Del expediente clínico. Recuperado de https://www.dof.gob.mx/nota_detalle.php?codigo=5272787&fecha=15/10/2012 (consultado el 29 de julio de 2024)Diario Oficial de la Federación. (2018, 24 de enero). Norma Oficial Mexicana NOM-005-SSA3-2018, Que establece los requisitos mínimos de infraestructura y equipamiento de establecimientos para la atención médica de pacientes ambulatorios. Recuperado de https://www.dof.gob.mx/nota_detalle.php?codigo=5518805&fecha=24/01/2018 (consultado el 29 de julio de 2024)Diario Oficial de la Federación. (2016, 7 de abril). Norma Oficial Mexicana NOM-007-SSA2-2016, Para la atención de la mujer durante el embarazo, parto y puerperio, y de la persona recién nacida. Recuperado de https://www.dof.gob.mx/nota_detalle.php?codigo=5432287&fecha=07/04/2016Diario Oficial de la Federación. (2015, 24 de marzo). Norma Oficial Mexicana NOM-008-SEGOB-2015, Personas con discapacidad. - Acciones de prevención y condiciones de seguridad en materia de protección civil en situación de emergencia o desastre. Recuperado de https://www.dof.gob.mx/nota_detalle.php?codigo=5383010&fecha=24/03/2015Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-015-SSA3-2012, Para la atención integral de personas con discapacidad. México: Secretaría de Salud.Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-016-SSA3-2012, Que establece las características mínimas de infraestructura y equipamiento de hospitales y consultorios de atención médica especializada. México: Secretaría de Salud.Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-024-SSA3-2012, Sistemas de información de registro electrónico para la salud. Intercambio de información en salud. Recuperado de [URL] (consultado el 29 de julio de 2024)Diario Oficial de la Federación. (2014, 20 de marzo). Norma Oficial Mexicana NOM-025-SSA2-2014, Para la prestación de servicios de salud en unidades de atención integral hospitalaria médico-psiquiátrica. México: Secretaría de Salud.Diario Oficial de la Federación. (2013, 23 de octubre). Norma Oficial Mexicana NOM-030-SSA3-2013, Que establece las características arquitectónicas para facilitar el acceso, tránsito, uso y permanencia de las personas con discapacidad en establecimientos para la atención médica ambulatoria y hospitalaria del Sistema Nacional de Salud. Recuperado de [URL] (consultado el 29 de julio de 2024)Diario Oficial de la Federación. (2013, 24 de octubre). Norma Oficial Mexicana NOM-034-SSA2-2013, Para la prevención y control de los defectos al nacimiento. Recuperado de [URL] (consultado el 29 de julio de 2024)Diario Oficial de la Federación. (2012, 15 de octubre). Norma Oficial Mexicana NOM-035-SSA3-2012, En materia de información en salud. México: Secretaría de Salud.Diario Oficial de la Federación. (2024, 2 de febrero). Proyecto de Norma Oficial Mexicana PROY-NOM-039-SSA-2023, en materia de Certificación de la Discapacidad. Recuperado de https://dof.gob.mx/nota_detalle.php?codigo=5715918&fecha=02/02/2024#gsc.tab=0 (consultado el 29 de julio de 2024)","code":""},{"path":"históricos.html","id":"históricos","chapter":"Históricos","heading":"Históricos","text":"","code":""},{"path":"históricos.html","id":"ámbito-internacional-internacional","chapter":"Históricos","heading":"Ámbito Internacional (Internacional)","text":"","code":""},{"path":"históricos.html","id":"panorama-de-la-discapacidad-a-nivel-internacional-desde-sus-inicios-hasta-la-actualidad","chapter":"Históricos","heading":"Panorama de la Discapacidad a Nivel Internacional: Desde sus Inicios hasta la Actualidad","text":"","code":""},{"path":"históricos.html","id":"antigüedad","chapter":"Históricos","heading":"Antigüedad:","text":"En el Antiguo Egipto, la evidencia artística sugiere la presencia e integración de individuos con discapacidades en la estructura social, asignándoles roles funcionales específicos (Metzler, 2013). En contraste, la Grecia clásica exhibió prácticas eugenésicas, incluyendo el abandono de infantes con discapacidades en el monte Taigeto (Rocha, 2001). La Roma antigua presentó actitudes duales, desde el infanticidio y la explotación de personas con deformidades para entretenimiento, hasta la fundación del primer nosocomio por San Basilio en el año 370 (Aguado, 1993). La China Antigua, por su parte, demostró un enfoque médico temprano, con descripciones y tratamientos de diversas discapacidades documentados en textos de la dinastía Han (Lo, 2000).","code":""},{"path":"históricos.html","id":"edad-media","chapter":"Históricos","heading":"Edad Media:","text":"El mundo árabe medieval experimentó un avance significativo en la medicina, con hospitales como el Bimaristán en Bagdad que proporcionaban tratamientos especializados para diversas discapacidades (Savage-Smith, 1996). En la Europa medieval, las personas con discapacidades fueron frecuentemente objeto de caridad cristiana, lo que condujo la creación de instituciones benéficas y hospitales (Aguado, 1993). obstante, también persistió una tradición demonológica que asociaba las discapacidades con la posesión diabólica, aunque el humanitarismo cristiano impulsó la fundación de sanatorios y hospitales (Aguado, 1993).","code":""},{"path":"históricos.html","id":"renacimiento-y-edad-moderna","chapter":"Históricos","heading":"Renacimiento y Edad Moderna:","text":"El Renacimiento marcó un cambio hacia un enfoque más científico y racional de la discapacidad, con figuras como Paracelso y Vesalio que contribuyeron la comprensión médica (Porter, 1997). El siglo XVIII, con la Ilustración, introdujo ideales de igualdad que influyeron en la creación de instituciones educativas especializadas para personas sordas y ciegas, como se evidenció durante la Revolución Francesa (Lane, 1984).","code":""},{"path":"históricos.html","id":"siglo-xx","chapter":"Históricos","heading":"Siglo XX:","text":"Las Guerras Mundiales resultaron en un aumento sustancial de personas con discapacidades, lo que impulsó el desarrollo de tecnologías de rehabilitación (Harrison, 2000). En 1920, Estados Unidos promulgó la Ley Smith-Fess, iniciando programas de rehabilitación vocacional. El movimiento por los derechos civiles en la segunda mitad del siglo XX abogó por los derechos de las personas con discapacidades, culminando en la promulgación de la Ley de Estadounidenses con Discapacidades (ADA) en 1990 (Scotch, 2001). La Declaración Universal de Derechos Humanos (1948) y la Clasificación Internacional de Deficiencias, Discapacidades y Minusvalías (CIDDM) de la OMS (1980) establecieron marcos para la igualdad y la comprensión de la discapacidad. El Año Internacional de las Personas con Discapacidad (1981) y las Normas Uniformes de la ONU (1993) promovieron la sensibilización y la acción global.","code":""},{"path":"históricos.html","id":"siglo-xxi","chapter":"Históricos","heading":"Siglo XXI:","text":"La Clasificación Internacional del Funcionamiento, de la Discapacidad y de la Salud (CIF) de 2001 adoptó un enfoque holístico y multidimensional de la discapacidad. La Convención sobre los Derechos de las Personas con Discapacidad (CDPD) de 2006 representó un hito al establecer un tratado internacional para proteger los derechos y la dignidad de las personas con discapacidades. Los Objetivos de Desarrollo Sostenible (ODS) de 2015 incluyeron metas específicas para la inclusión de las personas con discapacidades en la educación y el empleo.\nReferencias\n- Metzler, Irina. (2013). Disability Medieval Europe: Thinking Physical Impairment High Middle Ages, c. 1100–1400. Routledge.\n- Rocha, Arturo (2001). Nadie es ombligo en la tierra. Ayac xictli tlaltícpac. Discapacidad en el México antiguo, Cultura náhuatl. TELETON, Editorial Miguel Ángel Porrúa. México.\n- Aguado Díaz, Antonio León (1993). Historia de las Deficiencias. Colección Tesis y Praxis. Escuela Libre Editorial, Fundación . Madrid, España.\n- Porter, G.L. (1997). Critical Elements Inclusive Schools. En: Pijl, S.J., Meijer, C.J.W., y Hegerty, S. (Eds.) Inclusive Education, Global Agenda. London : Routledge Publishing.\n- Baynton, Douglas C. (2016), “Disability History”, Disability Studies Quarterly, 28 (3), available : http://dsq-sds.org/article/view/108/108.\n- Harrison, Mark. (2000). Medical War: British Military Medicine First World War. Oxford University Press.\n- Lo, V. (2000). Influence Buddhism Chinese Medicine. H. T. Barrett (Ed.), Chinese medicine healing: illustrated history (pp. 112-137). Harvard University Press.\n- Savage-Smith, E. (1996). Attitudes toward dissection medieval Islam. Journal history medicine allied sciences, 50(1), 67–110. https://doi.org/10.1093/jhmas/50.1.67\n- Lane, Harlan. (1984). Mind Hears: History Deaf. New York: Random House.\n- Rose, Sarah F. ‘“Crippled” Hands: Disability Labor Working-Class History’, Labor 2:1 (2003), 27–54.\n- Scotch, Richard K. (2001). Good Civil Rights: Transforming Federal Disability Policy. Temple University Press.\n- Instituto Nacional de Estadística, Geografía e Informática (INEGI). (2000). Las personas con discapacidad en México: una visión censal.","code":""},{"path":"históricos.html","id":"ámbito-nacional-méxico","chapter":"Históricos","heading":"Ámbito Nacional (México)","text":"","code":""},{"path":"históricos.html","id":"panorama-de-la-discapacidad-a-nivel-nacional-en-méxico-desde-sus-inicios-hasta-la-actualidad","chapter":"Históricos","heading":"Panorama de la Discapacidad a Nivel Nacional en México: Desde sus Inicios hasta la Actualidad","text":"","code":""},{"path":"históricos.html","id":"época-prehispánica-en-méxico","chapter":"Históricos","heading":"Época Prehispánica en México","text":"En la época prehispánica, las culturas indígenas de México, como la náhuatl, tenían diversas formas de interpretar y tratar las discapacidades. Las enfermedades y deficiencias eran frecuentemente asociadas razones naturales, castigos divinos, maleficios o influencias astrológicas. Los códices Florentino y Badiano documentan prácticas terapéuticas complejas, incluyendo el uso de herbolaria y otros tratamientos.","code":""},{"path":"históricos.html","id":"colonia-en-méxico","chapter":"Históricos","heading":"Colonia en México","text":"Durante la colonia, la atención las personas con discapacidades comenzó institucionalizarse. En 1566, se fundó el Hospital de San Hipólito en Ciudad de México, el primer hospital en el continente dedicado enfermedades mentales. En 1698, José Sáyago fundó el Real Hospital del Divino Salvador, también dedicado enfermedades mentales. En 1794, se establecieron el Hospital de Belén en Guadalajara y el Hospital Civil en Monterrey, ambos con secciones para atender personas con deficiencias mentales.","code":""},{"path":"históricos.html","id":"siglo-xix","chapter":"Históricos","heading":"Siglo XIX","text":"El siglo XIX vio avances significativos en la educación y atención personas con discapacidades. En 1861, Benito Juárez ordenó la creación de una escuela para sordomudos en la Ciudad de México, y en 1866, José Urbano Fonseca fundó dicha escuela. Estos esfuerzos marcaron el inicio de una mayor conciencia y acción hacia la inclusión educativa de personas con discapacidades.","code":""},{"path":"históricos.html","id":"siglo-xx-1","chapter":"Históricos","heading":"Siglo XX","text":"principios del siglo XX, se fundaron varias instituciones dedicadas personas con discapacidades en ciudades como Veracruz, Yucatán, Jalisco y Puebla. En 1928, se creó el Instituto Nacional de Protección la Infancia (INPI), precursor del Sistema Nacional para el Desarrollo Integral de la Familia (DIF). En 1970, se estableció el Instituto Nacional de Rehabilitación (INR) para proporcionar atención médica especializada y rehabilitación. En 1995, una reforma constitucional reconoció los derechos de las personas con discapacidades y estableció políticas públicas para su inclusión. En 1997, se creó la Fundación Teletón, que ofrece atención y rehabilitación través de sus Centros de Rehabilitación e Inclusión Infantil Teletón (CRIT).","code":""},{"path":"históricos.html","id":"siglo-xxi-1","chapter":"Históricos","heading":"Siglo XXI","text":"En el siglo XXI, México ha continuado avanzando en la inclusión y derechos de las personas con discapacidades. El XII Censo de Población y Vivienda del 2000 proporcionó datos relevantes sobre la población con discapacidad en el país. En 2005, se publicó la Ley General de las Personas con Discapacidad y se creó el Consejo Nacional para el Desarrollo y la Inclusión de las Personas con Discapacidad (CONADIS). En 2007, México ratificó la Convención sobre los Derechos de las Personas con Discapacidad y su Protocolo Facultativo, adoptados por la Asamblea General de las Naciones Unidas en 2006. En 2011, una reforma constitucional amplió los derechos humanos en México, incluyendo las personas con discapacidades.","code":""},{"path":"históricos.html","id":"avances-tecnológicos-y-educativos","chapter":"Históricos","heading":"Avances Tecnológicos y Educativos","text":"El desarrollo tecnológico en México ha permitido la creación de dispositivos avanzados que mejoran la movilidad y la comunicación, como sillas de ruedas motorizadas, software de reconocimiento de voz y prótesis biónicas. Los sistemas educativos han adoptado políticas más inclusivas, promoviendo la participación plena de estudiantes con discapacidades en aulas regulares mediante tecnologías de apoyo y metodologías pedagógicas adaptativas.","code":""},{"path":"históricos.html","id":"perspectivas-futuras","chapter":"Históricos","heading":"Perspectivas Futuras","text":"\nEl futuro de la discapacidad en México está marcado por un enfoque en la inclusión, accesibilidad y el respeto los derechos humanos. Los avances en tecnología asistiva, la educación inclusiva y la expansión de leyes que protegen los derechos de las personas con discapacidad continúan siendo una prioridad. Las campañas de sensibilización y educación pública están ayudando reducir el estigma y promover una mayor comprensión y aceptación de la discapacidad en la sociedad.\nReferencias\n- Alvarez Amézquita, José; Bustamante, Miguel E.; López P. Antonio y Fernández del Castillo Francisco (1960). Historia de la salubridad y de la asistencia en México. Tomo II. SSA. México.\n- Rocha, Arturo (2001). Nadie es ombligo en la tierra. Ayac xictli tlaltícpac. Discapacidad en el México antiguo, Cultura náhuatl. TELETON, Editorial Miguel Ángel Porrúa. México.\n- Fuentes, Mario Luis (1998). La asistencia social en México. Historia y perspectivas. Ediciones del\nMilenio. México, D.F.\n- Secretaría de Salud (SSA). (2003). Historia de la atención las personas con discapacidad en México. Ciudad de México: Secretaría de Salud.","code":""},{"path":"referencias-1.html","id":"referencias-1","chapter":"Referencias","heading":"Referencias","text":"CONAPO [Consejo Nacional de Población]. (2021a). Índice de marginación por entidad federativa y municipio 2020 Nota técnico-metodológica. (2021). Recuperado de: https://www.gob.mx/cms/uploads/attachment/file/685354/Nota_te_cnica_IMEyM_2020.pdf.\n_________. (2021b). Índice de marginación por localidad 2020 Nota técnico-metodológica. (2021). Recuperado de: https://www.gob.mx/cms/uploads/attachment/file/685308/Nota_t_cnica_IML_2020.pdf.DGIS [Dirección General de Información en Salud]. (2021). Catálogo de Clave Única de Establecimientos de Salud-CLUES. Recuperado de: http://www.dgis.salud.gob.mx/contenidos/sinais/s_clues.html.Dalenius y Hodges, J. L., Jr. (1959). Minimum variance stratification. Journal American Statistical Association, 54, 88-101. Gunning, P. y Horgan, J. M. (2004). new algorithm construction stratum boundaries skewed populations. Survey Methodology, 30 (2), 159–166.Gobierno de México. (2019). Plan Nacional de Desarrollo 2019-2024, Anexo XVIII-Bis, Gaceta Parlamentaria Número 5266-XVIII, Año XXII, Palacio Legislativo San Lázaro, México. Recuperado de: http://gaceta.diputados.gob.mx/PDF/64/2019/abr/20190430-XVIII-1.pdf (consultado el 16/11/2022).Gunning, P. y Horgan, J. M. (2004). new algorithm construction stratum boundaries skewed populations. Survey Methodology, 30 (2), 159–166.\nHidiroglou, M. . y Kozak, M. (2018). Stratification Skewed Populations: Comparison Optimizationbased versus Approximate Methods. International Statistical Review, 86 (1), 87–105. Recuperado de: https://doi.org/10.1111/insr.12230.Hubert, M. y Vandervieren, E. (2007). adjusted boxplot skewed distributions. ScienceDirect, 52 (12), 5186-5201. Recuperado de https://doi.org/10.1016/j.csda.2007.11.008.INEGI [Instituto Nacional de Estadística y Geografía]. (2020a). Recuperado de: Censo de Población y Vivienda 2020 https://www.inegi.org.mx/programas/ccpv/2020/\n_________. (2020b). Marco Geoestadístico Nacional 2020. Censo de Población y Vivienda 2020. Recuperado de: https://www.inegi.org.mx/temas/mg/\n_________. (2020c). Características del Entorno Urbano y Localidad. Recuperado de: https://www.inegi.org.mx/programas/ccpv/2020/\n_________. (2021). Directorio Estadístico Nacional de Unidades Económicas. Recuperado de: https:// www.inegi.org.mx/app/mapa/denue/\nINEGI-IMT/SCT (2020). Instituto Nacional de Estadística y Geografía (INEGI), Instituto Mexicano del Transporte (IMT) y la Secretaría de Comunicaciones y Transportes (SCT). Recuperado de: https://www.gob.mx/imt/acciones-y-programas/red-nacional-de-caminos..T. Jolliffe: “Principal Component Analysis”, Springer, 2002. ISBN: 978-0-387-22440-4Martens, H., Naes, T. (1989). Multivariate Calibration. John Wiley & Sons, Chichester, UK.Martens, H., Martens, M. (2001). Multivariate Analysis Quality. John Wiley & Sons, Chichester, UK.ONUHABITAT, (2022). Ciudades - Desarrollo Sostenible Recuperado de: https://www.un.org/sustainabledevelopment/es/cities/Pena Trapero, J. B. (1977). Problemas de la medición del bienestar y conceptos afines. Una aplicación al Caso Español. Madrid: INE.SEDESOL [Secretaría de Desarrollo Social]. (2012). Estructura del Sistema Normativo de Equipamiento. Recuperado de: http://cdam.unsis.edu.mx/files/Servicios%20publicos%20municipales/4%20Mercados/Sistema%20Normativo%20de%20Equipamiento%20Urbano%20SEDESOL.pdf.SIGED [Sistema de Información y Gestión Educativa]. (2021). Secretaría de Educación Pública (SEP). Recuperado de: http://snie.sep.gob.mx/SNIESC/ .Somarriba, N. (2008): Aproximación la medición de la calidad de vida en la Unión Europea. Tesis doctoral, dirigida por J. B. Pena, defendida el 11 de abril de 2008. Facultad de Ciencias Económicas y Empresariales. Universidad de Valladolid. Recuperado de: www.eumed.net/tesis-doctorales/2010/mnsa/index.htm.Somarriba, N. y Pena, B. (2009a): Synthetic Indicators Quality Life Europe. Social Indicators Research, doi 10.1007/s11205-008-9356-y. Recuperado de: https://link.springer.com/referenceworkentry/10.1007%2F978-94-007-0753-5_3729.Somarriba, N. y Pena, B. (2009b): La medición de la calidad de vida en Europa, el papel de la información subjetiva. Estudios de economía aplicada, Vol. 27(2).Somarriba, N. y Pena, B. (2010): Un análisis dinámico de la Calidad de Vida y de la Convergencia en Europa. Anales de Estudios Económicos y Empresariales, núm. 20, pp. 283-324.Zarzosa, P. (Dir.) (2005): La calidad de vida en los municipios de la provincia de Valladolid. Valladolid: Diputación Provincial de Valladolid.Zarzosa, P. (2009): Estimación de la pobreza en las Comunidades Autónomas españolas, mediante la Distancia DP2 de Pena. Estudios de Economía Aplicada, Vol. 27(2), pp. 397-416.Zarzosa, P. (2012): Social Welfare Spain Crisis: Territorial Chronological Analysis. International Journal Advances Management Economics. Vol. 1, núm. 4, pp. 165-171.Zarzosa, P. y Somarriba, N. (2013): Assessment Social Welfare Spain: Territorial Analysis Using Synthetic Welfare Indicator. Social Indicators Research, Vol. 111, pp. 1-23.Las librerías que se usaron para este projecto.Nota:\nhttps://www.yotambien.mx/opinion/los-factores-ambientales-y-la-discapacidadArtículos\nhttps://www.gob.mx/cms/uploads/attachment/file/869213/Articulo_3_Parte1.pdfhttps://www.gob.mx/cms/uploads/attachment/file/869214/Articulo_3_Parte2.pdfpágina y la metodología\nhttps://www.gob.mx/conapo/documentos/indice-de-calidad-del-entorno?idiom=eshttps://www.gob.mx/cms/uploads/attachment/file/784373/Nota_t_cnica_ICE_2020.pdfDOF del Índice de Calidad del Entorno\nhttps://www.dof.gob.mx/nota_detalle.php?codigo=5715917&fecha=02/02/2024#gsc.tab=0Norma Oficial de Discapacidad\nhttps://dof.gob.mx/nota_detalle.php?codigo=5715918&fecha=02/02/2024#gsc.tab=0Metodología\nhttps://dvillasanao.github.io/ICE_2020/","code":"\nsesion_info <- devtools::session_info()"}]
